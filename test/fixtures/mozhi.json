{
  "rss": {
    "$": {
      "version": "2.0"
    },
    "channel": [
      {
        "title": [
          "nuysoft's blog"
        ],
        "description": [
          "nuysoft's blog - nuysoft"
        ],
        "link": [
          "http://nuysoft.github.com",
          "http://nuysoft.github.com"
        ],
        "lastBuildDate": [
          "2013-09-02T09:12:10-07:00"
        ],
        "pubDate": [
          "2013-09-02T09:12:10-07:00"
        ],
        "ttl": [
          "1800"
        ],
        "item": [
          {
            "title": [
              "在 JavaScript 中保护对象"
            ],
            "description": [
              "\n\n<!-- This blog post is a quick refresher of how objects can be protected in JavaScript. There are three levels of protection: -->\n\n\n<p>这篇博客旨在快速复习如何在 JavaScript 中保护对象。有 3 种程度的保护：</p>\n\n<!-- 1. Preventing extensions is the weakest level,\n1. sealing is stronger,\n1. freezing is strongest. -->\n\n\n<ol>\n<li>最弱的是阻止扩展，</li>\n<li>稍强的是封闭对象，</li>\n<li>最强的是冻结对象。</li>\n</ol>\n\n\n<!-- ## Preventing extension -->\n\n\n<h2>阻止扩展</h2>\n\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/preventExtensions\">Object.preventExtensions(obj)</a></p>\n\n<!-- makes it impossible to add properties to obj. Example: -->\n\n\n<p>使对象不能再添加属性。例如</p>\n\n<pre><code>var obj = { foo: 'a' };\nObject.preventExtensions(obj);\n</code></pre>\n\n<!-- Now adding a propert fails silently in sloppy mode: -->\n\n\n<p>现在，在宽松模式下添加属性会静默失败：</p>\n\n<pre><code>&gt; obj.bar = 'b';\n&gt; obj.bar\nundefined\n</code></pre>\n\n<!-- And throws an error in strict mode [1](#[1]), which we switch to via an IIFE [2](#[2]). -->\n\n\n<p>而在严格模式<a href=\"#[1]\">[1]</a>下会抛出一个错误，我们通过一个 IIFE<a href=\"#[2]\">[2]</a> 使用严格模式。</p>\n\n<pre><code>&gt; (function () { 'use strict'; obj.bar = 'b' }());\nTypeError: Can't add property bar, object is not extensible\n</code></pre>\n\n<!-- You can still delete properties, though. -->\n\n\n<p>但是，仍然可以删除属性。</p>\n\n<pre><code>&gt; delete obj.foo\ntrue\n&gt; obj.foo\nundefined\n</code></pre>\n\n<!-- ### Checking whether an object is extensible -->\n\n\n<h3>检查对象是否可扩展</h3>\n\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isExtensible\">Object.isExtensible(obj)</a></p>\n\n<!-- checks whether obj is extensible: -->\n\n\n<p>检查 obj 是否可扩展：</p>\n\n<pre><code>&gt; Object.isExtensible(obj)\nfalse\n</code></pre>\n\n<!-- ## Sealing -->\n\n\n<h2>封闭对象</h2>\n\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/seal\">Object.seal(obj)</a></p>\n\n<!-- prevents extensions and makes all properties “unconfigurable”. The latter means that the attributes [3](#[3]) of properties can’t be changed, any more. Read-only properties stay read-only, enumerable properties stay enumerable, etc. -->\n\n\n<p>阻止扩展，并使所有属性“不可配置”。后者意味着属性的特性不可修改。只读的属性保持只读，可枚举的属性仍可枚举，等等。</p>\n\n<!-- (As an aside, JavaScript does allow you to change an unconfigurable property from writable to read-only, due to [historical reasons](http://stackoverflow.com/questions/9829817/why-can-i-set-enumerability-and-writability-of-unconfigurable-property-descripto/9843191#9843191).) -->\n\n\n<p>（顺便说一句，因为<a href=\"http://stackoverflow.com/questions/9829817/why-can-i-set-enumerability-and-writability-of-unconfigurable-property-descripto/9843191#9843191\">历史原因</a>，JavaScript 允许把不可配置的属性从可写改为只读。）</p>\n\n<!-- The following example demonstrates that sealing makes all properties unconfigurable. -->\n\n\n<p>下面的例子演示了封闭使所有属性不可配置。</p>\n\n<pre><code>&gt; var obj = { foo: 'a' };\n\n&gt; Object.getOwnPropertyDescriptor(obj, 'foo')  // before sealing\n{ value: 'a',\n  writable: true,\n  enumerable: true,\n  configurable: true }\n\n&gt; Object.seal(obj)\n\n&gt; Object.getOwnPropertyDescriptor(obj, 'foo')  // after sealing\n{ value: 'a',\n  writable: true,\n  enumerable: true,\n  configurable: false }\n</code></pre>\n\n<!-- You can still change the property foo: -->\n\n\n<p>你仍然可以改变属性 foo：</p>\n\n<pre><code>&gt; obj.foo = 'b';\n'b'\n&gt; obj.foo\n'b'\n</code></pre>\n\n<!-- But you can’t change its attributes: -->\n\n\n<p>但是你不能改变它的特性：</p>\n\n<pre><code>&gt; Object.defineProperty(obj, 'foo', { enumerable: false });\nTypeError: Cannot redefine property: foo\n</code></pre>\n\n<p>Additionally, obj is not extensible, any more.\n此外，obj 不再可扩展。</p>\n\n<!-- ### Checking whether an object is sealed -->\n\n\n<h3>检查对象是否是封闭的</h3>\n\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isSealed\">Object.isSealed(obj)</a></p>\n\n<!-- checks whether obj is sealed: -->\n\n\n<p>检查 obj 是否是封闭的：</p>\n\n<pre><code>&gt; Object.isSealed(obj)\ntrue\n</code></pre>\n\n<!-- ## Freezing -->\n\n\n<h2>冻结对象</h2>\n\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze\">Object.freeze(obj)</a></p>\n\n<!-- makes all properties non-writable and seals obj. That is, obj is not extensible, all properties are read-only and there is no way to change that. -->\n\n\n<p>是所有属性不可写，并封闭对象。也就是说，对象不可扩展，所有属性为只读并不可修改。</p>\n\n<pre><code>var point = { x: 17, y: -5 };\nObject.freeze(point);\n</code></pre>\n\n<!-- Once again, you get silent failures in sloppy mode: -->\n\n\n<p>在宽松模式中，将再次静默失败：</p>\n\n<pre><code>&gt; point.x = 2;  // no effect, point.x is read-only\n&gt; point.x\n17\n\n&gt; point.z = 123;  // no effect, point is not extensible\n&gt; point\n{ x: 17, y: -5 }\n</code></pre>\n\n<!-- And errors in strict mode: -->\n\n\n<p>在严格模式中则抛出一个错误：</p>\n\n<pre><code>&gt; (function () { 'use strict'; point.x = 2 }());\nTypeError: Cannot assign to read-only property 'x'\n\n&gt; (function () { 'use strict'; point.z = 123 }());\nTypeError: Can't add property z, object is not extensible\n</code></pre>\n\n<!-- ### Checking whether an object is frozen -->\n\n\n<h3>检查对象是否是冻结的</h3>\n\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isFrozen\">Object.isFrozen(obj)</a></p>\n\n<!-- checks whether obj is frozen: -->\n\n\n<p>检查 obj 是否是冻结的：</p>\n\n<pre><code>&gt; Object.isFrozen(point)\ntrue\n</code></pre>\n\n<!-- ## References -->\n\n\n<h2>参考文献</h2>\n\n<p><a name=\"[1]\"></a>\n<a name=\"[2]\"></a></p>\n\n<ol>\n<li><a href=\"http://www.2ality.com/2011/01/javascripts-strict-mode-summary.html\">JavaScript’s strict mode: a summary</a></li>\n<li><a href=\"http://www.2ality.com/2011/02/javascript-variable-scoping-and-its.html\">JavaScript variable scoping and its pitfalls</a></li>\n<li><a href=\"http://www.2ality.com/2012/10/javascript-properties.html\">Object properties in JavaScript</a></li>\n</ol>\n\n\n<hr>\n\n\n<blockquote><p>原文：<a href=\"http://www.2ality.com/2013/08/protecting-objects.html\">Protecting objects in JavaScript</a></p></blockquote>\n\n<p><link href=\"/assets/codemirror/lib/codemirror.css\" rel=\"stylesheet\">\n<link href=\"/assets/codemirror/theme/neat.css\" rel=\"stylesheet\"></p>\n\n<script src=\"/assets/codemirror/lib/codemirror.js\"></script>\n\n\n<script src=\"/assets/codemirror/addon/runmode/runmode.js\"></script>\n\n\n<script src=\"/assets/codemirror/mode/javascript/javascript.js\"></script>\n\n\n<script type=\"text/javascript\">\n    $('pre').each(function(index, el){\n        $(this).hide()\n        var ctn = $('<pre class=\"cm-s-neat\">').insertAfter(this)\n        CodeMirror.runMode($(this).find('code').text(), 'javascript',\n                 ctn.get(0));\n    })\n</script>\n\n"
            ],
            "link": [
              "http://nuysoft.github.com/2013/09/02/protecting-objects-in-javascript"
            ],
            "guid": [
              "http://nuysoft.github.com/2013/09/02/protecting-objects-in-javascript"
            ],
            "pubDate": [
              "2013-09-02T00:00:00-07:00"
            ]
          },
          {
            "title": [
              "异步编程"
            ],
            "description": [
              "\n\n<!-- Managing asynchronous operations is a necessity when working in JavaScript, and it can be messy business, especially when it comes to error handling. -->\n\n\n<p>当使用 JavaScript 开发时，对异步操作的管理是必要的，然后它可能是凌乱的，特别是当它处理错误时。</p>\n\n<!-- This lesson covers asynchronous error handling pitfalls, and shows how promises can provide familiar synchronous programming patterns for asynchronous operations. -->\n\n\n<p>本系列涵盖了异步错误处理陷阱，并展示了 Promise 如何为异步操作提供友好的同步编程模型。</p>\n\n<ul>\n  \n    \n  \n    \n  \n    \n      \n        <li>\n            <a href=\"/2013/08/28/async-programming-is-messy\">凌乱的异步编程</a>\n            <br>\n            <span>Async Programming is Messy。</span>\n        </li>\n      \n    \n  \n    \n      \n        <li>\n            <a href=\"/2013/08/27/simplifying-async-with-promises\">用 Promises 简化异步编程</a>\n            <br>\n            <span>Simplifying Async with Promises。</span>\n        </li>\n      \n    \n  \n    \n      \n        <li>\n            <a href=\"/2013/08/26/mastering-async-error-handling-with-promises\">用 Promises 控制异步错误处理</a>\n            <br>\n            <span>Mastering Async Error Handling with Promises。</span>\n        </li>\n      \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n</ul>\n\n"
            ],
            "link": [
              "http://nuysoft.github.com/2013/08/29/async-programming"
            ],
            "guid": [
              "http://nuysoft.github.com/2013/08/29/async-programming"
            ],
            "pubDate": [
              "2013-08-29T00:00:00-07:00"
            ]
          },
          {
            "title": [
              "凌乱的异步编程"
            ],
            "description": [
              "\n\n<!-- ## Exceptions and try/catch -->\n\n\n<h2>异常和 try/catch</h2>\n\n<!-- Exceptions and try/catch are an intuitive way to execute operations that may fail. They allow us to recover from the failure, or to let the failure propagate up the call stack to a caller by either not catching the exception, or explicitly re-throwing it. -->\n\n\n<p>当执行可能失败的操作时，异常和 try/catch 是一种直观的操作。通过这种方式，我们可以从失败中恢复，也可以不捕获异常，或者明确地将异常再次抛出，让异常沿着调用栈向上传播到调用者。</p>\n\n<!-- Here's a simple example: -->\n\n\n<p>下面是一个简单的例子：</p>\n\n<pre><code>function thisMightFail() {\n    //...\n    if(badThingsHappened) {\n        throw new Error(...);\n    }\n\n    return theGoodResult;\n}\n\nfunction recoverFromFailure(e) {\n    //...\n    return recoveryValue;\n}\n\nfunction getTheResult() {\n\n    var result;\n\n    try {\n        result = thisMightFail();\n    } catch(e) {\n        result = recoverFromFailure(e);\n    }\n\n    return result;\n}\n</code></pre>\n\n<!-- In this case, `getTheResult` handles the case where `thisMightFail` does indeed fail and throws an `Error` by catching the `Error` and calling `recoverFromFailure` (which could return some default result, for example). This works because `thisMightFail` is synchronous. -->\n\n\n<p>在这个例子中，当 <code>thisMightFail</code> 失败并抛出一个 <code>Error</code> 时，<code>getTheResult</code> 捕获抛出的 <code>Error</code>，并调用 <code>recoverFromFailure</code>（例如，可以返回某个默认结果）。这个例子之所以能够工作，是因为 <code>thisMightFail</code> 是同步的。</p>\n\n<!-- ## Going Async -->\n\n\n<h2>面向异步</h2>\n\n<!-- What if `thisMightFail` is *asynchronous*? For example, it may perform an asynchronous XHR to fetch the result data: -->\n\n\n<p>如果 <code>thisMightFail</code> 是<em>异步</em>的会如何呢？例如，它可能执行一个异步的 XHR 来获取数据：</p>\n\n<pre><code>function thisMightFail(callback, errback) {\n    xhrGet('/result', callback, errback);\n}\n</code></pre>\n\n<!--Now it's impossible to use try/catch, and we have to supply a callback and errback to handle the success and failure cases. That's pretty common in Javascript applications, so no big deal, right? But wait, now `getTheResult` also has to change:-->\n\n\n<p>现在使用 try/catch 是不可能的了，我们必须提供一个 callback 和 errback 来处理成功和失败的情况。这在 JavaScript 应用程序中相当常见，所以没什么大不了的，真是这样吗？先别急，现在 <code>getTheResult</code> 也需要改变：</p>\n\n<pre><code>function getTheResult(callback) {\n\n    // Simulating the catch-and-recover behavior of try/catch\n    thisMightFail(callback, function(e) {\n\n        var result = recoverFromFalure(e);\n        callback(result);\n\n    });\n\n}\n</code></pre>\n\n<!--At the very least, `callback` (and possibly `errback`, read on) must now be added to every function signature all the way back up to the caller who is ultimately interested in the result.-->\n\n\n<p>现在，对最终执行结果感兴趣的调用方，必须至少为每个函数签名增加 <code>callback</code>（也可能是 <code>errback</code>，请继续往下读）。</p>\n\n<!-- ## More Async -->\n\n\n<h2>更多异步</h2>\n\n<!--If `recoverFromFailure` is also asynchronous, we have to add yet another level of callback nesting:-->\n\n\n<p>如果 <code>recoverFromFailure</code> 也是异步的，我们不得不再添加一层嵌套的回调函数：</p>\n\n<pre><code>function getTheResult(callback) {\n\n    // Simulating the catch-and-recover behavior of try/catch\n    thisMightFail(callback, function(e) {\n\n        recoverFromFailure(callback, function(e) {\n            // What do we do here?!?!\n        });\n\n    });\n}\n</code></pre>\n\n<!--This also raises the question of what to do if `recoverFromFailure` itself fails. When using synchronous try/catch, `recoverFromFailure` could simply throw an `Error` and it would propagate up to the code that called `getTheResult`. To handle an asynchronous failure, we have to introduce another `errback`, resulting in both `callback` and `errback` infiltrating every function signature from `recoverFromFailure` all the way up to a caller who must ultimately supply them.-->\n\n\n<p>这就提出了另一个问题：如果 <code>recoverFromFailure</code> 失败了该如何处理呢？当使用同步的 try/catch 时，<code>recoverFromFailure</code> 可以简单的抛出一个 <code>Error</code>，<code>Error</code> 将传播到调用 <code>getTheResult</code> 的代码。为了处理异步失败，我们不得不引入另一个 <code>errback</code>，这就导致在从 <code>recoverFromFailure</code> 到调用方的路径上，<code>callback</code> 和 <code>errback</code> 侵入了每个函数的签名，而且调用方必须提供它们。</p>\n\n<!--It may also mean that we have to check to see if callback and errback were actually provided, and if they might throw exceptions:-->\n\n\n<p>这也可能意味着我们不得不检查是否真地提供了 callback 和 errback，以及它们是否会抛出异常：</p>\n\n<pre><code>function thisMightFail(callback, errback) {\n    xhrGet('/result', callback, errback);\n}\n\nfunction recoverFromFailure(callback, errback) {\n    recoverAsync(\n        function(result) {\n            if(callback) {\n                try {\n                    callback(result);\n                } catch(e) {\n                    // Ok, callback threw an exception, let's switch to errback\n                    // At least this will let the caller know that something went wrong.\n                    // But now, both the callback and errback will have been called, and\n                    // and the developer may not have accounted for that!\n                    errback(e);\n                }\n            }\n        },\n        function(error) {\n            if(errback) {\n                try {\n                    errback(error);\n                } catch(ohnoes) {\n                    // What do we do now?!?\n                    // We could re-throw or not catch at all, but no one can catch\n                    // the exception because this is all asynchronous.\n                    // And now console.error has infiltrated deep into our code, too!\n                    console.error(ohnoes);\n                }\n            }\n        }\n    );\n}\n\nfunction getTheResult(callback, errback) {\n\n    // Simulating the catch-and-recover behavior of try/catch\n    thisMightFail(callback, function(e) {\n\n        recoverFromFailure(callback, errback);\n\n    });\n\n}\n</code></pre>\n\n<!--The code has gone from a simple try/catch to deeply nested callbacks, with `callback` and `errback` in every function signature, plus additional logic to check whether it's safe to call them, and, ironically, *two try/catch blocks* to ensure that `recoverFromFailure` can indeed recover from a failure.-->\n\n\n<p>这段代码已经从一个简答的 try/catch 变为深度嵌套的回调函数，每个函数的签名需要增加 <code>callback</code> 和 <code>errback</code>，需要增加额外的逻辑来检查是否可以安全地调用它们，而且讽刺的是，需要用<em>两个 try/catch 块</em>来确保 <code>recoverFromFailure</code> 真的可以从失败中恢复。</p>\n\n<!--## And what about finally?-->\n\n\n<h2>如何处理 finally？</h2>\n\n<!--Imagine if we were also to introduce `finally` into the mix--things would need to become even more complex. There are essentially two options, neither of which is as simple and elegant as the language-provided `finally` clause. We could: 1) add an `alwaysback` callback to all function signatures, with the accompanying checks to ensure it is safely callable, or 2) always write our callback/errback to handle errors internally, and be sure to invoke `alwaysback` in all cases.-->\n\n\n<p>试想一下，如果我们再将 <code>finally</code> 引入这种混乱的实现方式，事情必然会变得更复杂。基本上有两种选择：1) 为所有方法的签名增加一个 <code>alwaysback</code> 回调函数，并做相应的检查以确保可以安全地调用它，或者 2) 在 callback/errback 的内部处理异常，并确保总是会调用 <code>alwaysback</code>。然后无论哪种选择都不如语言所提供的 <code>finally</code> 简单和优雅。</p>\n\n<!--## Summary-->\n\n\n<h2>总结</h2>\n\n<!--Using callbacks for asynchronous programming changes the basic programming model, creating the following situation:-->\n\n\n<p>在异步编程中使用回调函数改变了传统的编程模型，并且引发了下面的问题：</p>\n\n<!--1. We can no longer use a simple call-and-return programming model\n1. We can no longer handle errors using try/catch/finally\n1. We must add callback and errback parameters to every function signature that might eventually lead to an asynchronous operation-->\n\n\n<ol>\n<li>我们再也不能使用简单的调用-返回编程模型。</li>\n<li>我们再也不能使用 try/catch/finally 来处理异常。</li>\n<li>我们必须为可能执行异步操作的每个函数的签名增加 callback 和 errback 参数。</li>\n</ol>\n\n\n<!--We can do better. There is another model for asynchronous programming in Javascript that more closely resembles standard call-and-return, follows a model more like try/catch/finally, and doesn't force us to add two callback parameters to a large number of functions.-->\n\n\n<p>事实上我们可以做得更好。在 JavaScript 中，还有另一种异步编程模型，更接近于标准的调用-返回模型，非常类似于 try/catch/finally，并且不会强迫我们为大量的函数增加两个回调函数参数。</p>\n\n<!--Next, we'll look at [Promises](http://know.cujojs.com/tutorials/async/simplifying-async-with-promises.html.md), and how they help to bring asynchronous programming back to a model that is simpler and more familiar.-->\n\n\n<p>下一步，我们将看看 <a href=\"http://know.cujojs.com/tutorials/async/simplifying-async-with-promises.html.md\">Promises</a>，以及它们如何帮助异步编程回归到更简单、更友好的模型。</p>\n\n<hr>\n\n\n<blockquote><p>原文：<a href=\"http://know.cujojs.com/tutorials/async/async-programming-is-messy\">Async Programming is Messy</a></p></blockquote>\n\n<p><link href=\"/assets/codemirror/lib/codemirror.css\" rel=\"stylesheet\">\n<link href=\"/assets/codemirror/theme/neat.css\" rel=\"stylesheet\"></p>\n\n<script src=\"/assets/codemirror/lib/codemirror.js\"></script>\n\n\n<script src=\"/assets/codemirror/addon/runmode/runmode.js\"></script>\n\n\n<script src=\"/assets/codemirror/mode/javascript/javascript.js\"></script>\n\n\n<script type=\"text/javascript\">\n    $('pre').each(function(index, el){\n        $(this).hide()\n        var ctn = $('<pre class=\"cm-s-neat\">').insertAfter(this)\n        CodeMirror.runMode($(this).find('code').text(), 'javascript',\n                 ctn.get(0));\n    })\n</script>\n\n"
            ],
            "link": [
              "http://nuysoft.github.com/2013/08/28/async-programming-is-messy"
            ],
            "guid": [
              "http://nuysoft.github.com/2013/08/28/async-programming-is-messy"
            ],
            "pubDate": [
              "2013-08-28T00:00:00-07:00"
            ]
          },
          {
            "title": [
              "用 Promises 简化异步编程"
            ],
            "description": [
              "\n\n<!-- In [Async Programming is Messy](http://know.cujojs.com/tutorials/async/async-programming-is-messy.html.md), we looked at the awkward situation created when we introduce callbacks to handle even a single asynchronous operation into an otherwise simple set of function calls. -->\n\n\n<p>在 <a href=\"/2013/08/26/async-programming-is-messy\">凌乱的异步编程</a> 一文中，当为一组简单的函数调用引入回调函数时，我们看到的是一副尴尬的局面，即使是用这种方式来处理单个异步操作。</p>\n\n<!-- As a quick review, have a look back at the code we started with, the messy end result when using callbacks, and the things we'd like to fix in order to get back to sanity: -->\n\n\n<p>快速回顾一下，看看我们最初的代码、使用回调函数时的凌乱结果，以及我们为了回到正途而想要解决的几个问题：</p>\n\n<!-- 1. We can no longer use a simple call-and-return programming model\n1. We can no longer handle errors using try/catch/finally\n1. We must add callback and errback parameters to every function signature that might eventually lead to an asynchronous operation -->\n\n\n<ol>\n<li>我们再也不能使用简单的调用-返回编程模型。</li>\n<li>我们再也不能使用 try/catch/finally 来处理异常。</li>\n<li>我们必须为可能执行异步操作的每个函数的签名增加 callback 和 errback 参数。</li>\n</ol>\n\n\n<h2>Promises</h2>\n\n<!-- A Promise (aka Future, Delayed value, Deferred value) represents a value that is not yet available because the computation that will produce the value has not yet completed. A Promise is a placeholder into which the successful result or reason for failure will eventually materialize. -->\n\n\n<p>一个 Promise（又名 Future, Delayed value, Deferred value）代表一个尚不可用的值，因为产生这个值的计算过程尚未完成。一个 Promise 是最终的成功结果或失败原因的占位符。</p>\n\n<blockquote><p>在《jQuery技术内幕》一书中，把 Deferred 称为“异步队列”，把 Promise 称为“异步队列的只读副本”。</p></blockquote>\n\n<!-- Promises also provide a simple API (see note below) for being notified when the result has materialized, or when a failure has occured. -->\n\n\n<p>Promises 还提供了一个简单的 API（见下文），用于在结果完成或故障发生时获取通知。</p>\n\n<!-- Promises are [not a new concept](http://en.wikipedia.org/wiki/Futures_and_promises), and have been implemented in many languages. While several implementations of the Promise concept in Javascript have been around for a while, they have started to gain more popularity recently as we start to build bigger, more complex systems that require coordinating more asynchronous tasks. -->\n\n\n<p>Promises <a href=\"http://en.wikipedia.org/wiki/Futures_and_promises\">不是一个新概念</a>，已经在许多语言中被实现。在 JavaScript 中，Promise 概念的实现已经有一段时间了，并且最近变得更加流行，因为我们开始构建更庞大、更复杂的系统，需要协调更多的异步任务。</p>\n\n<!-- (NOTE: Although there are [several proposed](http://wiki.commonjs.org/wiki/Promises) Promise API standards, [Promises/A+](http://promises-aplus.github.io/promises-spec/) has been implemented in several major frameworks, and appears to be becoming the defacto standard. In any case, the basic concepts are the same: 1) Promises act as a placeholder for a result or error, 2) they provide a way to be notified when the actual result has materialized, or when a failure has occurred.) -->\n\n\n<p>（注意：虽然 Promise API 标准存在<a href=\"http://wiki.commonjs.org/wiki/Promises\">多个提案</a>，但是 <a href=\"http://promises-aplus.github.io/promises-spec/\">Promises/A+</a> 已经在多个主流框架中被实现，似乎正在成为事实上的标准。无论哪种提案，基本的概念是相同的：1) Promises 作为结果或错误的占位符，2) 提供了一种在结果完成或错误发生时的通知方式。）</p>\n\n<!-- ## The Canonical XHR Example -->\n\n\n<h2>典型的 XHR 示例</h2>\n\n<!-- In the case of an XHR Get, the value we care about is the content of the url we're fetching. We know that XHR is an asynchonous operation, and that the value won't be available immediately. That fits the definition of a Promise perfectly. -->\n\n\n<p>在 XHR Get 示例中，我们关注的是获取 url 的内容。我们知道 XHR 是一个异步操作，值不会立即可用。这种情况完全符合一个 Promise 的定义。</p>\n\n<!-- Imagine that we have an XHR library that immediately returns a Promise, as a placeholder for the content, instead of requiring us to pass in a callback. We could rewrite our asynchronous `thisMightFail` function from Part 1 to look like this: -->\n\n\n<p>假设我们有一个 XHR 库，它立即返回一个 Promise 作为内容的占位符，而不是要求我们传入一个回调函数。我们可以重写 <a href=\"/2013/08/28/async-programming-is-messy/\">Part 1</a> 中的异步函数 <code>thisMightFail</code>，就像这样：</p>\n\n<pre><code>function thisMightFail() {\n    // Our XHR library returns a promise placeholder for the\n    // content of the url.  The XHR itself will execute later.\n    var promise = xhrGet('/result');\n\n    // We can simply return the promise to our caller as if\n    // it is the actual value.\n    return promise;\n}\n</code></pre>\n\n<!-- (Note that several popular Javascript libraries, including [Dojo](http://dojotoolkit.org/reference-guide/dojo/xhrGet.html) (see also this [great article on Dojo's Deferred](http://dojotoolkit.org/documentation/tutorials/1.6/deferreds/) by [@bryanforbes](https://twitter.com/bryanforbes)) and [jQuery](http://api.jquery.com/Types/#jqXHR), implement XHR operations using promises) -->\n\n\n<p>（需要注意的是，一些流行的 JavaScript 库，包括 <a href=\"https://twitter.com/bryanforbes\">@bryanforbes</a> 的 <a href=\"http://dojotoolkit.org/reference-guide/dojo/xhrGet.html\">Dojo</a>（请参考 <a href=\"http://dojotoolkit.org/documentation/tutorials/1.6/deferreds/\">great article on Dojo's Deferred</a>） 和 <a href=\"http://api.jquery.com/Types/#jqXHR\">jQuery</a>，使用了 Promises 来实现 XHR 操作）</p>\n\n<!-- Now, we can return the Promise placeholder *as if it were the real result*, and our asynchronous `thisMightFail` function looks very much like a plain old synchronous, call-and-return operation. -->\n\n\n<p>现在，我们可以返回 Promise 占位符，就像它是真正的结果，并且异步函数 <code>thisMightFail</code> 看起来非常像传统的同步操作和调用-返回操作。</p>\n\n<!-- ## Taking Back the Stack -->\n\n\n<h2>调用栈</h2>\n\n<!-- In a non-callback world, results and errors flow back *up* the call stack. This is expected and familiar. In a callback-based world, as we've seen, results and errors no longer follow that familiar model, and instead, callbacks must flow *down*, deeper into the stack. -->\n\n\n<p>在一个没有回调函数的世界里，结果和错误沿着调用栈<em>向上</em>回传。这是一种符合预期和友好的模式。而在一个基于回调函数的世界里，正如我们已经看到的，结果和错误不再遵循这种熟悉的模式，回调函数必须*向下传递，深入调用栈。</p>\n\n<!-- By using Promises, we can restore the familiar call-and-return programming model, and remove the callbacks. -->\n\n\n<p>通过使用 Promises，我们可以恢复到熟悉的调用-返回编程模型，并移除回调函数。</p>\n\n<!-- ### Restoring Call-and-return -->\n\n\n<h3>恢复调用-返回编程模型</h3>\n\n<!-- To see how this works, let's start with a simplified version of the [synchronous `getTheResult` function from Part 1](http://know.cujojs.com/tutorials/async/async-programming-is-messy.html.md), without try/catch so that exceptions will always propagate up the call stack. -->\n\n\n<p>为了看看它是如何工作的，让我们从 <a href=\"/2013/08/28/async-programming-is-messy/\">Part 1</a> 简化版本的同步函数 <code>getTheResult</code> 开始，不使用 try/catch，这样异常将总是沿着调用栈向上传播。</p>\n\n<pre><code>function thisMightFail() {\n    //...\n    if(badThingsHappened) {\n        throw new Error(...);\n    }\n\n    return theGoodResult;\n}\n\nfunction getTheResult() {\n    // Return the result of thisMightFail, or let the exception\n    // propagate.\n    return thisMightFail();\n}\n</code></pre>\n\n<!-- Now let's introduce the asynchronous `thisMightFail` from above that uses our Promise-based XHR lib. -->\n\n\n<p>现在，让我们为上面的代码引入异步的 <code>thisMightFail</code>，它使用了基于 Promise 的 XHR 库。</p>\n\n<pre><code>function thisMightFail() {\n    // Our XHR library returns a promise placeholder for the\n    // content of the url.  The XHR itself will execute later.\n    var promise = xhrGet('/result');\n\n    // We can simply return the promise to our caller as if\n    // it is the actual value.\n    return promise;\n}\n\nfunction getTheResult() {\n    // Return the result of thisMightFail, which will be a Promise\n    // representing a future value or failure\n    return thisMightFail();\n}\n</code></pre>\n\n<!-- Using Promises, `getTheResult()` is identical in the synchronous and asynchronous cases! And in both, the successful result *or the failure* will propagate *up* the stack to the caller. -->\n\n\n<p>使用 Promises 时，<code>getTheResult()</code> 在同步和异步情况下是相同的！并且在这两种情况下，成功结果或<em>失败</em>将沿着调用栈传播到调用者。</p>\n\n<!-- ### Removing Callbacks -->\n\n\n<h3>移除回调函数</h3>\n\n<!-- Notice also that there are no callbacks or errbacks (or alwaysbacks!) being passed down the callstack, and they haven't polluted any of our function signatures. By using Promises, our functions now *look and act* like the familiar, synchronous, call-and-return model. -->\n\n\n<p>还要注意到的是，没有向调用栈传入回调函数或错误回调函数（或总是执行的回调函数！），也没有污染任何函数的签名。通过使用 Promises，现在我们的函数的<em>外观和行为</em>就像友好的、同步的调用-返回编程模型。</p>\n\n<!-- ### Done? -->\n\n\n<h3>完成了吗？</h3>\n\n<!-- We've used Promises to refactor our simplified `getTheResult` function, and fix two of the problems we identified in Part 1. We've: -->\n\n\n<p>我们已经使用 Promises 重构了简单的 <code>getTheResult</code> 函数，并且解决了在 <a href=\"/2013/08/28/async-programming-is-messy/\">Part 1</a> 提出的的两个问题。我们已经：</p>\n\n<!-- 1. restored call-and-return\n1. removed callback/errback/alwaysback parameter propagation -->\n\n\n<ol>\n<li>恢复了调用-返回编程模型</li>\n<li>移除了参数 callback/errback/alwaysback 的传播</li>\n</ol>\n\n\n<!-- But, what does this mean for callers of `getTheResult`? Remember that we're returning a Promise, and eventually, either the successful result (the result of the XHR) or an error will materialize into the Promise placeholder, at which point the caller will want to take some action. -->\n\n\n<p>但是，这对 <code>getTheResult</code> 的调用者意味着什么呢？别忘了，我们返回的是一个 Promise，并且，无论成功结果（XHR 的结果）或错误最终将落实到占位符 Promise，到那时，调用者将需要采取一些行动。</p>\n\n<!-- ## What about the Caller? -->\n\n\n<h2>对调用者如何？</h2>\n\n<!-- As mentioned above, Promises provide an API for being notified when either the result or failure becomes available. For example, in the proposed Promises/A spec, a Promise has a `.then()` method, and many promise libraries provide a `when()` function that achieves the same goal. -->\n\n\n<p>正如上面所提到的，Promises 提供了一个 API，用于在结果或错误可用时获取通知。例如，在 Promises/A 规范提案中，一个 Promise 含有一个 <code>.then()</code> 方法，而且许多 Promise 库提供了一个 <code>when()</code> 函数来实现同样的目标。</p>\n\n<!-- First, let's look at what the calling code might look like when using the callback-based approach: -->\n\n\n<p>首先，让我们看看在使用基于回调函数的方式时，调用代码可能是什么样子：</p>\n\n<pre><code>// Callback-based getTheResult\ngetTheResult(\n    function(theResult) {\n        // theResult will be the XHR reponse content\n        resultNode.innerHTML = theResult;\n    },\n    function(error) {\n        // error will be an indication of why the XHR failed, whatever\n        // the XHR lib chooses to supply.  For example, it could be\n        // an Error.\n        errorNode.innerHTML = error.message;\n    }\n);\n</code></pre>\n\n<!-- Now, let's look at how the caller can use the Promise that `getTheResult` returns using the Promises/A `.then()` API. -->\n\n\n<p>现在，让我们看看调用者如何通过 Promises/A API <code>.then()</code> 使用 <code>getTheResult</code> 所返回的 Promise。</p>\n\n<pre><code>// Call promise-based getTheResult and get back a Promise\nvar promise = getTheResult();\n\npromise.then(\n    function(theResult) {\n        // theResult will be the XHR reponse content\n        resultNode.innerHTML = theResult;\n    },\n    function(error) {\n        // error will be an indication of why the XHR failed, whatever\n        // the XHR lib chooses to supply.  For example, it could be\n        // an Error.\n        errorNode.innerHTML = error.message;\n    }\n);\n</code></pre>\n\n<!-- Or, more compactly: -->\n\n\n<p>或者，更紧凑一些：</p>\n\n<pre><code>getTheResult().then(\n    function(theResult) {\n        // theResult will be the XHR reponse content\n        resultNode.innerHTML = theResult;\n    },\n    function(error) {\n        // error will be an indication of why the XHR failed, whatever\n        // the XHR lib chooses to supply.  For example, it could be\n        // an Error.\n        errorNode.innerHTML = error.message;\n    }\n);\n</code></pre>\n\n<p><img src=\"http://know.cujojs.com/tutorials/async/funny-surprised-owl-WHAT.jpg\" alt=\"\" /></p>\n\n<p>(Image from <a href=\"http://themetapicture.com/wat/\">The Meta Picture</a>)</p>\n\n<!-- Wasn't the whole point of this Promises stuff to *avoid using callbacks*? And here we are using them?!? -->\n\n\n<p>这就是 Promises 用来<em>避免使用回调函数</em>的全部内容？我们就这么使用它们？！？</p>\n\n<!-- ## Stay with Me -->\n\n\n<h2>别着急</h2>\n\n<!-- In Javascript, Promises are implemented using callbacks because there is no language-level construct for dealing with asynchrony. Callbacks are a necessary *implementation detail* of Promises. If Javascript provided, or possibly when it does provide in the future, other language constructs, promises could be implemented differently. -->\n\n\n<p>在 JavaScript 中，通过使用回调函数来实现 Promises，因为没有语言级的结构可以用于处理异步。回调函数是 Promises 必然的实现方式。如果 Javascript 已经提供或者未来可能提供其他的语言结构，那么 Promises 可能会以不同的方式实现。</p>\n\n<!-- However, there are several important advantages in using Promises over the deep callback passing model from Part 1. -->\n\n\n<p>然而，使用 Promises 解决（<a href=\"/2013/08/28/async-programming-is-messy/\">Part 1</a> 中）模块之间传递深度回调函数的问题具备几个重要的优点。</p>\n\n<!-- First, our function signatures are sane. We have removed the need to add callback and errback parameters to every function signature from the caller down to the XHR lib, and only the caller who is ultimately interested in the result needs to mess with callbacks. -->\n\n\n<p>首先，我们的函数签名是正常的。我们不再需要为从调用者到 XHR 库的每个函数签名添加 callback 和 errback 参数，并且只有对最终结果感兴趣的调用者才需要与回调函数厮混在一起。</p>\n\n<!-- Second, the Promise API standardizes callback passing. Libraries all tend to place callbacks and errbacks at different positions in function signatures. Some don't even accept an errback. *Most* don't accept an alwaysback (i.e. \"finally\"). We can rely on the Promise API instead of *many potentially different library APIs*. -->\n\n\n<p>其次，Promise API 标准化了回调函数的传递。所有库可能会把 callbacks 和 errbacks 参数放到函数签名的不同位置。某些库甚至不接受一个 errback 参数。<em>大部分</em> 不接受一个 alwaysback（即“finally”）。我们可以依赖 Promise API，而不是<em>许多有着潜在差异的库 API</em>。</p>\n\n<!-- Third, a Promise makes a set of *guarantees* about how and when callbacks and errbacks will be called, and how return values and exceptions thrown by callbacks will be handled. In a non-Promise world, the multitude of callback-supporting libraries and their many function signatures also means a multitude of different behaviors: -->\n\n\n<p>第三，Promise <em>保障</em>了回调函数和错误回调函数被调用的方式和时机，以及如何处理返回值和回调函数抛出的异常。在没有 Promise 的世界里，如果库和函数签名支持许多不同的回调函数，便意味着许多不同的行为：</p>\n\n<!-- 1. Are your callbacks allowed to return a value?\n1. If so, what happens to that value?\n1. Do all libraries allow your callback to throw an exception? If so, what happens to it? Is it silently eaten?\n1. If your callback does throw an exception, will your errback be called, or not? -->\n\n\n<ol>\n<li>你的回调函数允许返回一个值吗？</li>\n<li>如果允许返回会发生什么？</li>\n<li>是否所有库都允许你的回调函数抛出一个异常？如果允许抛出会发生什么？悄悄的把它吞掉吗？</li>\n<li>如果你的回调函数真的抛出一个异常，错误回调是否会被调用？</li>\n</ol>\n\n\n<!-- … and so on … -->\n\n\n<p>...等等...</p>\n\n<!-- So, while one way to think of Promises is as a standard API to callback registration, they also provide standard, predictable *behavior* for how and when a callback will be called, exception handling, etc. -->\n\n\n<p>所以，当考虑把 Promises 作为回调函数注册的标准 API 时，也为如何以及何时调用回调函数和处理异常提供了标准的、可预测的行为。</p>\n\n<!-- ## What about try/catch/finally? -->\n\n\n<h2>怎么处理 try/catch/finally？</h2>\n\n<!-- Now that we've restored call-and-return and removed callbacks from our function signatures, we need a way to handle failures. Ideally, we'd like to use try/catch/finally, or at least something that *looks and acts just like it* and works in the face of asynchrony. -->\n\n\n<p>现在，我们已经恢复了调用-返回编程模型，并从函数签名中移除了回调函数，我们还需要一种方式来处理失败的情况。理想情况下，我们希望使用 try/catch/finally，或者是至少在外观和行为上与它相似，并且在面对异步时可以正常工作。</p>\n\n<!-- In [Mastering Async Error Handling with Promises](http://know.cujojs.com/tutorials/async/mastering-async-error-handling-with-promises.html.md), we'll put the final piece of the puzzle into place, and see how to model try/catch/finally using Promises. -->\n\n\n<p>在 <a href=\"http://know.cujojs.com/tutorials/async/mastering-async-error-handling-with-promises.html.md\">用 Promises 控制异步错误处理</a> 一文中，我们将把拼图的最后一块填到位，看看如何用 Promises 模仿 try/catch/finally。</p>\n\n<hr>\n\n\n<blockquote><p>原文：<a href=\"http://know.cujojs.com/tutorials/async/simplifying-async-with-promises\">Simplifying Async with Promises</a></p></blockquote>\n\n<!-- https://github.com/know-cujojs/know/blob/master/src/documents/tutorials/async/simplifying-async-with-promises.html.md -->\n\n\n<p><link href=\"/assets/codemirror/lib/codemirror.css\" rel=\"stylesheet\">\n<link href=\"/assets/codemirror/theme/neat.css\" rel=\"stylesheet\"></p>\n\n<script src=\"/assets/codemirror/lib/codemirror.js\"></script>\n\n\n<script src=\"/assets/codemirror/addon/runmode/runmode.js\"></script>\n\n\n<script src=\"/assets/codemirror/mode/javascript/javascript.js\"></script>\n\n\n<script type=\"text/javascript\">\n    $('pre').each(function(index, el){\n        $(this).hide()\n        var ctn = $('<pre class=\"cm-s-neat\">').insertAfter(this)\n        CodeMirror.runMode($(this).find('code').text(), 'javascript',\n                 ctn.get(0));\n    })\n</script>\n\n"
            ],
            "link": [
              "http://nuysoft.github.com/2013/08/27/simplifying-async-with-promises"
            ],
            "guid": [
              "http://nuysoft.github.com/2013/08/27/simplifying-async-with-promises"
            ],
            "pubDate": [
              "2013-08-27T00:00:00-07:00"
            ]
          },
          {
            "title": [
              "用 Promises 控制异步错误处理"
            ],
            "description": [
              "\n\n<!-- As we saw in [Async Programming is Messy](http://know.cujojs.com/tutorials/async/async-programming-is-messy.html.md), error handling in callback-based asynchronous code gets messy quickly, and loses many of the qualities of synchronous code that make it familiar and easier to reason about. In [Simplifying Async with Promises](http://know.cujojs.com/tutorials/async/simplifying-async-with-promises.html.md), we introduced Promises and saw how they restore call-and-return semantics, allow errors to propagate up the stack similarly to synchronous exceptions, and generally provide a cleaner approach to managing asynchrony, especially when handling errors. -->\n\n\n<p>正如我们在 <a href=\"/2013/08/26/async-programming-is-messy/\">凌乱的异步编程</a> 一文中看到的，基于回调函数的异步代码很快变得混乱起来，并且大大降低了同步代码部分的质量，从而更容易导致错误。在 <a href=\"/2013/08/27/simplifying-async-with-promises/\">用 Promises 简化异步编程</a> 一文中，我们引入了 Promises，看到了它们如何恢复调用-返回编程模型，并且提供一种更清晰方法来管理异步，特别是在处理错误时。</p>\n\n<!-- ## Try/catch/finally -->\n\n\n<h2>Try/catch/finally</h2>\n\n<!-- In synchronous code, `try/catch/finally` provides a simple and familiar, yet very powerful idiom for performing a task, handling errors, and then always ensuring we can clean up afterward. -->\n\n\n<p>在同步代码中，<code>try/catch/finally</code> 提供了一种简单友好但非常强大的惯用语法来执行任务、处理错误，并且总是确保稍后可以执行清理。</p>\n\n<blockquote><p>译注：idiom <a href=\"http://baike.baidu.com/view/1678043.htm\">习语</a></p></blockquote>\n\n<!-- Here's a simple `try/catch/finally` example in the same vein as the original `getTheResult()` from Part 1: -->\n\n\n<p>下面是一个简单的 <code>try/catch/finally</code> 示例，与 <a href=\"/2013/08/28/async-programming-is-messy/\">Part 1</a> 中的原始 <code>getTheResult()</code> 一模一样：</p>\n\n<pre><code>// Sync\nfunction getTheResult() {\n\n    try {\n        return thisMightFail();\n    } catch(e) {\n        return recoverFromFailure(e);\n    } finally {\n        alwaysCleanup();\n    }\n\n}\n</code></pre>\n\n<!-- As we've seen, attempting to simulate even the `try/catch` via a callback-based approach is fraught with pitfalls. Adding the notion of `finally`, that is, *guaranteed cleanup*, only makes things worse. -->\n\n\n<p>正如我们已经看到的那样，即使是试图以基于回调函数的方式来模拟 <code>try/catch</code> 也充满了陷阱。加入 <code>finally</code> 的概念后（即<em>确保执行清理</em>）只会使事情变得更糟。</p>\n\n<!-- Using Promises, we can build an approach that is analogous to this familiar `try/catch/finally` idiom, without deep callback structures. -->\n\n\n<p>使用 Promises，我们可以建立一种方法，类似于友好的惯用语法 <code>try/catch/finally</code>，并且没有深度回调结构。</p>\n\n<!-- ## Try/catch -->\n\n\n<h2>Try/catch</h2>\n\n<!-- Let's start with a simpler version of example above that only uses `try/catch`, and see how we can use Promises to handle errors in the same way. -->\n\n\n<p>让我们从上面示例的简单版本开始，只使用 <code>try/catch</code>，然后看看如何用 Promises 以同样的方式处理错误。</p>\n\n<pre><code>// Sync\nfunction getTheResult() {\n\n    try {\n        return thisMightFail();\n    } catch(e) {\n        return recoverFromFailure(e);\n    }\n\n}\n</code></pre>\n\n<!-- And now, as in Part 2, let's assume that `thisMightFail()` is asynchronous and returns a Promise. We can use `then()` to simulate `catch`: -->\n\n\n<p>现在，就像在 <a href=\"/2013/08/27/simplifying-async-with-promises/\">Part 2</a> 中一样，让我们假设 <code>thisMightFail()</code> 是异步的，并且返回一个 Promise。我们可以用 <code>then()</code> 来模拟 <code>catch</code>：</p>\n\n<pre><code>// Async\nfunction thisMightFail() {\n    //...\n    return promise;\n}\n\nfunction getTheResult() {\n\n    return thisMightFail()\n        .then(null, recoverFromFailure);\n\n}\n</code></pre>\n\n<!-- Waitaminit, that's *even less code* than using `try/catch`! What's going on here? -->\n\n\n<p>等等，比 <code>try/catch</code> 的<em>代码甚至更少</em>！这是怎么回事呢？</p>\n\n<blockquote><p>译注：Waitaminit, Wait a minute</p></blockquote>\n\n<!-- ### Propagating a success -->\n\n\n<h3>传播成功状态</h3>\n\n<!-- This example introduces two very important facts about how Promises behave. The first of which is: -->\n\n\n<p>这个例子引入了两个关于 Promises 行为非常重要的事实。其中第一个是：</p>\n\n<!-- If no `onFulfilled` handler is provided to `then()`, the fulfillment value will propagate through unchanged to the returned Promise. -->\n\n\n<p>如果没有提供 <code>onFulfilled</code> 处理程序，结果值将原封不动地传播到返回的 Promise。</p>\n\n<!-- We're *not* supplying an `onFulfilled` handler when calling `then()`. This means that a successful result from `thisMightFail()` simply will propagate through and be returned to the caller. -->\n\n\n<p>在调用 <code>then()</code> 时，我们<em>没有</em>提供 <code>onFulfilled</code> 处理程序。这意外着 <code>thisMightFail()</code> 返回的成功结果将简单地传播，并返回给调用者。</p>\n\n<!-- ### Handling an error -->\n\n\n<h3>处理错误</h3>\n\n<!-- The other important behavior is: -->\n\n\n<p>另外一个重要的行为是：</p>\n\n<!-- A handler may produce either a successful result by returning a value, or an error by throwing or returning a rejected promise. -->\n\n\n<p>处理程序可以通过返回一个值来产生一个成功结果，也可以通过抛出错误或返回一个被拒的 Promise 来产生一个错误。</p>\n\n<!-- We *are* supplying an `onRejected` handler: `recoverFromFailure`. That means that any error produced by `thisMightFail` will be provided to `recoverFromFailure`. Just like the `catch` statement in the synchronous example, `recoverFromFailure` can handle the error and `return` a successful result, *or* it can produce an error by throwing or by returning a rejected Promise. -->\n\n\n<p>我们提供了一个 <code>onRejected</code> 处理程序：<code>recoverFromFailure</code>。这意外着，<code>thisMightFail</code> 产生的任何错误将被传给 <code>recoverFromFailure</code>。就像同步例子中的 <code>catch</code> 语句，<code>recoverFromFailure</code> 可以处理传入的错误并 <code>return</code> 一个成功结果，<em>也可以</em>通过抛出错误或返回一个被拒的 Promise 来产生一个错误。</p>\n\n<!-- Now we have a fully asynchronous construct that behaves like its synchronous analog, and is just as easy to write. -->\n\n\n<p>现在我们有一个完整的异步结构，它的行为就像是同步的模拟，并且也很容易编写。</p>\n\n<!-- ### Adding some sugar -->\n\n\n<h3>添加一点语法糖</h3>\n\n<blockquote><p>译注：Syntactic sugar <a href=\"http://baike.baidu.com/view/1805428.htm\">语法糖</a></p></blockquote>\n\n<!-- Hmmm, but what about that `null` we're passing as the first param? Why should we have to type `null` everywhere we want to use this asynchronous `try/catch`-like construct? Can't we do better? -->\n\n\n<p>嗯，但我们把 <code>null</code> 作为第一个参数传入是什么意思？在想要使用类似 <code>try/catch</code> 的异步结构的地方，我们为什么必须要键入 <code>null</code>？能不能做的更好点？</p>\n\n<!-- While the primary interface to a Promises/A+ Promise is its `then()` method, many implementations add convenience methods, built, with very little code, upon `then()`. For example, [when.js](https://github.com/cujojs/when) Promises provide an [`otherwise()` method](https://github.com/cujojs/when/blob/master/docs/api.md#otherwise) that allows us to write this example more intuitive and compactly: -->\n\n\n<p>虽然遵循 Promises/A+ 规范的 Promise 的主要接口是 <code>then()</code> 方法，但是许多实现都（用很少的代码）以 <code>then()</code> 为基础构建和添加了便捷方法。例如，<a href=\"https://github.com/cujojs/when\">when.js</a> Promises 提供了一个 <a href=\"https://github.com/cujojs/when/blob/master/docs/api.md#otherwise\"><code>otherwise()</code> 方法</a>，允许我们更直观、更紧凑地编写这个例子：</p>\n\n<pre><code>// Async: Using when.js promise.otherwise();\nfunction getTheResult() {\n\n    return thisMightFail()\n        .otherwise(recoverFromFailure);\n\n}\n</code></pre>\n\n<!-- Now we have something that reads nicely! -->\n\n\n<p>现在我们有了阅读起来很棒的异步结构！</p>\n\n<!-- ## Adding finally -->\n\n\n<h2>添加 finally</h2>\n\n<!-- Let's add `finally` back into the mix, and see how we can use Promises to achieve the same result for asynchronous operations. -->\n\n\n<p>让我们把 <code>finally</code> 添加到这种混合结构中，看看如何用 Promises 使异步操作达到同样的结果。</p>\n\n<pre><code>// Sync\nfunction getTheResult() {\n\n    try {\n        return thisMightFail();\n    } catch(e) {\n        return recoverFromFailure(e);\n    } finally {\n        alwaysCleanup();\n    }\n\n}\n</code></pre>\n\n<!-- First, let's note that there are some very interesting things about this seemingly simple `finally` block. It: -->\n\n\n<p>首先让我们注意到的是，这个看似简单的 <code>finally</code> 块包含了一些有趣的东西：</p>\n\n<!-- 1. will always execute after thisMightFail and/or recoverFromFailure\n1. does not have access to the value returned by `thisMightFail`, or to the thrown exception (`e`), or to the value returned by `recoverFromFailure`[^1].\n1. cannot, in this case, transform an exception thrown by `recoverFromFailure` back into a successful result[^2].\n1. *can* change a successful result (returned by either `thisMightFail` or `recoverFromFailure`) into a failure if `alwaysCleanup` throws an exception.\n1. *can* substitute a new exception in place of one thrown by `recoverFromFailure`. That is, if both `recoverFromFailure` and `alwaysCleanup` throw exceptions, the one thrown by `alwaysCleanup` will propagate to the caller, and the one thrown by `recoverFromFailure` *will not*. -->\n\n\n<ol>\n<li>总是在 <code>thisMightFail</code> 和/或 <code>recoverFromFailure</code> 之后执行</li>\n<li><a name=\"footnote-1-ref\"></a>没有机会访问 <code>thisMightFail</code> 返回的值或抛出的异常 <code>e</code>，也没有机会访问 <code>recoverFromFailure</code> 返回的值<a href=\"#footnote-1\">^1</a>。</li>\n<li><a name=\"footnote-2-ref\"></a>在这种情况下，不能把 <code>recoverFromFailure</code> 抛出的异常转换回成功结果<a href=\"#footnote-2\">^2</a>。</li>\n<li>如果 <code>alwaysCleanup</code> 抛出一个异常，<em>可以</em>把成功结果（由 <code>thisMightFail</code> 或 <code>recoverFromFailure</code>）转换为一个失败。</li>\n<li><em>可以</em>用一个新异常替换掉 <code>recoverFromFailure</code> 抛出的异常。也就是说，如果 <code>recoverFromFailure</code> 和 <code>alwaysCleanup</code> 都抛出了异常，<code>alwaysCleanup</code> 抛出的异常将传播到调用者，而由 <code>recoverFromFailure</code> 抛出的却<em>不会</em>。</li>\n</ol>\n\n\n<!-- This seems fairly sophisticated. Let's return to our asynchronous `getTheResult` and look at how we can achieve these same properties using Promises. -->\n\n\n<p>这似乎相当复杂。让我们回到异步的 <code>getTheResult</code>，看看如何用 Promises 实现同样的特性。</p>\n\n<!-- ### Always execute -->\n\n\n<h3>总是会执行</h3>\n\n<!-- First, let's use `then()` to ensure that `alwaysCleanup` will execute in all cases (for succinctness, we'll keep when.js's `otherwise`): -->\n\n\n<p>首先，让我们用 <code>then()</code> 确保 <code>alwaysCleanup</code> 在所有情况下都将会执行（为了简洁些，我们会保留 when.js 的 <code>otherwise</code>）：</p>\n\n<pre><code>// Async\nfunction getTheResult() {\n\n    return thisMightFail()\n        .otherwise(recoverFromFailure);\n        .then(alwaysCleanup, alwaysCleanup);\n}\n</code></pre>\n\n<!-- That seems simple enough! Now, `alwaysCleanup` will be executed in all cases: -->\n\n\n<p>这似乎很简单！现在，<code>alwaysCleanup</code>在所有情况下都将会被执行：</p>\n\n<!-- 1. if `thisMightFail` succeeds,\n1. if `thisMightFail` fails and `recoverFromFailure` succeeds, or\n1. if `thisMightFail` and `recoverFromFailure` both fail. -->\n\n\n<ol>\n<li>如果 <code>thisMightFail</code> 成功了，</li>\n<li>如果 <code>thisMightFail</code> 失败了，而 <code>recoverFromFailure</code> 成功了，</li>\n<li>如果 <code>thisMightFail</code> 和 <code>recoverFromFailure</code> 都失败了。</li>\n</ol>\n\n\n<!-- But wait, while we've ensured that `alwaysCleanup` will always execute, we've violated two of the other properties: `alwaysCleanup` *will* receive the successful result or the error, so has access to either/both, and it *can* transform an error into a successful result by returning successfully. -->\n\n\n<p>但等等，虽然我们已经确保了 <code>alwaysCleanup</code> 将总是会执行，但是也侵犯了其他两项特性：<code>alwaysCleanup</code> <em>会</em>收到成功结果或错误，因此有机会访问其中之一，或者两个，并且<em>可以</em>通过返回一个成功值把一个错误转换为一个成功结果。</p>\n\n<!-- ### Don't access result/error -->\n\n\n<h3>不要访问结果/错误</h3>\n\n<!--We can introduce a wrapper to prevent passing the result or error to `alwaysCleanup`:-->\n\n\n<p>我们可以引入一个包装函数，以防把结果或错误传给 <code>alwaysCleanup</code>：</p>\n\n<pre><code>// Async\nfunction alwaysCleanupWrapper(resultOrError) {\n    // don't pass resultOrError through\n    return alwaysCleanup();\n}\n\nfunction getTheResult() {\n\n    return thisMightFail()\n        .otherwise(recoverFromFailure);\n        .then(alwaysCleanupWrapper, alwaysCleanupWrapper);\n}\n</code></pre>\n\n<!-- Now we've achieved one of the two properties we had lost: `alwaysCleanup` no longer has access to the result or error. Unfortunately, we had to add some code that feels unnecessary. Let's keep exploring, though, to see if we can achieve the remaining property. -->\n\n\n<p>现在，我们已经实现了曾丢掉的两项特性中的一项：<code>alwaysCleanup</code> 不再可以访问结果或错误。不幸的是，我们不得不添加一些感觉没必要的代码。不过，让我们继续探索，看看是否可以实现剩下的特性。</p>\n\n<!-- ### Don't change the result -->\n\n\n<h3>不要改变结果</h3>\n\n<!-- While `alwaysCleanupWrapper` prevents `alwaysCleanup` from accessing the result or error, it still allows `alwaysCleanup` to turn an error condition into a successful result. For example, if `recoverFromFailure` produces an error, it will be passed to `alwaysCleanupWrapper`, which will then call `alwaysCleanup`. If `alwaysCleanup` returns successfully, the result will be propagated to the caller, thus squelching the previous error. -->\n\n\n<p>虽然 <code>alwaysCleanupWrapper</code> 阻止了 <code>alwaysCleanup</code> 访问结果或错误，但是它仍然允许 <code>alwaysCleanup</code> 把一个错误状态转换一个成功结果。例如，如果 <code>recoverFromFailure</code> 产生一个错误，它将被传给 <code>alwaysCleanupWrapper</code>，然后调用 <code>alwaysCleanup</code>。如果 <code>alwaysCleanup</code> 成功返回，返回值将传播到调用者，从而消除了之前的错误。</p>\n\n<!-- That doesn't align with how our synchronous `finally` clause behaves, so let's refactor: -->\n\n\n<p>这与同步的 <code>finally</code> 之句的行为并不匹配，所以让我们重构它：</p>\n\n<pre><code>// Async\nfunction alwaysCleanupOnSuccess(result) {\n    // don't pass result through, *and ignore* the return value\n    // of alwaysCleanup.  Instead, return original result to propagate it.\n    alwaysCleanup();\n    return result;\n}\n\nfunction alwaysCleanupOnFailure(error) {\n    // don't pass result through, *and ignore* the result\n    // of alwaysCleanup.  Instead, rethrow error to propagate the failure.\n    alwaysCleanup();\n    throw error;\n}\n\nfunction getTheResult() {\n\n    return thisMightFail()\n        .otherwise(recoverFromFailure);\n        .then(alwaysCleanupOnSuccess, alwaysCleanupOnFailure);\n\n}\n</code></pre>\n\n<!-- In both the success and failure cases, we've preserved the outcome: `alwaysCleanupOnSuccess` will execute `alwaysCleanup` but not allow it to change the ultimate result, and `alwaysCleanupOnFailure` will also execute `alwaysCleanup` and always rethrow the original error, thus propagating it even if `alwaysCleanup` returns successfully. -->\n\n\n<p>在成功和失败状态下，我们已经保存了结果：<code>alwaysCleanupOnSuccess</code> 将执行 <code>alwaysCleanup</code> 但不允许它改变最终结果，<code>alwaysCleanupOnFailure</code> 也将执行 <code>alwaysCleanup</code> 并总是抛出原始的错误，从而传播错误，即使 <code>alwaysCleanup</code> 成功返回。</p>\n\n<!-- ### The remaining two properties -->\n\n\n<h3>剩下的两项特性</h3>\n\n<!-- Looking at the refactor above, we can also see that the remaining two properties hold: -->\n\n\n<p>看看上面的重构，我们还可以发现它涵盖了剩下的两项特性：</p>\n\n<!-- In `alwaysCleanupOnSuccess`, if `alwaysCleanup` throws, the `return result` will never be reached, and this new error will be propagated to the caller, thus turning a successful result into a failure. -->\n\n\n<p>在 <code>alwaysCleanupOnSuccess</code> 中，如果 <code>alwaysCleanup</code> 抛出错误，<code>return result</code> 将永远不会被执行到 ，并且这个新错误将传播到调用者，从而把一个成功结果转换为一个失败结果。</p>\n\n<!-- In `alwaysCleanupOnFailure`, if `alwaysCleanup` throws, the `throw error` will never be reached, and the error thrown by `alwaysCleanup` will be propagated to the caller, thus substituting a new error. -->\n\n\n<p>在 <code>alwaysCleanupOnFailure</code> 中，如果 <code>alwaysCleanup</code> 抛出错误，<code>throw error</code> 将永远不会被执行到，并且这个由 <code>alwaysCleanup</code> 抛出的错误将传播到调用者，从而代之以一个新错误。</p>\n\n<!-- ## Finally? -->\n\n\n<h2>圆满了吗？</h2>\n\n<!-- With this latest refactor, we've created an asynchronous construct that behaves like its familiar, synchronous `try/catch/finally` analog. -->\n\n\n<p>通过最新重构的代码，我们已经创建了这样一个异步结构，它的行为就像友好的同步 <code>try/catch/finally</code> 的模拟。</p>\n\n<!-- ### More sugar -->\n\n\n<h3>更多语法糖</h3>\n\n<!-- Some Promise implementations provide an abstraction for the `finally`-like behavior we want. For example, when.js Promises provide an [`ensure()` method](https://github.com/cujojs/when/blob/master/docs/api.md#ensure) that has all of the properties we achieved above, but also allows us to be more succinct: -->\n\n\n<p>一些 Promise 提供了类似 <code>finally</code> 行为的抽象。例如，when.js Promises 提供了一个 <a href=\"https://github.com/cujojs/when/blob/master/docs/api.md#ensure\"><code>ensure()</code> 方法</a>，它具备我们前面实现的所有特性，但是更简洁：</p>\n\n<pre><code>// Async: Using when.js promise.ensure();\nfunction getTheResult() {\n\n    return thisMightFail()\n        .otherwise(recoverFromFailure)\n        .ensure(alwaysCleanup);\n\n}\n</code></pre>\n\n<!-- ## Finally -->\n\n\n<h2>小结</h2>\n\n<!-- We started with the goal of finding a way to model the useful and familiar synchronous `try/catch/finally` behavior for asynchronous operations. Here's the simple, synchronous code we started with: -->\n\n\n<p>我们一开始的目标是为异步操作寻找一种方式来模拟有用且好用的同步 <code>try/catch/finally</code> 的行为。下面是我们开始时的简单同步代码：</p>\n\n<pre><code>// Sync\nfunction getTheResult() {\n\n    try {\n        return thisMightFail();\n    } catch(e) {\n        return recoverFromFailure(e);\n    } finally {\n        alwaysCleanup();\n    }\n\n}\n</code></pre>\n\n<!-- And here is the asynchronous analog we ended up with something that is just as compact, and easily readable: -->\n\n\n<p>然后，下面是最终的异步模拟，结构紧凑，而且易于阅读：</p>\n\n<pre><code>// Async\nfunction getTheResult() {\n\n    return thisMightFail()\n        .otherwise(recoverFromFailure)\n        .ensure(alwaysCleanup);\n\n}\n</code></pre>\n\n<!-- ## Try/finally -->\n\n\n<h2>Try/finally</h2>\n\n<!-- Another common construct is `try/finally`. It is useful in executing cleanup code, but always allowing exceptions to propagate in the case where there is no immediate recovery path. For example: -->\n\n\n<p>另一种常见的结构是 <code>try/finally</code>。在执行清理代码时它很有用，但是在这种没有恢复路径（<code>catch</code>）的情况下，它总是允许异常传播。例如：</p>\n\n<pre><code>// Sync\nfunction getTheResult() {\n\n    try {\n        return thisMightFail();\n    } finally {\n        alwaysCleanup();\n    }\n\n}\n</code></pre>\n\n<!-- Now that we've modeled a full `try/catch/finally` using Promises, modeling `try/finally` is trivial. Similarly to simply cutting out the `catch` above, we can cut out the `otherwise()` in our Promise version: -->\n\n\n<p>现在，我们已经 Promises 完整地模拟了 <code>try/catch/finally</code>，模拟 <code>try/finally</code> 就小菜一碟了。就像上面简单地删除掉 <code>catch</code> 一样，我们可以在 Promise 版本中删去 <code>otherwise()</code>：</p>\n\n<pre><code>// Async\nfunction getTheResult() {\n\n    return thisMightFail()\n        .ensure(alwaysCleanup);\n\n}\n</code></pre>\n\n<!--All of the constraints we've been attempting to achieve still hold--this asynchronous construct will behave analogously to its synchronous `try/finally` counterpart.-->\n\n\n<p>我们一直试图实现的制约（特性）仍然保留了下来——这个异步结构的行为类似于对应的同步 <code>try/finally</code>。</p>\n\n<!-- ## Using it -->\n\n\n<h2>应用异步结构</h2>\n\n<!-- Let's compare how we would use the synchronous and asynchronous versions of `getTheResult`. Assume we have the following two pre-existing functions for showing results and errors. For simplicity, let's also assume that `showResult` might fail, but that `showError` will not fail. -->\n\n\n<p>让我们来比较一下如何使用 <code>getTheResult</code> 的同步和异步版本。假设已经有下面两个用于展示结果和错误的函数。为了简单起见，我们还假设 <code>showResult</code> 可能会失败，而 <code>showError</code> 不会失败。</p>\n\n<pre><code>// Assume showResult might fail\nfunction showResult(result) { /* Format and show the result */ }\n\n// Assume showError will never fail\nfunction showError(error) { /* Show the error, warn the user, etc. */ }\n</code></pre>\n\n<!-- ### Synchronous -->\n\n\n<h3>同步版本</h3>\n\n<!-- First, the synchronous version, which we might use like this: -->\n\n\n<p>首先是同步版本，我们可能会像这样使用：</p>\n\n<pre><code>// Sync\ntry {\n    showResult(getTheResult());\n} catch(e) {\n    showError(e);\n}\n</code></pre>\n\n<!-- It's quite simple, as we'd expect. If we get the result successfully, then we show it. If getting the result fails (by throwing an exception), we show the error. -->\n\n\n<p>正如我们预料的，它相当简单。如果我们成功地得到结果，然后就展示结果。如果得到失败的结果（通过抛出一个异常），就展示错误。</p>\n\n<!--It's also important to note that if `showResult` fails, we will show an error. This is an important hallmark of synchronous exceptions. We've written single `catch` clause that will handle errors from either `getTheResult` or `showResult`. The error propagation is *automatic*, and required no additional effort on our part.-->\n\n\n<p>同样需要重点注意的是，如果 <code>showResult</code> 失败了，将展示一个错误。这是同步异常的一个重要标志。我们写下的 <code>catch</code> 单句将处理来自 <code>getTheResult</code> 或 <code>showResult</code> 的错误。这种错误传播是<em>自动的</em>，不需要为之增加额外的代码。</p>\n\n<!-- ### Asynchronous -->\n\n\n<h3>异步版本</h3>\n\n<!-- Now, let's look at how we'd use the asynchronous version to accomplish the same goals: -->\n\n\n<p>现在，让我们看看如何用异步版本完成同样的目标：</p>\n\n<pre><code>// Async\ngetTheResult().then(showResult)\n    .otherwise(showError);\n</code></pre>\n\n<!-- The functionality here is analogous, and one could argue that visually, this is even simpler than the synchronous version. We get the result, or rather in this case, a Promise for the result, and when the actual result materializes (remember, this is all asynchronous!), we show it. If getting the result fails (by rejecting resultPromise), we show the error. -->\n\n\n<p>这里的功能是类似的，而且会惊讶于它看起来居然比同步版本更简单。我们得到了结果，或者更确切地说，是结果的一个 Promise，并且当真正的结果实现时（记住，一切都是异步的），我们将展示它。如果得到了失败的结果（通过拒绝 Promise），我们将展示错误。</p>\n\n<!-- Because Promises propagate errors similarly to exceptions, if `showResult` fails, we will also show an error. So, the automatic the behavior here is also parallel to the synchronous version: We've written single `otherwise` call that will handle errors from either `getTheResult` or `showResult`. -->\n\n\n<p>由于 Promises 像传播异常一样传播错误，因此如果 <code>showResult</code> 失败了，我们也会展示一个错误。因此，这种自动的行为与同步版本是也是等价的：我们编写的 <code>otherwise</code> 单句调用将处理来自 <code>getTheResult</code> 和 <code>showResult</code> 的错误。</p>\n\n<!-- Another important thing to notice is that we are able to use the same `showResult` and `showError` functions as in the synchronous version. We don't need artificial callback-specific function signatures to work with promises--just the same functions we'd write anyway. -->\n\n\n<p>另一件需要注意的事情是，同样的 <code>showResult</code> 和 <code>showError</code> 函数也可以使用在同步版本中。我们不需要为了能在 Promises 中运行而人工改造特定函数的签名——与我们在任意地方编写的函数完全一样。</p>\n\n<!-- ## Putting it all together -->\n\n\n<h2>整合</h2>\n\n<!-- We've refactored our `getTheResult` code to use Promises to eumlate `try/catch/finally`, and also the calling code to use the returned Promise to handle all the same error cases we would handle in the synchronous version. Let's look at the complete Promise-based asynchronous version of our code: -->\n\n\n<p>我们已经重构了 <code>getTheResult</code> 的代码，使之以 Promises 来模拟 <code>try/catch/finally</code>，也使调用代码用返回的 Promise 来处理与同步版本相同的错误。让我们完整地看看代码基于 Promise 的异步版本：</p>\n\n<pre><code>// Using getTheResult()\ngetTheResult().then(showResult)\n    .otherwise(showError);\n\nfunction getTheResult() {\n    return thisMightFail()\n        .otherwise(recoverFromFailure)\n        .ensure(alwaysCleanup);\n}\n\nfunction thisMightFail() {\n    // Using the proposed Promises/A+ style API for promise creation\n    return makePromise(function(resolve, reject) {\n        var result, error;\n\n        // Do work, then:\n\n        if(error) {\n            reject(error);\n        } else {\n            resolve(result);\n        }\n    });\n}\n</code></pre>\n\n<!-- ## The end? -->\n\n\n<h2>结语</h2>\n\n<!-- Of course, there will always be differences between synchronous and asynchronous execution, but by using Promises, we can narrow the divide. The synchronous and Promise-based versions we've constructed not only look very similar, they *behave* similarly. They have similar invariants. We can reason about them in similar ways. We can even *refactor* and *test* them in similar ways. -->\n\n\n<p>当然同步执行和异步执行之间总是有所差异，但是我们可以通过使用 Promises 缩小这种差异。同步版本和我们构建的基于 Promise 的版本不仅看起非常相似，而且它们的<em>行为</em>也相似。它们有着相似的固定格式。我们可以用相似的方式揣测它们。我们甚至能用相似的方式<em>重构</em>和<em>测试</em>它们。</p>\n\n<!-- Providing familiar and predictable error handling patterns and composable call-and-return semantics are two powerful aspects of Promises, but they are also only the beginning. Promises are a building block on which fully asynchronous analogs of many other familiar features can be built easily: higher order functions like map and reduce/fold, [parallel and sequential](https://github.com/cujojs/when/blob/master/docs/api.md#concurrency) task execution, and much more. -->\n\n\n<p>提供友好和可预测的错误处理模式，以及可组合的调用-返回语法，是 Promises 两个强大的特性，但是这仅仅是开始。基于 Promises 的异步结构，可以轻松地将许多其他功能完全异步化：高级功能（例如 map、reduce/fold）、<a href=\"https://github.com/cujojs/when/blob/master/docs/api.md#concurrency\">并行和顺序</a>的执行任务等等。</p>\n\n<hr>\n\n\n\n\n<!--[^1]: You might be wondering why we want this property. For this article, we're choosing to try to model `finally` as closely as possible. The intention of synchronous `finally` is to cause *side effects*, such as closing a file or database connection, and not to transform the result or error by applying a function to it. Also, passing something that *might be a result or might be an error* to `alwaysCleanup` can be a source of hazards without *also* telling `alwaysCleanup` what kind of thing it is receiving. The fact that `finally` doesn't have a \"parameter\", like `catch` means that the burden is on the developer to grant access to the result or error, usually by storing it in a local variable before execution enters the `finally`. That approach will work for these promise-based approaches as well.-->\n\n\n\n\n<!--[^2]: Note that `finally` *is* allowed to squelch exceptions by *explicitly* returning a value. However, in this case, we are not returning anything explicitly. I've never seen a realistic and useful case for squelching an exception that way.-->\n\n\n<ol>\n<li><p><a name=\"footnote-1\"></a>你可能会奇怪于为什么我们需要这个特性。在这篇文章中，我们选择尝试尽可能近似地模拟 <code>finally</code>。同步 <code>finally</code> 的意图是引发某种<em>副作用</em>，例如关闭一个文件或数据库连接，并不是执行一个函数来转换结果或错误。而且，向 <code>alwaysCleanup</code> 传入一个<em>可能是结果或错误</em>的参数，<em>却</em>不告诉 <code>alwaysCleanup</code> 正在接受的参数什么类型，可能是一个危害源。事实上，<code>finally</code> 没有”参数“，不像 <code>catch</code>，这意外着开发人员需要承担授权访问结果或错误的烦扰，通常的做法是在进入 <code>finally</code> 之前把结果或错误存储到一个局部变量中。这种做法也可以应用在基于 Promise 的方式中。<a href=\"#footnote-1-ref\">↩</a></p></li>\n<li><p><a name=\"footnote-2\"></a>需要注意的是，<code>finally</code><em>可以</em>通过<em>明确地</em>返回一个值消除异常。但是在这种情况下，我们没有明确地返回任何东西。我从来没有在现实中见过需要用这种方式来消除异常的情况。<a href=\"#footnote-2-ref\">↩</a></p></li>\n</ol>\n\n\n<hr>\n\n\n<blockquote><p>原文：<a href=\"http://know.cujojs.com/tutorials/async/mastering-async-error-handling-with-promises\">Mastering Async Error Handling with Promises</a></p></blockquote>\n\n<!-- https://github.com/know-cujojs/know/blob/master/src/documents/tutorials/async/mastering-async-error-handling-with-promises.html.md -->\n\n\n<p><link href=\"/assets/codemirror/lib/codemirror.css\" rel=\"stylesheet\">\n<link href=\"/assets/codemirror/theme/neat.css\" rel=\"stylesheet\"></p>\n\n<script src=\"/assets/codemirror/lib/codemirror.js\"></script>\n\n\n<script src=\"/assets/codemirror/addon/runmode/runmode.js\"></script>\n\n\n<script src=\"/assets/codemirror/mode/javascript/javascript.js\"></script>\n\n\n<script type=\"text/javascript\">\n    $('pre').each(function(index, el){\n        $(this).hide()\n        var ctn = $('<pre class=\"cm-s-neat\">').insertAfter(this)\n        CodeMirror.runMode($(this).find('code').text(), 'javascript',\n                 ctn.get(0));\n    })\n</script>\n\n"
            ],
            "link": [
              "http://nuysoft.github.com/2013/08/26/mastering-async-error-handling-with-promises"
            ],
            "guid": [
              "http://nuysoft.github.com/2013/08/26/mastering-async-error-handling-with-promises"
            ],
            "pubDate": [
              "2013-08-26T00:00:00-07:00"
            ]
          },
          {
            "title": [
              "大型 JavaScript 应用架构中的模式"
            ],
            "description": [
              "\n\n<!-- **Today we're going to discuss an effective set of patterns for large-scale JavaScript application architecture. The material is based on my talk of the same name, last presented at LondonJS and inspired by [previous work](http://yuilibrary.com/theater/nicholas-zakas/zakas-architecture/) by Nicholas Zakas.** -->\n\n\n<p><strong>今天我们要讨论大型 JavaScript 应用架构中的有效模式。这篇文章基于我最近在 LondonJS 的同名演讲，灵感则来自 Nicholas Zakas <a href=\"http://yuilibrary.com/theater/nicholas-zakas/zakas-architecture/\">之前的成果</a>。</strong></p>\n\n<blockquote><p>译注：<a href=\"http://www.youtube.com/watch?v=vXjVFPosQHw\">Nicholas Zakas: Scalable JavaScript Application Architecture</a></p></blockquote>\n\n<!-- ### Who am I and why am I writing about this topic? -->\n\n\n<h3>我是谁，以及我为什么写这个主题？</h3>\n\n<!-- I'm currently a JavaScript and UI developer at AOL helping to plan and write the front-end architecture to our next generation of client-facing applications. As these applications are both complex and often require an architecture that is scalable and highly-reusable, it's one of my responsibilities to ensure the patterns used to implement such applications are as sustainable as possible. -->\n\n\n<p>我目前是 AOL 的一名 JavaScript 和 UI 开发人员，负责为我们下一代面向客户的应用程序计划和编写前端架构。\n由于这些应用程序不仅复杂，而且需要可扩展和高度可重用的架构，因此我的职责之一就是确保用于实现应用程序的模式尽可能是可持续的。</p>\n\n<!-- I also consider myself something of a design pattern enthusiast (although there are far more knowledgeable experts on this topic than I). I've previously written the creative-commons book '[Essential JavaScript Design Patterns]' and am in the middle of writing the more detailed follow up to this book at the moment. -->\n\n\n<p>我自认为是一名设计模式爱好者（虽然关于这个主题有很多专家比我更专业）。我之前基于创作共用许可证写了 <a href=\"http://addyosmani.com/resources/essentialjsdesignpatterns/book/\">Essential JavaScript Design Patterns</a> 一书，现在我想写得更详尽一些，作为这本书的后续部分。</p>\n\n<!-- ### Can you summarize this article in 140 characters? -->\n\n\n<h3>可以用 140 个字概述这篇文章吗？</h3>\n\n<!-- In the event of you being short for time, here's the tweet-sized summary of this article: -->\n\n\n<p>如果你时间不够，下面是这篇文章的摘要，只有一条 tweet 的长度：</p>\n\n<!-- > Decouple app. architecture w/module,facade & mediator patterns. Mods publish msgs, mediator acts as pub/sub mgr & facade handles security -->\n\n\n<blockquote><p>解耦应用。架构/模块，外观和中介者模式。模块生产消息，中介者发布/订阅消息，外观处理安全问题。</p></blockquote>\n\n<!-- ### What exactly is a 'large' JavaScript application? -->\n\n\n<h3>究竟什么是“大型” JavaScript 应用程序？</h3>\n\n<!-- Before we begin, let us attempt to define what we mean when we refer to a JavaScript application as being significantly 'large'. This is a question I've found still challenges developers with many years of experience in the field and the answer to this can be quite subjective. -->\n\n\n<p>在开始之前，让我们尝试弄清一点，当我们提到某个 JavaScript 应用程序是“大型”时，究竟是什么意思。这个问题对于有多年经验的开发人员仍然是一项挑战，而且答案也相当主观。</p>\n\n<!-- As an experiment, I asked a few intermediate developers to try providing their definition of it informally. One developer suggested 'a JavaScript application with over 100,000 LOC' whilst another suggested 'apps with over 1MB of JavaScript code written in-house'. Whilst valiant (if not scary) suggestions, both of these are incorrect as the size of a codebase does not always correlate to application complexity - those 100,000 LOC could easily represent quite trivial code. -->\n\n\n<p>我作了一个试验，咨询了几位中级开发人员，让他们试着做出非正式的定义。一个开发人员建议“JavaScript 应用程序的代码行数超过 100,000 行”，而另一位建议“应用程序中 JavaScript 代码超过 1MB”。虽然是勇敢的建议（如果不是故意吓人），但是这些都不正确，因为代码库的大小并不总是与应用程序的复杂度相关 - 100,000 行代码很可能是相当琐碎的代码。</p>\n\n<blockquote><p>译注：LOC，Lines of Code，代码行数</p></blockquote>\n\n<!-- My own definition may or may not be universally accepted, but I believe that it's closer to what a large application actually represents. -->\n\n\n<p>我自己的定义可能会也可能不会被普遍接受，但是我相信它更接近大型应用程序的真实含义。</p>\n\n<!-- > In my view, large-scale JavaScript apps are **non-trivial** applications requiring **significant** developer effort to maintain, where most heavy lifting of data manipulation and display falls to the **browser**. -->\n\n\n<blockquote><p>在我看来，大型 JavaScript 应用程序是<strong>成体系的</strong>，需要开发人员的<strong>努力</strong>维护，而最繁重的数据处理和显示则是在<strong>浏览器</strong>中。</p></blockquote>\n\n<!-- The last part of this definition is possibly the most significant. -->\n\n\n<p>这个定义的最后一部分可能是最重要的。</p>\n\n<!-- ### Let's review your current architecture. -->\n\n\n<h3>让我们回顾一下当前的架构</h3>\n\n<!-- > If working on a significantly large JavaScript application, remember to dedicate **sufficient time** to planning the underlying architecture that makes the most sense. It's often more complex than you may initially imagine. -->\n\n\n<blockquote><p>如果开发一个大型 JavaScript 应用程序，记得要投入<strong>足够的时间</strong>来规划基础架构，这是最有意义的事情。它往往比你最初想象的要更复杂。</p></blockquote>\n\n<!-- I can't stress the importance of this enough - some developers I've seen approach larger applications have stepped back and said 'Okay. Well, there are a set of ideas and patterns that worked well for me on my last medium-scale project. Surely they should mostly apply to something a little larger, right?'. Whilst this may be true to an extent, please don't take it for granted - **larger apps generally have greater concerns that need to be factored in**. I'm going to discuss shortly why spending a little more time planning out the structure to your application is worth it in the long run. -->\n\n\n<p>我无法再强调基础架构的重要性——我见过一些开发人员在遇到大型应用程序时，先退后几步，然后说：“好吧。恩，在我最近的中型项目中已经有一套思路和模式工作的不错。当然，它们也应该大致适用于稍大一点的项目，对吧？”。虽然在某种程度上这么说可能是正确的，但是请不要想当然 - <strong>大型应用程序通常需要考虑更大的问题</strong>。我稍后要讨论为什么多花点时间来为你的应用程序规划结构在长远来看是值得的。</p>\n\n<!-- Most JavaScript developers likely use a mixed combination of the following for their current architecture: -->\n\n\n<p>大部分 JavaScript 开发人员可能在他们的当前架构中混合使用下面的概念：</p>\n\n<!-- * custom widgets\n* models\n* views\n* controllers\n* templates\n* libraries/toolkits\n* an application core. -->\n\n\n<ul>\n<li>自定义控件 custom widgets</li>\n<li>模型 models</li>\n<li>视图 views</li>\n<li>控制器 controllers</li>\n<li>模板 templates</li>\n<li>库/工具集 libraries/toolkits</li>\n<li>应用程序的核心 an application core</li>\n</ul>\n\n\n<!-- **Related Reading** -->\n\n\n<p><strong>相关阅读</strong></p>\n\n<ul>\n<li><a href=\"http://blog.rebeccamurphey.com/code-org-take-2-structuring-javascript-applic\">Rebecca Murphey - Structuring JavaScript Applications</a></li>\n<li><a href=\"http://michaux.ca/articles/mvc-architecture-for-javascript-applications\">Peter Michaux - MVC Architecture For JavaScript Applications</a></li>\n<li><a href=\"http://stackoverflow.com/questions/5112899/knockout-js-vs-backbone-js-vs\">StackOverflow - A discussion on modern MVC frameworks</a></li>\n<li><a href=\"http://msdn.microsoft.com/en-us/scriptjunkie/ff706600\">Doug Neiner - Stateful Plugins and the Widget Factory</a></li>\n</ul>\n\n\n<!-- You probably also break down your application's functionality into blocks of modules or apply other patterns for this. This is great, but there are a number of potential problems you can run into if this represents all of your application's structure. -->\n\n\n<p>你也可能把应用程序分解为一个个的模块，或者应用其他模式来实现。这么做不错，但如果这就是你的应用程序的全部架构，那么你仍然可能栽到一些潜在的问题中。</p>\n\n<!-- ##### 1. How much of this architecture is instantly re-usable? -->\n\n\n<h5>1. 这种架构有多少是可立即复用的？</h5>\n\n<!-- Can single modules exist on their own independently? Are they self-contained? Right now if I were to look at the codebase for a large application you or your team were working on and selected a random module, would it be possible for me to easily just drop it into a new page and start using it on its own?. You may question the rationale behind wanting to do this, however I encourage you to think about the future. What if your company were to begin building more and more non-trivial applications which shared some cross-over in functionality?. If someone said, 'Our users love using the chat module in our mail client. Let's drop that into our new collaborative editing suite', would this be possible without significantly altering the code?. -->\n\n\n<p>单个模块可以独立存在吗？它们是自包含的吗？如果我现在要看看你或你的团队所工作的大型应用程序的代码库，并且随机选择一个模块，我可以简单地把它放入一个新页面，然后开始使用它吗？你可能会质疑这么做背后的理由，但是我鼓励你多想想未来。假使你的公司开始构建越来越多的非凡应用，而它们之间在功能上共享某些交叉点，情形将会怎么样呢？如果有人说，“我们的用户喜欢在我们的邮件客户端中使用聊天模块。让我们把它放到协同编辑套件”，不显著修改代码可以做到这点吗？</p>\n\n<!-- ##### 2. How much do modules depend on other modules in the system? -->\n\n\n<h5>2. 在这个系统中，模块之间的依赖有多少？</h5>\n\n<!-- Are they tightly coupled? Before I dig into why this is a concern, I should note that I understand it's not always possible to have modules with absolutely no other dependencies in a system. At a granular level you may well have modules that extend the base functionality of others, but this question is more-so related to groups of modules with distinct functionality. It should be possible for all of these distinct sets of modules to work in your application without depending on too many other modules being present or loaded in order to function. -->\n\n\n<p>它们是紧耦合的吗？在深入挖掘这为什么会是一个问题之前，我要指出的是，一个系统中的模块绝对无依赖并不总是可行的。在某个粒度级别，你有充分的理由让模块从其他模块扩展基本功能，但问题在于具有不同功能的模块组之间的关联度。而在你的应用程序中，所有这些不同的模块组在正常运行时，不依赖太多其他模块的存在和加载，应该是有可能的。</p>\n\n<!-- ##### 3. If specific parts of your application fail, can it still function? -->\n\n\n<h5>3. 如果应用程序的特定部分崩溃了，应用程序仍然可以运行吗？</h5>\n\n<!-- If you're building a GMail-like application and your webmail module (or modules) fail, this shouldn't block the rest of the UI or prevent users from being able to use other parts of the page such as chat. At the same time, as per before, modules should ideally be able to exist on their own outside of your current application architecture. In my talks I mention dynamic dependency (or module) loading based on expressed user-intent as something related. For example, in GMail's case they might have the chat module collapsed by default without the core module code loaded on page initialization. If a user expressed an intent to use the chat feature, only then would it be dynamically loaded. Ideally, you want this to be possible without it negatively affecting the rest of your application. -->\n\n\n<p>如果你正在构建一个类似 GMail 的应用程序，并且你的 webmail 模块崩溃了，此时不应该阻塞 UI 的其余部分，或者阻止用户使用页面上的其他部分，例如聊天模块。同时，按照之前说的，模块最好可以在当前应用程序的架构之外独立存在。在我的演讲中，我提到了基于用户意图的动态依赖（或模块）加载，用户意图以相关的事件来表达。例如，在 GMail 中，聊天模块默认是收起的，在页面初始化时不需要核心模块代码已经加载完毕。如果用户表示出使用聊天特性的意图，只需要动态加载即可。理想情况下，你期望不受应用程序其余部分的负面影响是可能的。</p>\n\n<!-- ##### 4. How easily can you test individual modules? -->\n\n\n<h5>4. 可以轻松地测试各个模块吗？</h5>\n\n<!-- When working on systems of significant scale where there's a potential for millions of users to use (or mis-use) the different parts it, it's essential that modules which may end up being re-used across a number of different applications be sufficiently tested. Testing needs to be possible for when the module both inside and outside of the architecture for which it was initially built. In my view, this provides the most assurance that it shouldn't break if dropped into another system. -->\n\n\n<p>当在一个有着显著规模的系统上工作，而且这个系统有数以百万计的潜在用户使用或误用系统的不同部分时，模块必然会被多个经过充分测试的应用程序所复用。既需要对模块在（负责初始化它的）架构内部的情况进行测试，也需要对模块在架构之外的情况进行测试。在我看来，当模块应用在另一个系统时，测试为模块不会崩溃提供了最大限度的保证。</p>\n\n<!-- ### Think Long Term -->\n\n\n<h3>想得长远一些</h3>\n\n<!-- When devising the architecture for your large application, it's important to think ahead. Not just a month or a year from now, but beyond that. What might change? It's of course impossible to guess exactly how your application may grow, but there's certainly room to consider what is likely. Here, there is at least one specific aspect of your application that comes to mind. -->\n\n\n<p>当为你的大型项目设计架构时，最重要的是超前思考。不仅仅是从现在开始的一个月或一年，比这要久的多。会改变什么吗？猜测你的应用程序会如何成长当然是不可能的，但是肯定有空间来考虑什么是可能的。在这节内容中，至少会思考应用程序的某个特定方面。</p>\n\n<!-- Developers often couple their DOM manipulation code quite tightly with the rest of their application - even when they've gone to the trouble of separating their core logic down into modules. Think about it..why is this not a good idea if we're thinking long-term? -->\n\n\n<p>开发人员经常把 DOM 操作代码与应用程序的其他部分耦合地相当紧密——甚至在他们已经把核心业务分离为模块时。想想为什么这么做不是一个好主意，如果我们正在做长期规划的话。</p>\n\n<!-- One member of my audience suggested that it was because a rigid architecture defined in the present may not be suitable for the future. Whilst certainly true, there's another concern that may cost even more if not factored in. -->\n\n\n<p>我的观众之一认为原因是，现在定义的这种僵硬架构在未来可能不再合适。这种观点千真万确，而且还有另一层担忧，就是如果现在不考虑进来的话，将来花费的成本甚至可能会更多。</p>\n\n<!-- > You may well decide to switch from using Dojo, jQuery, Zepto or YUI to something entirely different for reasons of performance, security or design in the future. This can become a problem because libraries are not easily interchangeable and have high switching costs if tightly coupled to your app. -->\n\n\n<p>你可能在未来因为性能、安全或设计的原因，决定把正在使用的 Dojo、jQuery、Zepto 或 YUI 切换为某个完全不同的东西。如果库与你的应用程序紧密耦合的话，这种决定就会演变为一个问题，因为互换库并不容易，而且切换的成本高昂。</p>\n\n<!-- If you're a Dojo developer (like some of the audience at my talk), you may not have something better to switch to in the present, but who is to say that in 2-3 years something better doesn't come out that you'll want to switch to?. -->\n\n\n<p>如果你是一个 Dojo 开发人员（例如我演讲会上的一些观众），目前你可能没有值得切换的、更好的库，但是谁敢说在 2-3 年内不会出现更好的、你想要切换的库？</p>\n\n<!-- This is a relatively trivial decision in smaller codebases but for larger applications, having an architecture which is flexible enough to support **not** caring about the libraries being used in your modules can be of great benefit, both financially and from a time-saving perspective. -->\n\n\n<p>在较小的代码库中，这是一个比较琐碎（容易）的决定，但是对于大型应用程序，拥有一个灵活到可以不关心模块所用库的架构，从财政和节省时间的角度来看，都可以带来很大的好处。</p>\n\n<!-- To summarize, if you reviewed your architecture right now, could a decision to switch libraries be made without rewriting your entire application?. If not, consider reading on because I think the architecture being outlined today may be of interest. -->\n\n\n<p>总之，如果你现在回顾你的架构，能够做出无需重写整个应用程序就可以切换库的决定吗？如果不能，请继续读下去，因为我觉得今天介绍的架构可能正是你所感兴趣的。</p>\n\n<!-- There are a number of influential JavaScript developers who have previously outlined some of the concerns I've touched upon so far. Three key quotes I would like to share from them are the following: -->\n\n\n<p>到目前为止，对于我所关注的问题，一些有影响力的 JavaScript 开发人员已经有所涉猎。我想要分享他们的三个关键观点，引文如下所示：</p>\n\n<!-- > \"The secret to building large apps is never build large apps. Break your applications into small pieces. Then, assemble those testable, bite-sized pieces into your big application\" - **Justin Meyer, author JavaScriptMVC** -->\n\n\n<blockquote><p>“构建大型应用程序的秘诀是永不构建大型应用程序。把你的应用程序分解为小块。然后把这些可测试、粒度合适的小块组装到你的大型应用程序中” - <strong>Justin Meyer，JavaScriptMVC 的作者</strong></p></blockquote>\n\n<!-- > \"The key is to acknowledge from the start that you have no idea how this will grow. When you accept that you don't know everything, you begin to design the system defensively. You identify the key areas that may change, which often is very easy when you put a little bit of time into it. For instance, you should expect that any part of the app that communicates with another system will likely change, so you need to abstract that away.\" - **Nicholas Zakas, author 'High-performance JavaScript websites'** -->\n\n\n<blockquote><p>“关键是从一开始就承认你不知道该如何成长。当你接受了你是一无所知的之后，你会开始保守地设计系统。你确定可能会改变的关键领域，当你花一点时间在这上面的话，要做到这点往往很容易。举个例子，你应该想到与应用程序中其他系统进行通信的部分将可能会改变，因此你需要把它抽象出来。” - <strong>Nicholas Zakas，《High-performance JavaScript websites》的作者</strong></p></blockquote>\n\n<!-- and last but not least: -->\n\n\n<p>最后但并非最不重要的：</p>\n\n<!-- \"The more tied components are to each other, the less reusable they will be, and the more difficult it becomes to make changes to one without accidentally affecting another\" - **Rebecca Murphey, author of jQuery Fundamentals.** -->\n\n\n<p>“彼此紧密绑定的组件，较少复用的组件，以及因为会影响到其他组件而变得更难改变的组件” - <strong>Rebecca Murphey, 《jQuery Fundamentals》的</strong></p>\n\n<!-- These principles are essential to building an architecture that can stand the test of time and should always be kept in mind. -->\n\n\n<p>这些原则是构建架构的关键，能够经得起时间的考验，应该始终牢记。</p>\n\n<!-- ### Brainstorming -->\n\n\n<h3>头脑风暴</h3>\n\n<!-- Let's think about what we're trying to achieve for a moment. -->\n\n\n<p>思考一下我们要达到什么目的。</p>\n\n<!-- > We want a loosely coupled architecture with functionality broken down into **independent modules** with ideally no inter-module dependencies. Modules **speak** to the rest of the application when something interesting happens and an **intermediate layer** interprets and reacts to these messages. -->\n\n\n<blockquote><p>我们希望有一个松耦合的架构，功能可以分解为<strong>独立的模块</strong>，最好模块间没有依赖。当有趣的事情发生时，模块<strong>通知</strong>应用程序的其他部分，一个<strong>中间层</strong>解释并响应这些消息。</p></blockquote>\n\n<!-- For example, if we had a JavaScript application responsible for an online bakery, one such 'interesting' message from a module might be 'batch 42 of bread rolls is ready for dispatch'. -->\n\n\n<p>例如，如果我们有一个负责在线面包店的 JavaScript 应用程序，从一个模块发来的“有趣”消息可能是“准备配送第 42 批次的面包卷”。</p>\n\n<!-- We use a different layer to interpret messages from modules so that a) modules don't directly access the core and b) modules don't need to directly call or interact with other modules. This helps prevent applications from falling over due to errors with specific modules and provides us a way to kick-start modules which have fallen over. -->\n\n\n<p>我们使用一个不同的分层来解释模块的消息，以便于：a) 模块不直接访问核心，b) 模块不需要直接调用其他模块或或与之交互。这有助于防止应用程序因为特定模块的错误而崩溃，并且提供了一种方式来重启崩溃的模块。</p>\n\n<!-- Another concern is security. The reality is that most of us don't consider internal application security as that much of a concern. We tell ourselves that as we're structuring the application, we're intelligent enough to figure out what should be publicly or privately accessible. -->\n\n\n<p>另一个令人关注的问题是安全性。然而真实情况是，我们中的大多数人不会考虑应用程序内部的安全性。我们告诉自己，因为是我们构建了应用程序，有足够的聪明来弄清楚哪些应该是公开或试下访问。</p>\n\n<!-- However, wouldn't it help if you had a way to determine what a module was permitted to do in the system? eg. if I know I've limited the permissions in my system to not allow a public chat widget to interface with an admin module or a module with DB-write permissions, I can limit the chances of someone exploiting vulnerabilities I have yet to find in the widget to pass some XSS in there. Modules shouldn’t be able to access everything. They probably can in most current architectures, but do they really need to be able to? -->\n\n\n<p>然而，如果你有办法判断系统中一个模块允许做什么，就不会有帮助了吗？例如，如果我已经在系统中限制了权限，不允许一个公开的聊天部件与权限管理模块，或者与一个用于数据库写权限模块交互，就可以防范有人利用聊天部件的已知漏洞来发起 XSS 攻击。模型不应该有能力访问所有的事务。目前的大多数架构可能可以做到这一点，但是真的需要这么做吗？</p>\n\n<!-- Having an intermediate layer handle permissions for which modules can access which parts of your framework gives you added security. This means a module is only able to do at most what we’ve permitted it do. -->\n\n\n<p>用一个中间层来处理权限问题，来决定哪些模块可以访问框架的哪部分，可以天然的增强安全性。这意味一个模块唯一能做的就是我们允许它做的。</p>\n\n<!-- ## The Proposed Architecture -->\n\n\n<h2>架构提议</h2>\n\n<!-- The solution to the architecture we seek to define is a combination of three well-known design patterns: the **module**, **facade** and **mediator**. -->\n\n\n<p>我们所寻求的架构解决方案是三个著名设计模式的组合体：<strong>模块化</strong>，<strong>外观模式</strong>和<strong>中介者模式</strong>。</p>\n\n<!-- Rather than the traditional model of modules directly communicating with each other, in this decoupled architecture, they'll instead only publish events of interest (ideally, without a knowledge of other modules in the system). The mediator pattern will be used to both subscribe to messages from these modules and handle what the appropriate response to notifications should be. The facade pattern will be used to enforce module permissions. -->\n\n\n<p>在传统的模式中，模块彼此之间直接进行通信，而在解耦架构中，模块只发布感兴趣的事件（在理想情况下，不需要知道系统中的其他模块）。中介者模式将订阅从模块来的消息，并在收到通知时给与适当的响应。中介者模式将用于模块鉴权。</p>\n\n<!-- I will be going into more detail on each of these patterns below: -->\n\n\n<p>我将在后面阐述这些模式的更多细节：</p>\n\n<!-- * Design patterns\n    * Module Theory\n        * [High-level Summary](#modtheory)\n        * [Module pattern](#modpattern)\n        * [Object literal notation](#objliteral)\n        * [CommonJS modules](#commonjsmods)\n    * [Facade Pattern](#facadepattern)\n    * [Mediator Pattern](#mediatorpattern)\nApplying To Your Architecture\n    * [The Facade - Abstraction Of The Core](#applyingfacade)\n    * [The Mediator - The Application Core](#applyingmediator)\n    * [Tying It All Together](#tyingittogether) -->\n\n\n<ul>\n<li>设计模式\n\n<ul>\n<li>模块化理论\n\n<ul>\n<li>摘要</li>\n<li>模块模式</li>\n<li>对象字面量</li>\n<li>CommonJS 模块</li>\n</ul>\n</li>\n<li>外观模式</li>\n<li>中介者模式</li>\n</ul>\n</li>\n<li>在架构中应用\n\n<ul>\n<li>外观 - 抽象的核心</li>\n<li>中介者 - 应用程序的核心</li>\n<li>集成</li>\n</ul>\n</li>\n</ul>\n\n\n<!-- ### Module Theory -->\n\n\n<h3>模块化理论</h3>\n\n<!-- You probably already use some variation of modules in your existing architecture. If however, you don't, this section will present a short primer on them. -->\n\n\n<p>你可能在现有架构中已经使用了一些模块。但如果没有的话，本节将简要介绍关于模块的一些引文。</p>\n\n<!-- > Modules are an **integral** piece of any robust application's architecture and are typically single-purpose parts of a larger system that are interchangeable. -->\n\n\n<blockquote><p>在任何健壮的应用程序的架构中，模块是一个<strong>完整</strong>部件，并且在可互换的较大系统中，模块通常是单一用途的。</p></blockquote>\n\n<!-- Depending on how you implement modules, it's possible to define dependencies for them which can be automatically loaded to bring together all of the other parts instantly. This is considered more scalable than having to track the various dependencies for them and manually load modules or inject script tags. -->\n\n\n<p>按照实现模块的方式，你可以定义模块的依赖，并瞬间自动把其他部分加载进来。相较于无奈地跟踪它们的各种依赖关系，然后手动加载模块或插入 script 标签，这种方式被认为更具有扩展性。</p>\n\n<!-- Any significantly non-trivial application should be built from modular components. Going back to GMail, you could consider modules independent units of functionality that can exist on their own, so the chat feature for example. It's probably backed by a chat module, however, depending on how complex that unit of functionality is, it may well have more granular sub-modules that it depends on. For example, one could have a module simply to handle the use of emoticons which can be shared across both chat and mail composition parts of the system. -->\n\n\n<p>任何成体系的应用程序都应该基于模块化组件构建。回到 GMail，你可以把模块理解为可以独立存在的功能单元，就像聊天模块。然而这取决于功能单元的复杂度，它很可能还依赖于更精细的子模块。例如，有一个子模块负责简单地处理表情符号，而该系统的聊天部件和邮件部件则共享使用这些表情符号。</p>\n\n<!-- > In the architecture being discussed, modules have a very limited knowledge of what's going on in the rest of the system. Instead, we delegate this responsibility to a mediator via a facade. -->\n\n\n<blockquote><p>在正讨论的架构中，模块对系统其他部分的情况所知甚少。而且，我通过一个外观把职责代理到一个中介者上。</p></blockquote>\n\n<!-- This is by design because if a module only cares about letting the system know when something of interest happens without worrying if other modules are running, a system is capable of supporting adding, removing or replacing modules without the rest of the modules in the system falling over due to tight coupling. -->\n\n\n<p>这个刻意设计的，因为如果一个模块只负责通知系统所感兴趣的事情发生了，而不用担心其他模块是否正在运行，那么系统就能够支持添加、移除或更换模块，而系统中的其他模块不会因为紧密耦合而崩溃。</p>\n\n<!-- Loose coupling is thus essential to this idea being possible. It facilitates easier maintainability of modules by removing code dependencies where possible. In our case, modules should not rely on other modules in order to function correctly. When loose coupling is implemented effectively, its straight-forward to see how changes to one part of a system may affect another. -->\n\n\n<p>这种思路行得通的关键是松耦合。松耦合通过在必要时移除代码依赖关系，简化了模块的维护。在我们的例子中，模块不应该依赖于其他模块才能正常运行。当松耦合被有效地贯彻时，看看系统某个部分的变化是如何影响其他部分的。</p>\n\n<!-- In JavaScript, there are several options for implementing modules including the well-known module pattern and object literals. Experienced developers will already be familiar with these and if so, please skip ahead to the section on CommonJS modules. -->\n\n\n<p>在 JavaScript 中，有几种可选的模块化实现方式，包括广为人知的模块模式和对象字面量。有经验的开发人员应该已经熟知这些知识，如果是这样的话，请跳到介绍 CommonJS 模块的部分。</p>\n\n<!-- ##### The Module Pattern -->\n\n\n<h5>模块模式</h5>\n\n<!-- The module pattern is a popular design that pattern that encapsulates 'privacy', state and organization using closures. It provides a way of wrapping a mix of public and private methods and variables, protecting pieces from leaking into the global scope and accidentally colliding with another developer's interface. With this pattern, only a public API is returned, keeping everything else within the closure private. -->\n\n\n<p>模块模式是一种流行的设计模式，通过使用闭包来封装“隐私”、状态和结构。它可以包裹公开和私有的方法和变量，避免它们污染全局作用域，以及避免与其他开发人员的接口冲突。这种模式只会返回公开的 API，此外的一切则是封闭和私有的。</p>\n\n<!-- This provides a clean solution for shielding logic doing the heavy lifting whilst only exposing an interface you wish other parts of your application to use. The pattern is quite similar to an immediately-invoked functional expression (IIFE) except that an object is returned rather than a function. -->\n\n\n<p>模块模式提供了一种清爽的解决方案，屏蔽了承担繁重任务的逻辑，只向应用程序的其他部分暴露希望它们使用的接口。这种模式与立即调用的函数表达式（IIFE）非常相似，只不过前者返回的是一个对象，而后者返回的是一个函数。。</p>\n\n<!-- It should be noted that there isn't really a true sense of 'privacy' inside JavaScript because unlike some traditional languages, it doesn't have access modifiers. Variables can't technically be declared as being public nor private and so we use function scope to simulate this concept. Within the module pattern, variables or methods declared are only available inside the module itself thanks to closure. Variables or methods defined within the returning object however are available to everyone. -->\n\n\n<p>应该指出的是，在 JavaScript 中并不存在真正意义上的“隐私”，因为它不像一些传统语言一样具有访问修饰符。从技术的角度，变量不能被声明为公开或私有，所以我们用函数作用域来模拟这个概念。在模块模式中，仰赖于闭包机制，声明的变量或方法只在模块自身内部有效。而返回的对象中的变量或方法对所有人都是可用的。</p>\n\n<!-- Below you can see an example of a shopping basket implemented using the pattern. The module itself is completely self-contained in a global object called `basketModule`. The `basket` array in the module is kept private and so other parts of your application are unable to directly read it. It only exists with the module's closure and so the only methods able to access it are those with access to its scope (ie. `addItem()`, `getItem()` etc). -->\n\n\n<p>你可以在下面看到一个购物车示例，其中使用了模块模式。该模块自身被包含在一个称为<code>basketModule</code> 的全局对象中，完全自给自足。模块中的数组 <code>basket</code> 是私有的，应用程序的其他部分无法直接读取它。它只存在于这个模块的闭包中，因此，只有可以访问它所属作用域的方法（即 <code>addItem()</code>、<code>getItem()</code> 等），才可以访问它。</p>\n\n<pre><code>var basketModule = (function() {\n    var basket = []; //private\n    return { //exposed to public\n        addItem: function(values) {\n            basket.push(values);\n        },\n        getItemCount: function() {\n            return basket.length;\n        },\n        getTotal: function(){\n           var q = this.getItemCount(),p=0;\n            while(q--){\n                p+= basket[q].price; \n            }\n            return p;\n        }\n    }\n}());\n</code></pre>\n\n<!-- Inside the module, you'll notice we return an object. This gets automatically assigned to basketModule so that you can interact with it as follows: -->\n\n\n<p>在模块内部，你会发现它返回了一个对象。这种做法使得返回值被自动赋值给 basketModule，因此你像下面这样与它交互：</p>\n\n<pre><code>//basketModule is an object with properties which can also be methods\nbasketModule.addItem({item:'bread',price:0.5});\nbasketModule.addItem({item:'butter',price:0.3});\n\nconsole.log(basketModule.getItemCount());\nconsole.log(basketModule.getTotal());\n\n//however, the following will not work:\nconsole.log(basketModule.basket);// (undefined as not inside the returned object)\nconsole.log(basket); //(only exists within the scope of the closure)\n</code></pre>\n\n<!-- The methods above are effectively namespaced inside basketModule. -->\n\n\n<p>上面的方法被有效的限制在命名空间 basketModule 中。</p>\n\n<!-- From a historical perspective, the module pattern was originally developed by a number of people including Richard Cornford in 2003. It was later popularized by Douglas Crockford in his lectures and re-introduced by Eric Miraglia on the YUI blog. -->\n\n\n<p>从历史的角度看，模块模式最初是由一些人发现的，包括 Richard Cornford（2013年）。后来被 Douglas Crockford 在他的演讲中推广，并被 Eric Miraglia 在 YUI 的博客中再次介绍。</p>\n\n<!-- How about the module pattern in specific toolkits or frameworks? -->\n\n\n<p>在具体的工具库或框架中，模块模式是什么样的情况呢？</p>\n\n<p><strong>Dojo</strong></p>\n\n<!-- Dojo attempts to provide 'class'-like functionality through `dojo.declare`, which can be used for amongst other things, creating implementations of the module pattern. For example, if we wanted to declare `basket` as a module of the `store` namespace, this could be achieved as follows: -->\n\n\n<p>Dojo 尝试通过 <code>dojo.declare</code> 来实现模块模式，提供与“class”类似的功能。例如，如果我们想把 <code>basket</code> 声明为命名空间 <code>store</code> 下的一个模块，可以做如下实现：</p>\n\n<pre><code>//traditional way\nvar store = window.store || {};\nstore.basket = store.basket || {};\n\n//using dojo.setObject\ndojo.setObject(\"store.basket.object\", (function() {\n    var basket = [];\n    function privateMethod() {\n        console.log(basket);\n    }\n    return {\n        publicMethod: function(){\n                privateMethod();\n        }\n    };\n}()));\n</code></pre>\n\n<!-- which can become quite powerful when used with `dojo.provide` and mixins. -->\n\n\n<p>如果 <code>dojo.declare</code> 与 <code>dojo.provide</code> 和 mixins 结合使用，可以变得非常强大。</p>\n\n<p><strong>YUI</strong></p>\n\n<!-- The following example is heavily based on the original YUI module pattern implementation by Eric Miraglia, but is relatively self-explanatory. -->\n\n\n<p>下面的例子基于 Eric Miraglia 实现的原始 YUI 模块模式，虽然有些厚重，但尚能自圆其说。</p>\n\n<pre><code>YAHOO.store.basket = function () {\n\n    //\"private\" variables:\n    var myPrivateVar = \"I can be accessed only within YAHOO.store.basket .\";\n\n    //\"private\" method:\n    var myPrivateMethod = function () {\n            YAHOO.log(\"I can be accessed only from within YAHOO.store.basket\");\n        }\n\n    return {\n        myPublicProperty: \"I'm a public property.\",\n        myPublicMethod: function () {\n            YAHOO.log(\"I'm a public method.\");\n\n            //Within basket, I can access \"private\" vars and methods:\n            YAHOO.log(myPrivateVar);\n            YAHOO.log(myPrivateMethod());\n\n            //The native scope of myPublicMethod is store so we can\n            //access public members using \"this\":\n            YAHOO.log(this.myPublicProperty);\n        }\n    };\n\n}();\n</code></pre>\n\n<p><strong>jQuery</strong></p>\n\n<!-- There are a number of ways in which jQuery code unspecific to plugins can be wrapped inside the module pattern. Ben Cherry previously suggested an implementation where a function wrapper is used around module definitions in the event of there being a number of commonalities between modules. -->\n\n\n<p>把 jQuery 代码（不局限于插件）封装为模块模式有很多种方式。Ben Cherry 曾经建议过一种实现：用一个函数把模块定义包裹起来，模块定义则含有一些共性事件。</p>\n\n<!-- In the following example, a `library` function is defined which declares a new library and automatically binds up the `init` function to `document.ready` when new libraries (ie. modules) are created. -->\n\n\n<p>在下面的示例中，定义了一个函数 <code>library</code>，该函数用于声明一个新库，当新库（即模块）被创建时，会并自动把函数 <code>init</code> 绑定到 <code>document.ready</code>。</p>\n\n<pre><code>function library(module) {\n  $(function() {\n    if (module.init) {\n      module.init();\n    }\n  });\n  return module;\n}\n\nvar myLibrary = library(function() {\n   return {\n     init: function() {\n       /*implementation*/\n     }\n   };\n}());\n</code></pre>\n\n<!-- **Related Reading** -->\n\n\n<p><strong>相关阅读</strong></p>\n\n<ul>\n<li><a href=\"http://www.adequatelygood.com/2010/3/JavaScript-Module-Pattern-In-Depth\">Ben Cherry - The Module Pattern In-Depth</a></li>\n<li><a href=\"http://lanyrd.com/2011/jsconf/sfgdk/\">John Hann - The Future Is Modules, Not Frameworks</a></li>\n<li><a href=\"https://gist.github.com/274388\">Nathan Smith - A Module pattern aliased window and document gist</a></li>\n<li><a href=\"http://blog.davidlitmark.com/post/6009004931/an-introduction-to-the-revealing-module-pattern\">David Litmark - An Introduction To The Revealing Module Pattern</a></li>\n</ul>\n\n\n<!-- #### Object Literal Notation -->\n\n\n<h4>对象字面量</h4>\n\n<!-- In object literal notation, an object is described as a set of comma-separated name/value pairs enclosured in curly braces (`{}`). Names inside the object may be either strings or identifiers that are followed by a colon. There should be no comma used after the final name/value pair in the object as this may result in errors. -->\n\n\n<p>在对象字面量中，一个对象被描述为一组用逗号分隔的名称/值对，并用大括号（<code>{}</code>）包裹起来。对象中的名称可以是字符串或唯一标识，后跟一个冒号。不应该在对象中最后一对名称/值的后面使用逗号，因为这可能导致错误。</p>\n\n<!-- Object literals don't require instantiation using the `new` operator but shouldn't be used at the start of a statement as the opening `{` may be interpreted as the beginning of a block. Below you can see an example of a module defined using object literal syntax. New members may be added to the object using assignment as follows `myModule.property = 'someValue';` -->\n\n\n<p>对象字面量不需要使用操作符 <code>new</code> 来实例化，但是不应该使用在语句的起始处，因为 <code>{</code> 可能会被解释为代码块的开始。你可以在下面看到一个使用对象字面量来定义模块的示例。新成员可能被通过赋值添加到对象上，就像下面的 <code>myModule.property = 'someValue';</code>。</p>\n\n<!-- > Whilst the module pattern is useful for many things, if you find yourself not requiring specific properties or methods to be private, the object literal is a more than suitable alternative. -->\n\n\n<blockquote><p>虽然模块模式适用于很多场景，但如果你发现并不需要特定的私有属性或方法，那么对象字面量无疑是更合适的替代品。</p></blockquote>\n\n<pre><code>var myModule = {\n    myProperty : 'someValue',\n    //object literals can contain properties and methods.\n    //here, another object is defined for configuration\n    //purposes:\n    myConfig:{\n        useCaching:true,\n        language: 'en'   \n    },\n    //a very basic method\n    myMethod: function(){\n        console.log('I can haz functionality?');\n    },\n    //output a value based on current configuration\n    myMethod2: function(){\n        console.log('Caching is:' + (this.myConfig.useCaching)?'enabled':'disabled');\n    },\n    //override the current configuration\n    myMethod3: function(newConfig){\n        if(typeof newConfig == 'object'){\n           this.myConfig = newConfig;\n           console.log(this.myConfig.language); \n        }\n    }\n};\n\nmyModule.myMethod(); //I can haz functionality\nmyModule.myMethod2(); //outputs enabled\nmyModule.myMethod3({language:'fr',useCaching:false}); //fr\n</code></pre>\n\n<!-- **Related Reading** -->\n\n\n<p><strong>相关阅读</strong></p>\n\n<ul>\n<li><a href=\"http://blog.rebeccamurphey.com/2009/10/15/using-objects-to-organize-your-code\">Rebecca Murphey - Using Objects To Organize Your Code</a></li>\n<li><a href=\"http://www.phpied.com/3-ways-to-define-a-javascript-class/\">Stoyan Stefanov - 3 Ways To Define A JavaScript Class</a></li>\n<li><a href=\"http://benalman.com/news/2010/03/theres-no-such-thing-as-a-json/\">Ben Alman - Clarifications On Object Literals (There's no such thing as a JSON Object)</a></li>\n<li><a href=\"http://ejohn.org/blog/simple-javascript-inheritance/\">John Resig - Simple JavaScript Inheritance</a></li>\n</ul>\n\n\n<!-- ### CommonJS Modules -->\n\n\n<h3>CommonJS 模块</h3>\n\n<!-- Over the last year or two, you may have heard about [CommonJS] - a volunteer working group which designs, prototypes and standardizes JavaScript APIs. To date they've ratified standards for modules and packages.The CommonJS AMD proposal specifies a simple API for declaring modules which can be used with both synchronous and asynchronous script tag loading in the browser. Their module pattern is relatively clean and I consider it a reliable stepping stone to the module system proposed for ES Harmony (the next release of the JavaScript language). -->\n\n\n<p>在过去一两年中，你可能已经听说过 <a href=\"http://commonjs.org/\">CommonJS</a> - 一个致力于设计、原型化和标准化 JavaScript API 的志愿者工作组。迄今为止，他们已经批准了针对模块和包的标准。CommonJS AMD 建议规范一个简单的 API 来声明模块，并且可以在浏览器中通过同步和异步 script 标签来加载声明的模块。他们的模块模式相对比较清爽，并且我认为它是 ES Harmony（JavaScript 语言的下一个版本）所建议的模块系统的可靠基石。</p>\n\n<!-- From a structure perspective, a CommonJS module is a reusable piece of JavaScript which exports specific objects made available to any dependent code. This module format is becoming quite ubiquitous as a standard module format for JS. There are plenty of great tutorials on implementing CommonJS modules, but at a high-level they basically contain two primary parts: an `exports` object that contains the objects a module wishes to make available to other modules and a `require` function that modules can use to import the exports of other modules. -->\n\n\n<p>从结构的角度来看，一个 CommonJS 模块是一段可重用的 JavaScript，它输出特定的对象以供任何依赖它的代码使用。这种模块格式正在变得相当普及，成为事实上的 JS 标准模块格式。有许多关于实施 CommonJS 模块的伟大教程，但是从高层次角度看的话，它们基本上包含两个主要部分：一个 <code>exports</code> 对象包含了希望对其他模块可用的模块，一个 <code>require</code> 函数用来让模块导入其他模块的输出。</p>\n\n<pre><code>/*\nExample of achieving compatibility with AMD and standard CommonJS by putting boilerplate around the standard CommonJS module format:\n*/\n\n(function(define){\ndefine(function(require,exports){\n// module contents\n var dep1 = require(\"dep1\");\n exports.someExportedFunction = function(){...};\n //...\n});\n})(typeof define==\"function\"?define:function(factory){factory(require,exports)});\n</code></pre>\n\n<!-- There are a number of great JavaScript libraries for handling module loading in the CommonJS module format, but my personal preference is RequireJS. A complete tutorial on RequireJS is outside the scope of this tutorial, but I can recommend reading James Burke's ScriptJunkie post on it [here](http://msdn.microsoft.com/en-us/scriptjunkie/ff943568). I know a number of people that also like `Yabble`. -->\n\n\n<p>有许多伟大的 JavaScript 库可以按照 CommonJS 模块规范来处理模块加载，但我个人偏好于 RequireJS。完整的 RequireJS 教程超出了本文的范畴，不过我推荐读一读 James Burke 的博文 <a href=\"http://msdn.microsoft.com/en-us/scriptjunkie/ff943568\">ScriptJunkie</a>。我知道有些人也喜欢 <code>Yabble</code>。</p>\n\n<!-- Out of the box, RequireJS provides methods for easing how we create static modules with wrappers and it's extremely easy to craft modules with support for asynchronous loading. It can easily load modules and their dependencies this way and execute the body of the module once available. -->\n\n\n<p>从使用的角度看，RequireJS 提供了一些包装方法，来简化静态模块的创建过程和异步加载。它可以很容易的加载模块以及模块的依赖，然后在模块就绪时执行模块的内容。</p>\n\n<!-- There are some developers that however claim CommonJS modules aren't suitable enough for the browser. The reason cited is that they can't be loaded via a script tag without some level of server-side assistance. We can imagine having a library for encoding images as ASCII art which might export a `encodeToASCII` function. A module from this could resemble: -->\n\n\n<p>有些开发人员声称 CommonJS 模块不太适用在浏览器中。原因是 CommonJS 模块无法通过 script 标签加载，除非有服务端协助。我们假设有一个把图片编码为 ASCII 的库，它暴露出一个 <code>encodeToASCII</code> 函数。它的模块类似于：</p>\n\n<pre><code>var encodeToASCII = require(\"encoder\").encodeToASCII;\nexports.encodeSomeSource = function(){\n    //process then call encodeToASCII\n}\n</code></pre>\n\n<!-- This type of scenario wouldn't work with a script tag because the scope isn't wrapped, meaning our `encodeToASCII` method would be attached to the `window`, `require` wouldn't be as such defined and exports would need to be created for each module separately. A client-side library together with server-side assistance or a library loading the script with an XHR request using `eval()` could however handle this easily. -->\n\n\n<p>在这类情况下，script 标签将无法正常工作，因为作用域不匹配，这就意味着方法 <code>encodeToASCII</code> 将被绑定到 <code>window</code> 对象、<code>require</code> 未定义，并且需要为每个模块单独创建 exports。但是，客户端库在服务端的协助下，或者库通过 XHR 请求加载脚本并使用了 <code>eval()</code>，都可以很容易地处理这种情况，</p>\n\n<!-- Using RequireJS, the module from earlier could be rewritten as follows: -->\n\n\n<p>使用 RequireJS，该模块的早期版本可以重写为下面这样：</p>\n\n<pre><code>define(function(require, exports, module) {\n    var encodeToASCII = require(\"encoder\").encodeToASCII;\n    exports.encodeSomeSource = function(){\n            //process then call encodeToASCII\n    }\n});\n</code></pre>\n\n<!-- For developers who may not rely on just using static JavaScript for their projects, CommonJS modules are an excellent path to go down, but do spend some time reading up on it. I've really only covered the tip of the ice berg but both the CommonJS wiki and Sitepen have a number of resources if you wish to read further. -->\n\n\n<p>对于不只依赖于静态 JavaScript 的项目来说，CommonJS 模块是很好的选择，不过一定要花一些时间来阅读相关的内容。我仅仅涉及到了冰山一角，如果你想进一步阅读的话，CommonJS 的 wikie 和 Sitepen 有着大量资源。</p>\n\n<!-- **Related Reading** -->\n\n\n<p><strong>相关阅读</strong></p>\n\n<ul>\n<li><a href=\"http://wiki.commonjs.org/wiki/Modules\">The CommonJS Module Specifications</a></li>\n<li><a href=\"http://dailyjs.com/2010/10/18/modules/\">Alex Young - Demystifying CommonJS Modules</a></li>\n<li><a href=\"http://requirejs.org/docs/commonjs.html#packages\">Notes on CommonJS modules with RequireJS</a></li>\n</ul>\n\n\n<!-- ### The Facade Pattern -->\n\n\n<h3>外观模式</h3>\n\n<!-- Next, we're going to look at the facade pattern, a design pattern which plays a critical role in the architecture being defined today. -->\n\n\n<p>接下来，我们要看看外观模式，这个设计模式在今天定义的架构中扮演着关键角色。</p>\n\n<!-- When you put up a facade, you're usually creating an outward appearance which conceals a different reality. The facade pattern provides a convenient **higher-level interface** to a larger body of code, hiding its true underlying complexity. Think of it as simplifying the API being presented to other developers. -->\n\n\n<p>当构造一个外观时，通常是创建一个掩盖了不同现实的外在表现。外观模式为更大的代码块提供了一个方便的<strong>高层接口</strong>，通过隐藏其真正复杂的底层。把它看成是提交给其他开发人员的简化版 API。</p>\n\n<!-- Facades are a **structural pattern** which can often be seen in JavaScript libraries and frameworks where, although an implementation may support methods with a wide range of behaviors, only a 'facade' or limited abstract of these methods is presented to the client for use. -->\n\n\n<p>外观是<strong>结构模式</strong>的一种，经常可以在 JavaScript 库和框架中看到它，它的内部实现虽然可以提供各种行为的方法，但是只有一个“外观”或这些方法的有限抽象被提交给客户使用。</p>\n\n<!-- This allows us to interact with the facade rather than the subsystem behind the scenes. -->\n\n\n<p>这样一来，我们是与外观交互，而不是与幕后的子系统交互。</p>\n\n<!-- The reason the facade is of interest is because of its ability to hide implementation-specific details about a body of functionality contained in individual modules. The implementation of a module can change without the clients really even knowing about it. -->\n\n\n<p>外观之所以好用的原因在于，它能够隐藏各个模块中功能的具体实现细节。模块实现的改变甚至可以在客户不知情的情况下进行。</p>\n\n<!-- By maintaining a consistent facade (simplified API), the worry about whether a module extensively uses dojo, jQuery, YUI, zepto or something else becomes significantly less important. As long as the interaction layer doesn't change, you retain the ability to switch out libraries (eg. jQuery for Dojo) at a later point without affecting the rest of the system. -->\n\n\n<p>通过维护一个统一的外观（简化后的 API），对模块是否使用 dojo、jQuery、YUI、zepto 或者别的东西的担心就显得不太重要。只要交互层不改变，就保留了在将来切换库（例如用 jQuery 替换 Dojo）的能力，而不会影响系统的其他部分。</p>\n\n<!-- Below is a very basic example of a facade in action. As you can see, our module contains a number of methods which have been privately defined. A facade is then used to supply a much simpler API to accessing these methods: -->\n\n\n<p>下面是一个非常简单的外观行为示例。正如你可以看到的，我们的模块包含了一些定位为私有的方法。然后用外观提供的更简单的 API 来访问这些方法。</p>\n\n<pre><code>var module = (function() {\n    var _private = {\n        i:5,\n        get : function() {\n            console.log('current value:' + this.i);\n        },\n        set : function( val ) {\n            this.i = val;\n        },\n        run : function() {\n            console.log('running');\n        },\n        jump: function(){\n            console.log('jumping');\n        }\n    };\n    return {\n        facade : function( args ) {\n            _private.set(args.val);\n            _private.get();\n            if ( args.run ) {\n                _private.run();\n            }\n        }\n    }\n}());\n\n\nmodule.facade({run: true, val:10});\n//outputs current value: 10, running\n</code></pre>\n\n<!-- and that's really it for the facade before we apply it to our architecture. Next, we'll be diving into the exciting mediator pattern. The core difference between the facade pattern and the mediator is that the facade (a structural pattern) only exposes existing functionality whilst the mediator (a behavioral pattern) can add functionality. -->\n\n\n<p>在把外观应用到我们的架构中之前，关于外观就介绍这么多。接下来，我们将深入激动人心的中介者模式。外观模式和中介者模式之间的核心区别在于，外观模式（一种结构模式）只公开已有的功能，而中介者模式（一种行为模式）可以添加功能。</p>\n\n<!-- **Related Reading** -->\n\n\n<p><strong>相关阅读</strong></p>\n\n<ul>\n<li><a href=\"http://books.google.co.uk/books?id=za3vlnlWxb0C&amp;lpg=PA141&amp;ots=MD5BLTsSzH&amp;dq=javascript%20facade%20pattern&amp;pg=PA141#v=onepage&amp;q=javascript%20facade%20pattern&amp;f=false\">Dustin Diaz, Ross Harmes - Pro JavaScript Design Patterns (Chapter 10, available to read on Google Books)</a></li>\n</ul>\n\n\n<!-- ### The Mediator Pattern -->\n\n\n<h3>中介者模式</h3>\n\n<!-- The mediator pattern is best introduced with a simple analogy - think of your typical airport traffic control. The tower handles what planes can take off and land because all communications are done from the planes to the control tower, rather than from plane-to-plane. A centralized controller is key to the success of this system and that's really what a mediator is. -->\n\n\n<p>介绍中介者模式的最佳方式是用一个简单的比喻——想象一下机场交通管制。塔台处理哪些飞机可以起飞或降落，因为所有的通信都由飞机和控制塔完成，而不是由飞机之间。集中控制是这个系统成功的关键，而这就是一个中介者。</p>\n\n<!-- > Mediators are used when the communication between modules may be complex, but is still **well defined**. If it appears a system may have too many relationships between modules in your code, it may be time to have a central point of control, which is where the pattern fits in. -->\n\n\n<blockquote><p>当模块之间的通信有可能是复杂的，请使用中介者，但是这一点<strong>不易鉴定</strong>。如果有这样一个系统，代码中的模块之间有大多的关系，那么就该有一个中央控制点了，这就是这个模式的用武之地。</p></blockquote>\n\n<!-- In real-world terms, a mediator **encapsulates** how disparate modules **interact** with each other by acting as an intermediary. The pattern also promotes loose coupling by preventing objects from referring to each other explicitly - in our system, this helps to solve our module inter-dependency issues. -->\n\n\n<p>一个中介者<strong>封装</strong>了不同模块之间的<strong>交互</strong>行为，就像现实世界中的中间人。该模式阻止了对象彼此之间直接引用，从而促进了松耦合——这有助于我们解决系统中模块互相依赖的问题。</p>\n\n<!-- What other advantages does it have to offer? Well, mediators allow for actions of each module to vary independently, so it’s extremely flexible. If you've previously used the Observer (Pub/Sub) pattern to implement an event broadcast system between the modules in your system, you'll find mediators relatively easy to understand. -->\n\n\n<p>它还必须提供什么其他的优势呢？恩，中介者允许每个模块的行为可以独立变化，所以它非常灵活。如果你曾经在你的系统使用过观察者（发布/订阅）模式来实现模块之间的事件广播系统，你将会发现中介者相对而言比较容易理解。</p>\n\n<!-- Let's take a look at a high level view of how modules might interact with a mediator: -->\n\n\n<p>让我们以高层次的视角来看看模块是如何与中介者交互的：</p>\n\n<p><img src=\"http://addyosmani.com/largescalejavascript/assets/img/chart4a.jpg\" alt=\"\" /></p>\n\n<!-- Consider modules as publishers and the mediator as both a publisher and subscriber. Module 1 broadcasts an event notifying the mediator something needs to done. The mediator captures this message and 'starts' the modules needed to complete this task Module 2 performs the task that Module 1 requires and broadcasts a completion event back to the mediator. In the mean time, Module 3 has also been started by the mediator and is logging results of any notifications passed back from the mediator. -->\n\n\n<p>模块是发布者，中介者则既是发布者又是订阅者。模块 1 广播一个事件了通知中介者有事要做。中介者捕获这个消息，继而启动需要完成这项任务的模块 2，模块 2 执行模块 1 要求的任务，并向中介者广播一个完成事件。与此同时，模块 3 也会被中介者启动，记录从中介者传来的任何通知。</p>\n\n<!-- Notice how at no point do any of the modules **directly communicate** with one another. If Module 3 in the chain were to simply fail or stop functioning, the mediator could hypothetically 'pause' the tasks on the other modules, stop and restart Module 3 and then continue working with little to no impact on the system. This level of decoupling is one of the main strengths the pattern has to offer. -->\n\n\n<p>任何模块没有机会与其他模块<strong>直接通信</strong>，请注意是如何做到这点的。如果调用链中的模块 3 失败或停止运行，中介者可以假装“暂停”其他模块的任务，停止模块 3 并重启它，然后继续工作，这对系统而言几乎没有影响。这种程度的解耦是中介者模块提供的主要优势之一。</p>\n\n<!-- To review, the advantages of the mediator are that: -->\n\n\n<p>回复一下，中介者的优势如下：</p>\n\n<!-- It decouples modules by introducing an intermediary as a central point of control.It allows modules to broadcast or listen for messages without being concerned with the rest of the system. Messages can be handled by any number of modules at once. -->\n\n\n<p>它通过引入一个中间人作为中央控制点来解耦模块。它允许模块广播或监听消息，而不必关注系统的其他的部分。消息可以同时被任意数量的模块所处理。</p>\n\n<!-- It is typically significantly more easy to add or remove features to systems which are loosely coupled like this. -->\n\n\n<p>显然，向松耦合的系统添加或移除功能变得更容易。</p>\n\n<!-- And its disadvantages: -->\n\n\n<p>但它的缺点是：</p>\n\n<!-- By adding a mediator between modules, they must always communicate indirectly. This can cause a very minor performance drop - because of the nature of loose coupling, its difficult to establish how a system might react by only looking at the broadcasts. At the end of the day, tight coupling causes all kinds of headaches and this is one solution. -->\n\n\n<p>通过在模块之间增加中介者，模块必须总是间接地通信。这可能会导致轻微的性能下降——因为松耦合的性质所然，而且很难预期一个关注广播的系统会如何响应。紧耦合令人各种头疼，而中介者正是一条解决之道。</p>\n\n<!-- **Example:** This is a possible implementation of the mediator pattern based on previous work by [@rpflorence] -->\n\n\n<p><strong>示例：</strong>这是中介者模式在 <a href=\"https://github.com/rpflorence\">@rpflorence</a> 早先工作基础上的一种可能实现。</p>\n\n<pre><code>var mediator = (function(){\n    var subscribe = function(channel, fn){\n        if (!mediator.channels[channel]) mediator.channels[channel] = [];\n        mediator.channels[channel].push({ context: this, callback: fn });\n        return this;\n    },\n\n    publish = function(channel){\n        if (!mediator.channels[channel]) return false;\n        var args = Array.prototype.slice.call(arguments, 1);\n        for (var i = 0, l = mediator.channels[channel].length; i &lt; l; i++) {\n            var subscription = mediator.channels[channel][i];\n            subscription.callback.apply(subscription.context, args);\n        }\n        return this;\n    };\n\n    return {\n        channels: {},\n        publish: publish,\n        subscribe: subscribe,\n        installTo: function(obj){\n            obj.subscribe = subscribe;\n            obj.publish = publish;\n        }\n    };\n\n}());\n</code></pre>\n\n<!-- **Example:** Here are two sample uses of the implementation from above. It's effectively managed publish/subscribe: -->\n\n\n<p><strong>示例：</strong>这是前面实现的两个使用示例。发布/订阅被有效的管理起来。</p>\n\n<pre><code>//Pub/sub on a centralized mediator\n\nmediator.name = \"tim\";\nmediator.subscribe('nameChange', function(arg){\n        console.log(this.name);\n        this.name = arg;\n        console.log(this.name);\n});\n\nmediator.publish('nameChange', 'david'); //tim, david\n\n\n//Pub/sub via third party mediator\n\nvar obj = { name: 'sam' };\nmediator.installTo(obj);\nobj.subscribe('nameChange', function(arg){\n        console.log(this.name);\n        this.name = arg;\n        console.log(this.name);\n});\n\nobj.publish('nameChange', 'john'); //sam, john\n</code></pre>\n\n<!-- **Related Reading** -->\n\n\n<p><strong>相关阅读</strong></p>\n\n<ul>\n<li>Stoyan Stefanov - Page 168, JavaScript Patterns</li>\n<li><a href=\"http://arguments.callee.info/2009/05/18/javascript-design-patterns--mediator/\">HB Stone - JavaScript Design Patterns: Mediator</a></li>\n<li><a href=\"http://www.vincehuston.org/dp/mediator.html\">Vince Huston - The Mediator Pattern (not specific to JavaScript, but a concise)</a></li>\n</ul>\n\n\n<!-- ### Applying The Facade: Abstraction Of The Core -->\n\n\n<h3>应用外观：核心的抽象</h3>\n\n<!-- In the architecture suggested: -->\n\n\n<p>架构建议：</p>\n\n<!-- A facade serves as an **abstraction** of the application core which sits between the mediator and our modules - it should ideally be the only other part of the system modules are aware of. -->\n\n\n<p>一个外观作为应用程序核心的<strong>抽象</strong>，位于中介者和模块之间——理想情况下，它应该是系统中唯一可以感知其他模式的模块。</p>\n\n<!-- The responsibilities of the abstraction include ensuring a **consistent interface** to these modules is available at all times. This closely resembles the role of the **sandbox controller** in the excellent architecture first suggested by Nicholas Zakas. -->\n\n\n<p>这个抽象的职责包括了为这些模块提供<strong>统一的接口</strong>，以及确保在任何时候都是可用的。这一点非常类似于杰出架构中<strong>沙箱控制器</strong>的角色，它由 Nicholas Zakas 首次提出。</p>\n\n<!-- Components are going to communicate with the mediator through the facade so it needs to be **dependable**. When I say 'communicate', I should clarify that as the facade is an abstraction of the mediator which will be listening out for broadcasts from modules that will be relayed back to the mediator. -->\n\n\n<p>组件将通过外观与中介者通信，所以外观必须是可靠的。应该澄清的是，当我说“通信”时实际上是指与外观进行通信，外观是中介者的抽象，将监听模块的广播，再把广播回传给中介者。</p>\n\n<!-- In addition to providing an interface to modules, the facade also acts as a security guard, determining which parts of the application a module may access. Components only call their own methods and shouldn't be able to interface with anything they don't have permission to. For example, a module may broadcast `dataValidationCompletedWriteToDB`. The idea of a security check here is to ensure that the module has permissions to request database-write access. What we ideally want to avoid are issues with modules accidentally trying to do something they shouldn't be. -->\n\n\n<p>除了为模块提供接口，中介者还扮演者安保的角色，确定一个模块可以访问应用程序的哪些部分。组件只能访问它们自己的方法，对于它没有权限的任何东西，则不能与之行交互。假设一个模块可以广播 <code>dataValidationCompletedWriteToDB</code>。此时，安全检查的概念是指确保有权限的模块才能请求数据写操作。我们最好避免让模块意外地试图做一些它们本不该做的事情。</p>\n\n<!-- To review in short, the mediator remains a type of pub/sub manager but is only passed interesting messages once they've cleared permission checks by the facade. -->\n\n\n<p>总之，中介者是发布/订阅的管理者，不过，只有通过外观权限检查的感兴趣事件才会被传给中介者。</p>\n\n<!-- ### Applying the Mediator: The Application Core -->\n\n\n<h3>应用中介者：应用程序的核心</h3>\n\n<!-- The mediator plays the role of the application core. We've briefly touched on some of its responsibilities but lets clarify what they are in full. -->\n\n\n<p>中介者扮演的角色是应用程序的核心。我们已经简要介绍了一些它的职责，不过还是要澄清下它的所有职责。</p>\n\n<!-- The core's primary job is to manage the module **lifecycle**. When the core detects an **interesting message** it needs to decide how the application should react - this effectively means deciding whether a module or set of modules needs to be **started** or **stopped**. -->\n\n\n<p>核心的主要任务是管理模块的<strong>生命周期</strong>。当核心侦测到一个<strong>感兴趣的事件</strong>时，它需要决定应用程序该如何响应——这实际上意味着决定是否需要<strong>启动</strong>或<strong>停止</strong>一个或一组模块。</p>\n\n<!-- Once a module has been started, it should ideally execute **automatically**. It's not the core's task to decide whether this should be when the DOM is ready and there's enough scope in the architecture for modules to make such decisions on their own. -->\n\n\n<p>理想情况下，一旦某个模块被启动，它应该<strong>自动</strong>执行。模块是否在 DOM 就绪时运行，以及运行条件是否全部满足，决定这些并不是核心的任务，而是由架构中的模块指定决定。</p>\n\n<!-- You may be wondering in what circumstance a module might need to be 'stopped' - if the application detects that a particular module has failed or is experiencing significant errors, a decision can be made to prevent methods in that module from executing further so that it may be restarted. The goal here is to assist in reducing disruption to the user experience. -->\n\n\n<p>你可能想知道一个模块在什么情况下可能需要“停止”——如果应用程序侦测到某个特定模块出现故障或正处于严重的错误中，可以决定让这个模块中的方法停止继续执行，并且可能会重新启动它。这么做的目的是帮助降低对用户体验的破坏。</p>\n\n<!-- In addition, the core should enable **adding or removing** modules without breaking anything. A typical example of where this may be the case is functionality which may not be available on initial page load, but is dynamically loaded based on expressed user-intent eg. going back to our GMail example, Google could keep the chat widget collapsed by default and only dynamically load in the chat module(s) when a user expresses an interest in using that part of the application. From a performance optimization perspective, this may make sense. -->\n\n\n<p>此外，核心应该可以<strong>添加或移除</strong>模块而不破坏任何东西。一个典型的应用场景是，功能在页面初始化时尚不可用，而是基于用户的意图动态加载，例如，回到 GMail 的例子，Google 可以让聊天部件默认收起，只有在用户表现出使用它的兴趣时才会动态加载。从性能优化的角度看，这么做是有意义的。</p>\n\n<!-- Error management will also be handled by the application core. In addition to modules broadcasting messages of interest they will also broadcast any errors experienced which the core can then react to accordingly (eg. stopping modules, restarting them etc).It's important that as part of a decoupled architecture there to be enough scope for the introduction of new or better ways of handling or displaying errors to the end user without manually having to change each module. Using publish/subscribe through a mediator allows us to achieve this. -->\n\n\n<p>错误管理应该由应用程序的核心处理。模块除了广播感兴趣的事件外，也会广播发生的任何错误，然后核心可以做出相应的反馈（例如停止模块、重启模块等）。提供足够的上下文，以便用更新或更好的方式来处理或者向终端用户显示错误，而不必手动改变每个模块，是解耦架构中重要的一环。通过中介者使用发布/订阅机制，可以做到这一点。</p>\n\n<!-- ### Tying It All Together -->\n\n\n<h3>整合</h3>\n\n<!-- **Modules** contain specific pieces of functionality for your application. They publish notifications informing the application whenever something interesting happens - this is their primary concern. As I'll cover in the FAQs, modules can depend on DOM utility methods, but ideally shouldn't depend on any other modules in the system. They should not be concerned with: -->\n\n\n<p><strong>模块</strong> 为应用程序提供特定的功能。每当发生了感兴趣的事情，模块发布消息通知应用程序——这是它们的主要关注点。正如我在 FAQ（常见问题）中介绍的，模块可以依赖 DOM 工具方法，但是理想情况下不应该依赖系统的任何其他模块。它们不应该关注：</p>\n\n<!-- * what objects or modules are subscribing to the messages they publish\n* where these objects are based (whether this is on the client or server)\n* how many objects subscribe to notifications -->\n\n\n<ul>\n<li>什么对象或模块将订阅它们发布的消息</li>\n<li>这些对象在哪里（是否在客户端或服务端）</li>\n<li>有多少对象订阅了消息</li>\n</ul>\n\n\n<p><img src=\"http://addyosmani.com/largescalejavascript/assets/img/chart1a.gif\" alt=\"\" /></p>\n\n<!-- **The Facade** abstracts the core to avoid modules touching it directly. It subscribes to interesting events (from modules) and says 'Great! What happened? Give me the details!'. It also handles module security by checking to ensure the module broadcasting an event has the necessary permissions to pass such events that can be accepted. -->\n\n\n<p><strong>外观</strong> 抽象核心，用于避免模块直接接触核心。它订阅（从模块来的）感兴趣的事情，并且说“干得好！发生了什么事？把详细资料给我！”。它还负责检查模块的安全性，以确保发布消息的模块具备必要的权限来传递可接受的事件。</p>\n\n<p><img src=\"http://addyosmani.com/largescalejavascript/assets/img/chart2a.gif\" alt=\"\" /></p>\n\n<!-- **The Mediator (Application Core)** acts as a 'Pub/Sub' manager using the mediator pattern. It's responsible for module management and starts/stops modules as needed. This is of particular use for dynamic dependency loading and ensuring modules which fail can be centrally restarted as needed. -->\n\n\n<p><strong>中介者（应用程序的核心）</strong> 扮演“发布/订阅”管理者的角色。负责管理模块，在需要时启动或停止模块。特别适用于动态依赖加载，并确保失败的模块可以在需要时集中重启。</p>\n\n<p><img src=\"http://addyosmani.com/largescalejavascript/assets/img/chart3a.gif\" alt=\"\" /></p>\n\n<!-- The result of this architecture is that modules (in most cases) are theoretically no longer dependent on other modules. They can be easily tested and maintained on their own and because of the level of decoupling applied, modules can be picked up and dropped into a new page for use in another project without significant additional effort. They can also be dynamically added or removed without the application falling over. -->\n\n\n<p>如此架构的结果是模块（大多数情况下）在理论上不再依赖于其他模块。它们可以很容易地独立测试和维护，正因为这种程度的解耦，可以把模块放入一个新页面中供其他系统使用，而不需要做太多额外的工作。模块可以被动态地添加或移除，而不会导致应用程序崩溃。</p>\n\n<!-- ### Beyond Pub/Sub: Automatic Event Registration -->\n\n\n<h3>超越发布/订阅：自动注册事件</h3>\n\n<!-- As previously mentioned by Michael Mahemoff, when thinking about large-scale JavaScript, it can be of benefit to exploit some of the more dynamic features of the language. You can read more about some of the concerns highlighted on Michael's [G+](https://plus.google.com/106413090159067280619/posts/hDZkVrDXZR6) page, but I would like to focus on one specifically - automatic event registration (AER). -->\n\n\n<p>正如 Michael Mahemoff 在前面提到的，当考虑大型 JavaScript 时，适当利用这门语言的动态特性是有益的。关于详细内容请阅读 Michael 的 <a href=\"https://plus.google.com/106413090159067280619/posts/hDZkVrDXZR6\">G+</a> 页面，我特别关注其中一个概念——自动注册事件（AER Automatic Event Registration）。</p>\n\n<!-- TODO: 译注：前面是哪里？演讲吗？-->\n\n\n\n\n<!-- TODO: concerns highlighted 高亮？强调？-->\n\n\n\n\n<!-- AER solves the problem of wiring up subscribers to publishers by introducing a pattern which auto-wires based on naming conventions. For example, if a module publishes an event called `messageUpdate`, anything with a `messageUpdate` method would be automatically called. -->\n\n\n<p>AER 通过引入基于命名约定的自动连接模式，解决了订阅者到发布者的连接问题。例如，如果某个模块发布一个称为 <code>messageUpdate</code> 的事件，所有相关的 <code>messageUpdate</code> 方法将被自动调用。</p>\n\n<blockquote><p>译注：有点类似于 jQuery 事件系统的手动触发方法 .trigger()，即可以触发通过 jQuery 事件方法（.on()）绑定的事件，也可以触发行内事件（elem.click()）。</p></blockquote>\n\n<!-- The setup for this pattern involves registering all components which might subscribe to events, registering all events that may be subscribed to and finally for each subscription method in your component-set, binding the event to it. It's a very interesting approach which is related to the architecture presented in this post, but does come with some interesting challenges. -->\n\n\n<p>这种模式的结构涉及到：注册所有可能订阅事件的模块，注册所有可能被订阅的事件，最后为组件库中的每个订阅者注册方法。对于这篇文章所讨论的架构来说，这是一个非常有趣的方法，但也确实带来一些有趣的挑战。</p>\n\n<!-- For example, when working dynamically, objects may be required to register themselves upon creation. Please feel free to check out Michael's [post](http://softwareas.com/automagic-event-registration) on AER as he discusses how to handle such issues in more depth. -->\n\n\n<p>例如，当动态地执行时，对象可以被要求在创建时注册自身。请阅读 Michael 关于 AER 的<a href=\"http://softwareas.com/automagic-event-registration\">文章</a>，他更深入地讨论了如何处理这类问题。</p>\n\n<!-- ### Frequently Asked Questions -->\n\n\n<h3>常问问题</h3>\n\n<!-- #### Q: Is it possible to avoid implementing a sandbox or facade altogether? -->\n\n\n<h4>问：是否有可能避免必须实现一个沙箱或外观？</h4>\n\n<!-- A: Although the architecture outlined uses a facade to implement security features, it's entirely possible to get by using a mediator and pub/sub to communicate events of interest throughout the application without it. This lighter version would offer a similar level of decoupling, but ensure you're comfortable with modules directly touching the application core (mediator) if opting for this variation. -->\n\n\n<p>答：虽然前面介绍的架构使用了一个外观来来实现安全功能，但是如果不用外观，而是用一个中介者和发布/订阅机制来通信系统中感情兴趣的事件是也完全可行的。这个轻量级版本（后者）可以提供类似程度的解耦，但如果选择这么做，模块就可以随意地直接接触应用程序的核心（中介者）。</p>\n\n<!-- #### Q: You've mentioned modules not having any dependencies. Does this include dependencies such as third party libraries (eg. jQuery?) -->\n\n\n<h4>问：你提到了模块没有任何依赖。是否包括对第三方库的依赖（例如 jQuery）？</h4>\n\n<!-- A: I'm specifically referring to dependencies on other modules here. What some developers opting for an architecture such as this opt for is actually abstracting utilities common to DOM libraries -eg. one could have a DOM utility class for query selectors which when used returns the result of querying the DOM using jQuery (or, if you switched it out at a later point, Dojo). This way, although modules still query the DOM, they aren't directly using hardcoded functions from any particular library or toolkit. There's quite a lot of variation in how this might be achieved, but the takeaway is that ideally core modules shouldn't depend on other modules if opting for this architecture. -->\n\n\n<p>答：我特别指对其他模块的依赖。一些开发人员为架构做出的选择实际上等同于 DOM 库的的公用抽象——例如，可以一个构建 DOM 公用类，使用 jQuery 来查询选择起表达式并返回查找到的 DOM（或者 Dojo，如果将来切换了的话）。通过这种方式，尽管模块依然会查询 DOM，但不会以硬编码的方式直接使用任何特定的库或工具。有相当多的方式可以实现这一点，但要选择的话，它们的共同点是核心模块（理想情况下）不应该依赖其他模块。</p>\n\n<!-- TODO the takeaway is 共同点？-->\n\n\n\n\n<!-- You'll find that when this is the case it can sometimes be more easy to get a complete module from one project working in another with little extra effort. I should make it clear that I fully agree that it can sometimes be significantly more sensible for modules to extend or use other modules for part of their functionality, however bear in mind that this can in some cases increase the effort required to make such modules 'liftable' for other projects. -->\n\n\n<p>在这种情况下，你会发现，有时只需要一点额外的工作量，就可以让一个项目的完整模块运行在另一个项目中。我应该说清楚的是，我完全同意对模块进行扩展或者只使用模块的部分功能，而且有时可能是更明智的选择，但是记住，在某些情况下，想要把这样的模块应用到其他项目会增加工作量。</p>\n\n<!-- #### Q: I'd like to start using this architecture today. Is there any boilerplate code around I can work from? -->\n\n\n<h4>问：我想开始使用这种架构。是否有可供参考的样板代码？</h4>\n\n<!-- A: I plan on releasing a free boilerplate pack for this post when time permits, but at the moment, your best bet is probably the '[Writing Modular JavaScript](http://bit.ly/orGVOL)' premium tutorial by Andrew Burgees (for complete disclosure, this is a referral link as any credits received are re-invested into reviewing material before I recommend it to others). Andrew's pack includes a screencast and code and covers most of the main concepts outlined in this post but opts for calling the facade a 'sandbox', as per Zakas. There's some discussion regarding just how DOM library abstraction should be ideally implemented in such an architecture - similar to my answer for the second question, Andrew opts for some interesting patterns on generalizing query selectors so that at most, switching libraries is a change that can be made in a few short lines. I'm not saying this is the right or best way to go about this, but it's an approach I personally also use. -->\n\n\n<p>答：如果时间允许的话，我打算为这篇文章发布一个样板包，但目前你最好的选择是 Andrew Burgees 的超值教程 <a href=\"http://bit.ly/orGVOL\">Writing Modular JavaScript</a>（在推荐之前需要完全披露的是，这仅仅是一个推荐链接，收到的任何反馈都将有助于完善内容）。Andrew 的样板包包含一张屏幕截屏以及代码，覆盖了这篇文章的的大部分主要观点，但选择把外观称作“沙箱”，就像 Zakas。还有一些讨论是关于如何理想地在这样一个架构中实现 DOM 抽象库———类似于我对第二个问题的回答，Andrew 在实现选择器表达式查询时采用了一些有趣的模式，使得在大多数情况下，用短短几行代码就可以做到切换库。我并不是说它是正确的或最好的实现方式，但是它是一种可能，而且我个人也在使用它。</p>\n\n<!-- reviewing material 材料审核？bit.ly ？-->\n\n\n\n\n<!-- #### Q: If the modules need to directly communicate with the core, is this possible? -->\n\n\n<h4>问：如果模块需要直接与核心通信，这么做可能吗？</h4>\n\n<!-- A: As Zakas has previously hinted, there's technically no reason why modules shouldn't be able to access the core but this is more of a best practice than anything. If you want to strictly stick to this architecture you'll need to follow the rules defined or opt for a looser architecture as per the answer to the first question. -->\n\n\n<p>答：正如 Zakas 之前暗示的，为什么模块不应该访问核心在技术上没有理由，但这是最佳实现，比其他任何事情都重要。如果你想严格地坚持这种架构，你需要遵循定义的这些规则，或者选择一个更松散的结构，就像第一个问题的答案。</p>\n\n<!--### Credits\nThanks to Nicholas Zakas for his original work in bringing together many of the concepts presented today; Andrée Hansson for his kind offer to do a technical review of the post (as well as his feedback that helped improve it); Rebecca Murphey, Justin Meyer, John Hann, Peter Michaux, Paul Irish and Alex Sexton, all of whom have written material related to the topics discussed in the past and are a constant source of inspiration for both myself and others.-->\n\n\n\n\n<hr>\n\n\n<blockquote><p>原文：<a href=\"http://addyosmani.com/largescalejavascript/\">Patterns For Large-Scale JavaScript Application Architecture</a> by <a href=\"https://twitter.com/addyosmani\">@Addy Osmani</a></p></blockquote>\n\n<p><link href=\"/assets/codemirror/lib/codemirror.css\" rel=\"stylesheet\">\n<link href=\"/assets/codemirror/theme/neat.css\" rel=\"stylesheet\"></p>\n\n<script src=\"/assets/codemirror/lib/codemirror.js\"></script>\n\n\n<script src=\"/assets/codemirror/addon/runmode/runmode.js\"></script>\n\n\n<script src=\"/assets/codemirror/mode/javascript/javascript.js\"></script>\n\n\n<script type=\"text/javascript\">\n    $('pre').each(function(index, el){\n        $(this).hide()\n        var ctn = $('<pre class=\"cm-s-neat\">').insertAfter(this)\n        CodeMirror.runMode($(this).find('code').text(), 'javascript',\n                 ctn.get(0));\n    })\n</script>\n\n"
            ],
            "link": [
              "http://nuysoft.github.com/2013/08/13/large-scale-javascript"
            ],
            "guid": [
              "http://nuysoft.github.com/2013/08/13/large-scale-javascript"
            ],
            "pubDate": [
              "2013-08-13T00:00:00-07:00"
            ]
          },
          {
            "title": [
              "Javascript Promise"
            ],
            "description": [
              "<blockquote><p>原文：<a href=\"http://wildermuth.com/2013/8/3/JavaScript_Promises\">JavaScript Promises</a></p></blockquote>\n\n<p><img src=\"http://wildermuth.com/images/pinky-promise_2.jpg\" alt=\"\" /></p>\n\n<!-- No I am not talking the promise that JavaScript will fix everything if you use it. I don't even believe that ;) I am talking about the concept of a promise object that several JavaScript libraries use (including [AngularJS](http://angularjs.org/), [jQuery](http://jquery.com/), [Dojo](http://dojotoolkit.org/) and [WinJS](http://msdn.microsoft.com/en-us/library/windows/apps/br229773.aspx)). -->\n\n\n<p>哦不，我不是在谈论使用了 Promise 后，JavaScript 就可以解决所有问题，这点连我自己也不相信。我想谈论的是一些 JavaScript 库中用到的 Promise 概念，包括 <a href=\"http://angularjs.org/\">AngularJS</a>, <a href=\"http://jquery.com/\">jQuery</a>, <a href=\"http://dojotoolkit.org/\">Dojo</a> and <a href=\"http://msdn.microsoft.com/en-us/library/windows/apps/br229773.aspx\">WinJS</a>。</p>\n\n<!-- A promise is a pattern for handling asynchronous operations. The problem is that essentially when you start an asynchronous operation, you need to execute some code as the operation is completed. Asynchronous code is so common that most libraries have found a solution for passing in callbacks. But there is little commonality to how each libraries does this. Let's take jQuery as an example: -->\n\n\n<p>Promise 是一种异步操作模式。异步操作的基本问题在于，当你开始一个异步操作后，你需要在操作完成时执行一些代码。异步代码是如此的普遍，并且大多数库也已经找到了一个解决方案：传入回调函数。并且每个库的实现有着共通之处。让我们看一个 jQuery 示例：</p>\n\n<iframe style=\"width: 100%\" height=\"300\" src=\"http://jsfiddle.net/cuXqF/embedded/\" frameborder=\"0\" width=\"100%\" allowfullscreen=\"allowfullscreen\"></iframe>\n\n\n\n\n<!-- In this example you can see the jQuery uses the success property of the settings object to specify the callback. This isn't a promise but a way to pass in the callback functions. When the ajax call is complete, it calls the success function. Depending on the library that uses asynchronous operations, you might pass in a set of callbacks (e.g. for success or failure). There are a ton of ways to accomplish this. -->\n\n\n<p>在上面这个例子中，你可以看到 jQuery 使用配置对象的属性 success 来指定回调函数。这不是 Promise，仅仅是一种传递回调函数的方式。当 ajax 请求完成时，它会调用函数 success。根据库对异步操作的实现，你可以传入一组回调函数（例如 success 或 failure）。然而，事实上有很多种方式可以实现这一点。</p>\n\n<!-- The promise pattern sets out to simplify this process. The asynchronous operation simply returns an object called a promise. The promise allows you to call a method called **then** that let's you specify the function(s) to use as the callbacks. Let's see how to consume a promise using jQuery as an example: -->\n\n\n<p>异步模式可以简化这个过程。异步操作简单地返回一个 Promise 对象，Promise 对象允许你调用一个命名为 <strong>then</strong> 的方法，来指定一些函数作为回调函数。让我们看看在 jQuery 中如何使用 Promise 对象：</p>\n\n<iframe style=\"width: 100%\" height=\"300\" src=\"http://jsfiddle.net/FDg6d/embedded/\" frameborder=\"0\" width=\"100%\" allowfullscreen=\"allowfullscreen\"></iframe>\n\n\n\n\n<!-- What is interesting here, is that the object that **ajax** returns is the **xhr** object which implements the promise pattern so we can call **then** as seen here. The power of the call to then is that you can chain them by calling then for discrete operations and completing the operation with a call to done as shown here: -->\n\n\n<p>有趣的是，<strong>ajax</strong> 返回的是一个实现了 Promise 模式的 <strong>xhr</strong> 对象，所以我们可以调用 <strong>then</strong>，正如你所看到的。then 的魔力在于，你可以通过调用 then 把离散的操作串联起来，并且通过调用 done 来结束操作，就像下面这样：</p>\n\n<iframe style=\"width: 100%\" height=\"400\" src=\"http://jsfiddle.net/kWrpq/embedded/\" frameborder=\"0\" width=\"100%\" allowfullscreen=\"allowfullscreen\"></iframe>\n\n\n\n\n<!-- Because many libraries are starting to take on the promise pattern, handling asynchronous operations should be easier no matter what code you're writing (e.g. NodeJS, in-browser JS, etc.). But what does a promise look like from the other side? -->\n\n\n<p>由于许多库开始采用 Promise 模式，对异步操作的处理将更加容易，并且不需要考虑所写的是哪种代码（例如 NodeJS、浏览器 JS 等等）。但是，如果从其他角度来看待 Promise 会是什么样子呢？</p>\n\n<!-- One important key to the pattern is that the then function can accept two functions. The first is for the success callback; the second for the failure callback like so: -->\n\n\n<p>Promise 模式的一个重要关键是，方法 then 可以接受两个参数。第一个是 success 回调函数，第二个是 failure 回调函数，就像这样：</p>\n\n<iframe style=\"width: 100%\" height=\"400\" src=\"http://jsfiddle.net/SwzkK/embedded/\" frameborder=\"0\" width=\"100%\" allowfullscreen=\"allowfullscreen\"></iframe>\n\n\n\n\n<!-- Notice that in jQuery we're using a call to **always** to specify that we want to be called whether the success or failure was called. -->\n\n\n<p>请注意，在 jQuery 中，我们可以通过调用 <strong>always</strong> 来指定无论 success 或 failure 都会执行的回调函数。</p>\n\n<!-- Let's see how using a promise looks. Here is an example from AngularJS: -->\n\n\n<p>让我们看看如何使用一个 Promise 对象，下面是一个来自 AngularJS 的示例：</p>\n\n<iframe style=\"width: 100%\" height=\"700\" src=\"http://jsfiddle.net/s35B9/embedded/\" frameborder=\"0\" width=\"100%\" allowfullscreen=\"allowfullscreen\"></iframe>\n\n\n\n\n<!-- AngularJS uses an implementation (see the **$q** variable) that is started with a call to **defer()**.  This returns an object that contains ways to mark a successful or failure condition as well as the promise itself. Notice that in the **_callMe** function the **d** variable is created by calling **$q.defer()** then the **d.promise** is returned from the function so that the caller can call the promise methods (e.g. **then**). When the actual asynchronous operation is performed (in this case mocked up as a **setTimeout** call), we can use the **resolve** method on the defer'd object to tell the promise that we completed successfully (and therefore call the first function in the **then** method below). If we were to call **reject**, the second method (the failure call) would be called instead. -->\n\n\n<p>在 AngularJS 的实现（见变量 <strong>$q</strong>）中，首先要调用 <strong>defer()</strong>。返回的对象包含了标记成功或失败状态的方法，以及 promise。注意：在函数 <strong>_callMe</strong> 中，变量 <strong>d</strong> 通过调用 <strong>$q.defer()</strong> 创建，然后 <strong>d.promise</strong> 被返回，调用方可以继续调用 promise 方法（例如 <strong>then</strong>）。当实际的异步操作完成后（在这个例子中用 <strong>setTimeout</strong> 模拟），我们可以使用 d 的方法 <strong>resolve</strong> 来告诉 promise（调用传给方法 <strong>then</strong> 的第一个函数）。如果我们调用 <strong>reject</strong>，第二个（失败）函数将被调用。</p>\n\n<!-- You can play with these examples in JSFiddle and see what you can make happen. Promises are a really simple and cool way to handle asynchronicity. What I really like about it is that it simplifies your code (so that you don't have the triangle of doom when you have to nest callback functions inside each other. This makes it easy. -->\n\n\n<p>你可以在 JSFiddle 中试验这些例子，看看会发生什么。Promise 以相当简单和出色的方式来处理异步性。我真正喜欢的是它可以简化你的代码，当必须彼此嵌入回调函数时，不会再有末日般的恐怖轮回。Promise 使这一点变得很容易。</p>\n"
            ],
            "link": [
              "http://nuysoft.github.com/2013/08/12/javascript-promise"
            ],
            "guid": [
              "http://nuysoft.github.com/2013/08/12/javascript-promise"
            ],
            "pubDate": [
              "2013-08-12T00:00:00-07:00"
            ]
          },
          {
            "title": [
              "ECMAScript 6 and Proxy "
            ],
            "description": [
              "<blockquote><p>原文：<a href=\"http://ariya.ofilabs.com/2013/07/es6-and-proxy.html\">ECMAScript 6 and Proxy</a></p></blockquote>\n\n<!-- Being able to intercept a certain operation to an object can be really useful, in particular during a troubleshooting session. With ECMAScript 6, this is possible via its new feature, **proxy**. Creating a proxy on a particular object allows a predefined handler to get notified when something happens. -->\n\n\n<p>能够拦截对象的某项特定操作可能非常有用，特别是排除故障时。通过 ECMAScript 6 的新功能<strong>代理</strong>，拦截变得可行起来。通过在特定对象上创建一个代理，可以使得预定义的处理程序在某些操作发生时收到通知。</p>\n\n<!-- In the latest [draft specification](http://wiki.ecmascript.org/doku.php?id=harmony:specification_drafts) (Rev 15, May 14, 2013), section 15.18 on Proxy Objects is still empty. It is safe to assume that more information will be available later, when the specification starts to stabilize. Meanwhile, there is some useful information on the [Direct Proxies](http://wiki.ecmascript.org/doku.php?id=harmony:direct_proxies) wiki page. At the time of this writing, proxy support is already available on the latest stable version of Firefox and Chrome (experimental flag needs to be enabled). -->\n\n\n<p>在最新的<a href=\"http://wiki.ecmascript.org/doku.php?id=harmony:specification_drafts\">规范草案</a>（15版，2013年5月14日）中，第 15.18 节关于代理对象的内容仍然是空的。不过可以肯定的是，当规范趋于稳定时，将会有更多有用的信息。<a href=\"http://wiki.ecmascript.org/doku.php?id=harmony:direct_proxies\">直接代理</a>的维基页面提供了一些有用的信息。而且在本文写作之际，最新稳定版本的 Firefox 和 Chrome 已经提供了对代理的支持（需要启用实验性 JavaScript）。</p>\n\n<blockquote><p>译注：在 Chrome 中输入 <code>chrome://flags/#enable-javascript-harmony</code>，启用<code>实验性 JavaScript</code>。</p></blockquote>\n\n<!-- The best way to illustrate a proxy is by a simple example (**note:** the code fragment is updated to use the new syntax, `Proxy(target, handler)`, and not the deprecated `Proxy.create`): -->\n\n\n<p>阐明代理的最佳方式是通过一个简单的例子（<strong>注意：</strong>更新后的代码片段使用了新语法 <code>Proxy(target, handler)</code>，而不是弃用的 <code>Proxy.create</code>）:</p>\n\n<pre><code>var engineer = { name: 'Joe Sixpack', salary: 50 };\n\nvar interceptor = {\n  set: function (receiver, property, value) {\n    console.log(property, 'is changed to', value);\n    receiver[property] = value;\n  }\n};\n\nengineer = Proxy(engineer, interceptor);\n</code></pre>\n\n<!-- In the above code, we create a simple object `engineer`. This object will be replaced by another one as the result of installing a proxy via `Proxy()`. The second parameter for this function is denoting a handler, `interceptor` in our case. A handler can have many different functions, for this simple example we have only one, `set`. -->\n\n\n<p>在上面的代码中，我们创建了一个简单的对象 <code>engineer</code>。该对象将被替换为通过 <code>Proxy()</code> 创建的代理对象。函数的第二个参数表示一个拦截器，在这里是 <code>interceptor</code>。一个拦截器可以含有多个不同的函数，不过在这个简单的例子中只有一个 <code>set</code>。</p>\n\n<!-- Let’s see what happens if we executed the following code: -->\n\n\n<p>让我们来看看执行下面的代码会发生什么：</p>\n\n<pre><code>engineer.salary = 60;\n</code></pre>\n\n<!-- The handler will be called and its `set` function will be invoked. Thus, we will get: -->\n\n\n<p>拦截器将被触发，它的方法 <code>set</code> 将被调用。因此，我们将得到：</p>\n\n<pre><code>salary is changed to 60\n</code></pre>\n\n<!-- Every time a property of `engineer` is set, our interceptor will know about it. Obviously, there are various other operations which can be detected a proxy handler, such as property getter, `keys()`, iterator, and many others. Refer to the [Direct Proxies](http://wiki.ecmascript.org/doku.php?id=harmony:direct_proxies) wiki page for more details. **Note:** you might be also interested in [tvcutsem/harmony-reflect](https://github.com/tvcutsem/harmony-reflect) which contains the polyfills so that you can use the new Proxy API on top of the deprecated one. -->\n\n\n<p>每当 <code>engineer</code> 的某个属性被设置时，拦截器都会知道。而且显然拦截器还可以检测各种其他的操作，例如读取属性、<code>keys()</code>、迭代器等等。更多详情请参考<a href=\"http://wiki.ecmascript.org/doku.php?id=harmony:direct_proxies\">直接代理</a>的维基页面。<strong>注意：你也可能对 </strong><a href=\"https://github.com/tvcutsem/harmony-reflect\">tvcutsem/harmony-reflect</a> 提供的垫片感兴趣，它可以帮助你使用新的 Proxy API 来代替那些不推荐使用的 API。</p>\n\n<!-- Beside for debugging purposes, proxy can be helpful for libraries which implement *data binding*. Because a handler can be hooked to the data model, there is no need to use an alternative syntax (e.g. explicit `set` to change a value) or to continuously track the change (e.g. dirty state) to modify the model. -->\n\n\n<p>除了用于调试外，代理可以帮助库实现<em>数据绑定</em>。因为拦截器可以挂在数据模型上，没有必要再使用替代语法（例如明确调用 <code>set</code> 来更改属性值）或持续跟踪变化（例如脏数据检查）来修改数据模型。</p>\n\n<!-- How would you plan to use proxy? -->\n\n\n<p>你打算如何使用代理呢？</p>\n"
            ],
            "link": [
              "http://nuysoft.github.com/2013/08/11/es6-and-proxy"
            ],
            "guid": [
              "http://nuysoft.github.com/2013/08/11/es6-and-proxy"
            ],
            "pubDate": [
              "2013-08-11T00:00:00-07:00"
            ]
          },
          {
            "title": [
              "jQuery 浏览器功能测试"
            ],
            "description": [
              "<p><a href=\"/project/jQuery.support/report.html\">jQuery 浏览器功能测试</a></p>\n"
            ],
            "link": [
              "http://nuysoft.github.com/2013/07/09/jquerysupport"
            ],
            "guid": [
              "http://nuysoft.github.com/2013/07/09/jquerysupport"
            ],
            "pubDate": [
              "2013-07-09T00:00:00-07:00"
            ]
          },
          {
            "title": [
              "Mock.js"
            ],
            "description": [
              "<p><a href=\"http://mockjs.com/\">Mock.js</a></p>\n"
            ],
            "link": [
              "http://nuysoft.github.com/2013/04/25/mocking"
            ],
            "guid": [
              "http://nuysoft.github.com/2013/04/25/mocking"
            ],
            "pubDate": [
              "2013-04-25T00:00:00-07:00"
            ]
          },
          {
            "title": [
              "模块化 & 依赖管理 & 性能优化"
            ],
            "description": [
              "<blockquote><p>原文：<a href=\"http://www.elijahmanor.com/2013/04/angry-birds-of-javascript-yellow-bird.html\">Angry Birds of JavaScript: Yellow Bird RequireJS</a></p></blockquote>\n\n<!-- ## Introduction -->\n\n\n<h2>简介</h2>\n\n<p><img src=\"http://4.bp.blogspot.com/-6p5Xgjlsmhk/UVZlEo_QOKI/AAAAAAAAY9k/BBXhjrfp42U/s1600/Angry-Birds-Logo.png\" alt=\"\" /></p>\n\n<!-- ![](http://4.bp.blogspot.com/-6p5Xgjlsmhk/UVZlEo_QOKI/AAAAAAAAY9k/BBXhjrfp42U/s320/Angry-Birds-Logo.png) -->\n\n\n\n\n<!-- A diabolical herd of pigs stole all of the front-end architecture from an innocent flock of birds and now they want it back! A team of special agent hero birds will attack those despicable pigs until they recover what is rightfully theirs, front-end JavaScript architecture! -->\n\n\n<p>一群无法无天的猪从无辜的小鸟那里偷走了所有的前端架构，现在小鸟们要把它们夺回来！一队特殊的小鸟英雄将攻击这些卑鄙的猪，直到夺回原本属于它们的前端 JavaScript 架构！</p>\n\n<!-- Will the birds be successful in the end? Will they defeat their bacon flavored foe? Let's find out together in another nail biting episode of Angry Birds of JavaScript! -->\n\n\n<p>小鸟们最终会成功吗？它们会打败那些培根味儿的敌人吗？让我们一起揭示 JavaScript 之愤怒的小鸟系列的另一个扣人心弦的章节！</p>\n\n<blockquote><p>译注：翻译“bacon flavored foe”时，想起来了《少林足球》里的“做人如果没有梦想，那跟咸鱼有什么区别？”，就翻译成了“咸猪敌人”，<a href=\"http://nuysoft.com/2013/04/21/angry-birds-of-javascript-orange-bird-templating/#comment-881925473\">@sunnylost</a> 建议翻译为“培根味儿的敌人”，应该更准确和有趣些。</p></blockquote>\n\n<!-- > Check out the **[series introduction post](http://www.elijahmanor.com/2013/03/angry-birds-of-javascript-series.html)** for a list of all the birds and their attack powers. -->\n\n\n<blockquote><p>阅读<strong><a href=\"http://www.elijahmanor.com/2013/03/angry-birds-of-javascript-series.html\">系列介绍文章</a></strong>，查看所有小鸟以及它们的攻击力。</p></blockquote>\n\n<!-- ### Previous Attacks -->\n\n\n<h3>战报</h3>\n\n<ul>\n  <li>\n    <a href=\"http://www.elijahmanor.com/2013/03/angry-birds-of-javascript-red-bird.html\" target=\"_blank\">Red Bird - IIFE</a>\n  </li>\n  <li>\n    <a href=\"http://www.elijahmanor.com/2013/03/angry-birds-of-javascript-blue-bird.html\" target=\"_blank\">Blue Bird - Events</a>\n  </li>\n</ul>\n\n\n<br />\n\n\n\n\n<!-- ### Yellow Bird Attacks -->\n\n\n<h3>黄色小鸟的攻击</h3>\n\n<!-- ![](http://4.bp.blogspot.com/-eBq1DHq7P64/UVZlP7q4zMI/AAAAAAAAY9s/g5Ii1ZrLIbs/s1600/yellow-bird.png) -->\n\n\n<p><img src=\"http://4.bp.blogspot.com/-eBq1DHq7P64/UVZlP7q4zMI/AAAAAAAAY9s/g5Ii1ZrLIbs/s1600/yellow-bird.png\" alt=\"\" /></p>\n\n<!-- In this post we will take a look at the Yellow Bird who comes with a [RequireJS](http://requirejs.org/) speed booster and dynamically injects scripts against those pesky swine. Slowly, one by one, the birds will take back what it theirs to keep! -->\n\n\n<p>在这片文章中，我们将看看黄色小鸟，它用速度助推器 <a href=\"http://requirejs.org/\">RequireJS</a> 和动态注入脚本攻击那些讨厌的猪。渐渐地，小鸟们将一个接一个地夺回属于它们的东西！</p>\n\n<!-- ## What Was Stolen by the Pigs? -->\n\n\n<h2>猪偷走了什么？</h2>\n\n<!-- The birds used to manually add script tags to their HTML files. At first this wasn't an issue, but when their application started to grow larger and more complex it started to become difficult for them to organize their code, figure out dependencies, and determine a strategy for optimizing performance. Thankfully they were introduced to the [RequireJS](http://requirejs.org/) library which provided them a way to manage their code into modules, load their scripts asynchronously, manage their dependencies, and provide an easy way to optimize. Unfortunately the pigs, during a recent invasion, stole the RequireJS library from the birds. -->\n\n\n<p>小鸟们过去经常手动向 HTML 文件中添加 script 标签。起初这不是一个问题，但是当它们的应用开始变得更大更复杂时，组织代码、解决依赖关系和确定性能优化策略变得困难重重。值得庆幸的是，小鸟们引入了 <a href=\"http://requirejs.org/\">RequireJS</a> 库，这个库可以管理代码模块、异步加载脚本、管理依赖关系，并提供了一种简单的优化方式。不幸的是，在最近的一次入侵中，猪群从小鸟们那里偷走了 RequireJS 库。</p>\n\n<!-- One of the yellow birds has been tasked to reclaim what has been stolen. He will use the optimization power of speed to help destroy the pigs in order to take back what is theirs. -->\n\n\n<p>一只黄色小鸟被派去夺回被盗的 RequireJS 库。它将用加速度的力量摧毁猪群，夺回属于它们的东西。</p>\n\n<!-- ## Broken Application -->\n\n\n<h2>崩溃的应用</h2>\n\n<!-- Let's first start with a simple little web page that contains just a few scripts. You'll notice that I'm loading 3 popular libraries (jQuery, Underscore, and Postal) and some custom code at the end. -->\n\n\n<p>我们先从一个简单的小网页开始，其中包含了几个脚本文件。你会看到，我加载了 3 个常用库（jQuery、Underscore、Postal），并且在结尾处加载了一些自定义代码。</p>\n\n<p>  <script src=\"https://gist.github.com/elijahmanor/5275285.js?file=broken-dependency.html\">\n  </script></p>\n\n<!-- The above code looks pretty straightforward, but when I end up running the page I get the following error in the dev tool's console... -->\n\n\n<p>上面的代码看起来相当简单，但当我运行这个网页时，开发工具的控制台打印了下面的错误...</p>\n\n<!-- ![](http://1.bp.blogspot.com/-ry8ojeQF3OI/UVZosPNPtVI/AAAAAAAAY94/0Catr-PQzbo/s1600/3-29-2013+10-36-11+PM.png) -->\n\n\n<p><img src=\"http://1.bp.blogspot.com/-ry8ojeQF3OI/UVZosPNPtVI/AAAAAAAAY94/0Catr-PQzbo/s1600/3-29-2013+10-36-11+PM.png\" alt=\"\" /></p>\n\n<!-- Fictitious Internal Dialog: \"WHAT!?! I don't see any `each` method anywhere. What's up with that? Ohh man, it looks like the exception occurred in postal.min.js somewhere. FOUND A BUG... see if I use that library again. But, wait!?! Ohh, maybe something else is going on here.\" -->\n\n\n<p>内心对白：“什么！？！我没有在任何地方看到 <code>each</code> 方法。这到底是怎么回事？哦，天啊，看起来像是在 postal.min.js 的某处发生的异常。发现了一个 BUG... 但是等等！？！哦，这里面可能还有别的东西。”</p>\n\n<!-- So, the real issue isn't a bug in postal.js, the issue is in that postal.js has a dependency on underscore.js. The problem is that underscore should have been loaded before postal.js. Simply rearranging the script tags could easily solve this issue. In the above case the fix was trivial, but imagine how cumbersome this could be once the project starts to get large and requires lots of scripts. -->\n\n\n<p>好吧，真正的问题并不是 postal.js 的 bug，而是 postal.js 依赖于 underscore.js。而 underscore.js 应该在 postal.js 之前就被加载。通过简单的重新排列 script 标签就能很容易地解决这个问题。在上述情况下的修复显然微不足道，但是想像一下，一旦项目开始变大，并且需要大量的脚本时，修复工作会变得多么繁重。</p>\n\n<!-- ## RequireJS Basics -->\n\n\n<h2>RequireJS 基础</h2>\n\n<!-- Before we go and look at how we could fix the above situation using RequireJS, let's first take a high level overview of what the library is doing for us. RequireJS is an Asynchronous Module Loader and the API it provides allows us to define and require modules. Both functions are really easy to understand so let's take a look at them. -->\n\n\n<p>在开始看如何用 RequireJS 解决上述情况之前，让我们先来高度概括一下这个库能为我们做些什么。RequireJS 时一个异步模块加载器，提供的 API 允许我们定义和请求模块。这两个功能都很好理解，所以我们看看它们。</p>\n\n<!-- ### define method -->\n\n\n<h3>定义方法</h3>\n\n<!-- In order to create a module you need a name, a list of dependencies, and a callback function. -->\n\n\n<p>创建一个模块需要一个名字、一个依赖关系列表和一个回调函数。</p>\n\n<p>  <script src=\"https://gist.github.com/elijahmanor/5275285.js?file=define.js\">\n  </script></p>\n\n<!-- ### require method -->\n\n\n<h3>请求方法</h3>\n\n<!-- At some point in your application you will need to use the `require` function to kick things off. -->\n\n\n<p>在应用的某些地方，你需要使用 <code>require</code> 函数来开始执行代码。</p>\n\n<p>  <script src=\"https://gist.github.com/elijahmanor/5275285.js?file=require.js\">\n  </script></p>\n\n<!-- ## Fixed Application -->\n\n\n<h2>修正后的应用</h2>\n\n<!-- Using RequireJS I took the above little application and rearranged some things. You should notice that the following markup removes all the script tags except one, which points to the require.js library. RequireJS knows where to start because we add an HTML5 data-main attribute describing where the main script is located. -->\n\n\n<p>我用 RequireJS 重新调整了上面的小应用。你应该注意到，下面的代码移除了所有 script 标签，除了指向 require.js 库的标签。RequireJS 知道从哪里开始执行，因为我们添加了一个 HTML5 属性 data-main，它描述了主脚本的位置。</p>\n\n<p>  <script src=\"https://gist.github.com/elijahmanor/5275285.js?file=requirejs.html\">\n  </script></p>\n\n<!-- The main script has a configuration section inside of it where you can assign aliases to existing AMD modules and also shim libraries that were not previously defined. Although jQuery and Postal define themselves as AMD modules we included them in our configuration because they are not located alongside `main.js`. -->\n\n\n<p>主脚本有一段配置部分，可以在其中为现有的 AMD 模块指定别名，也可以为未预定义的库应用垫片。尽管 jQuery 和 Postal 定义自身为 AMD 模块，我们仍然要在配置中包含它们，因为它们没有被放在 <code>main.js</code> 的旁边。</p>\n\n<!-- You don't have to include in your config any custom modules you define in your application. You can refer to those by their file path and name. -->\n\n\n<p>你不必在配置中包含应用程序中的所有自定义模块。你可以通过文件路径和名称引用它们。</p>\n\n<p>  <script src=\"https://gist.github.com/elijahmanor/5275285.js?file=main.js\">\n  </script></p>\n\n<!-- ## Optimize -->\n\n\n<h2>优化</h2>\n\n<!-- Our application only has 5 script files in it, but as you know our app will only continue to add additional scripts. So, it would be nice if there was an easy way to combine and minify our scripts for better production performance. The nice thing is that by using RequireJS we have already defined the dependencies of our application. -->\n\n\n<p>我们的应用只包含了 5 个脚本文件，但你也知道，我们的应用只会持续添加额外的脚本。所以，理想的做法是用一种简单的方式将脚本合并和压缩，从而达到更好的生产性能。通过使用 RequireJS 定义应用的依赖关系可以实现这一目标。</p>\n\n<!-- Thankfully there is a tool called `[r.js](http://requirejs.org/docs/1.0/docs/optimization.html)` that takes this dependency information and uses it to generate a combined and minified script. You can install the tool with the Node Package Manager `npm install requirejs` -->\n\n\n<p>值得庆幸的是，有一个称为 <a href=\"http://requirejs.org/docs/1.0/docs/optimization.html\">r.js</a> 的工具可以收集依赖信息，并用这些信息生成一个合并和压缩过的脚本文件。你可以通过 Node 包管理器 <code>npm install requirejs</code> 安装这个工具。</p>\n\n<!-- You could provide all the command line argument to the tool in the console, but I prefer making a build config file like the following to define all of its settings before I run it. You can find a [comprehensive list of settings](https://github.com/jrburke/r.js/blob/master/build/example.build.js) from the official GitHub repository. -->\n\n\n<p>你可以在控制台中把命令行参数都传给这个工具，但我更喜欢在运行这个工具之前先创建一个构建配置文件，来定义所以的选项，就像下面的示例。你可以在官方 GitHub 库中找到<a href=\"https://github.com/jrburke/r.js/blob/master/build/example.build.js\">完整的选项列表</a>。</p>\n\n<p>  <script src=\"https://gist.github.com/elijahmanor/5275285.js?file=build.js\">\n  </script></p>\n\n<!-- Once you've defined your `build.js` file then you let `r.js` know you want to use it. The following command will get you going... `r.js -o build.js`. You can see the output of the tool in the output below. -->\n\n\n<p>定义 <code>build.js</code> 文件之后，你可以把这个文件作为参数传给 <code>r.js</code>。运行这条命令 <code>r.js -o build.js</code>，你可以在控制台看到这个工具的输出，就像下面这样。</p>\n\n<p>  <script src=\"https://gist.github.com/elijahmanor/5275285.js?file=optimize.sh\">\n  </script></p>\n\n<!-- ## Additional Resources -->\n\n\n<h2>其他资源</h2>\n\n<!-- I only scratched the surface on all the things you can do with RequireJS and the r.js optimization tool. If you are interesting in learning more about these concepts you may want to look at some of the following resources.  -->\n\n\n<p>关于 RequireJS 和优化工具 r.js 所能的所有事情，我仅仅触及到了皮毛。如果你有兴趣了解关于这些概念的更多信息，你可能想看看下面这些资源。</p>\n\n<ul>\n  <li>\n    Jack Franklin's (<a href=\"http://twitter.com/jack_franklin\" target=\"_blank\">@jack_franklin</a>)\n    <a href=\"http://javascriptplayground.com/blog/2012/07/requirejs-amd-tutorial-introduction\">Introduction to RequireJS</a> article\n  </li>\n  <li>\n    Jeffrey Way's (<a href=\"http://twitter.com/jeffrey_way\" target=\"_blank\">@jeffrey_way</a>)\n    <a href=\"http://net.tutsplus.com/tutorials/javascript-ajax/a-requirejs-backbone-and-bower-starter-template/\" target=\"_blank\">A RequireJS, Backbone, and Bower Starter Template</a> screencast\n  </li>\n  <li>\n    Cary Landholt's (<a href=\"http://twitter.com/carylandholt\" target=\"_blank\">@carylandholt</a>)\n    <a href=\"http://www.youtube.com/watch?v=VGlDR1QiV3A\">RequireJS Basics</a> video\n  </li>\n  <li>\n    Jonathan Creamer's (<a href=\"http://twitter.com/jcreamer898\" target=\"_blank\">@jcreamer898</a>)\n    <a href=\"http://tech.pro/tutorial/1156/using-requirejs-in-an-aspnet-mvc-application\" target=\"_blank\">Using Require.js in an ASP.NET MVC application</a> article\n  </li>\n</ul>\n\n\n\n\n<!-- ## Attack! -->\n\n\n<h2>攻击！</h2>\n\n<p>下面是一个用 <a href=\"http://incompl.github.com/boxbox/\">boxbox</a> 构建的简版 Angry Birds，boxbox 是一个用于 <a href=\"https://code.google.com/p/box2dweb/\">box2dweb</a> 的框架，由 <a href=\"http://bocoup.com\">Bocoup</a> 的 <a href=\"http://twitter.com/_gsmith\">Greg Smith</a> 编写。</p>\n\n<!-- > Press the `space bar` to launch the Yellow Bird and you can also use the arrow keys. -->\n\n\n<blockquote><p>按下<code>空格键</code>来发射黄色小鸟，你也可以使用方向键。</p></blockquote>\n\n<p><a href=\"http://jsfiddle.net/Gue8x/show\"><img src=\"http://1.bp.blogspot.com/-BvvbLg5ACrI/UVZoyYxCmSI/AAAAAAAAY-E/G7I6uezUKV0/s1600/3-29-2013+11-19-41+PM.png\" alt=\"\" /></a></p>\n\n<!-- ## Conclusion -->\n\n\n<h2>结论</h2>\n\n<!-- Front-end web applications can get complicated quickly. It is nice to have a way to provide some structure, dependency management, and an easy way to optimize the final result. Thanks to the power of Yellow the birds have regained their trusty RequireJS tool for use in their next application. -->\n\n\n<p>Web 前端应用可以快速变得相当复杂。理想的做法是提供某种结构和依赖关系管理，以及用一种简单的方式优化最终结果。由于黄色小鸟的努力，小鸟们已经夺回了值得信赖的 RequireJS 工具，并会在它们的下一个应用程序中使用它。</p>\n\n<!-- There are many other front-end architecture techniques that have been stolen by the pigs. Tune in next time as the next Angry Bird takes its revenge! Dun, dun, daaaaaaa! -->\n\n\n<p>还有许多其他的前端架构技术被猪群偷走了。在下篇文章中，另一只愤怒的小鸟将继续复仇！Dun, dun, daaaaaaa!</p>\n\n<blockquote><p><a href=\"http://nuysoft.com/2013/04/21/angry-birds-of-javascript-orange-bird-templating/#comment-881925473\">@sunnylost</a> 补充：Dun, dun, daaaaaaaaaa! 应该是在模拟背景音乐，类似于这种 <a href=\"http://missingno.ocremix.org/musicpages/game_on.html\">http://missingno.ocremix.org/musicpages/game_on.html</a></p></blockquote>\n"
            ],
            "link": [
              "http://nuysoft.github.com/2013/04/21/angry-birds-of-javascript-yellow-bird-requirejs"
            ],
            "guid": [
              "http://nuysoft.github.com/2013/04/21/angry-birds-of-javascript-yellow-bird-requirejs"
            ],
            "pubDate": [
              "2013-04-21T00:00:00-07:00"
            ]
          },
          {
            "title": [
              "模板 - 分离展现和逻辑"
            ],
            "description": [
              "<blockquote><p>原文：<a href=\"http://www.elijahmanor.com/2013/04/angry-birds-of-javascript-orange-bird.html\">Angry Birds of JavaScript: Orange Bird - Templating</a></p></blockquote>\n\n<!-- ## Introduction -->\n\n\n<h2>简介</h2>\n\n<p><img src=\"http://1.bp.blogspot.com/-EoYTO-3jfeY/UV-WOmhaF3I/AAAAAAAAZ0g/S1oYMzsOg2w/s1600/angrybirds_620_121112.jpg\" alt=\"\" /></p>\n\n<!-- ![](http://1.bp.blogspot.com/-EoYTO-3jfeY/UV-WOmhaF3I/AAAAAAAAZ0g/S1oYMzsOg2w/s320/angrybirds_620_121112.jpg) -->\n\n\n\n\n<!-- A diabolical herd of pigs stole all of the front-end architecture from an innocent flock of birds and now they want it back! A team of special agent hero birds will attack those despicable pigs until they recover what is rightfully theirs, front-end JavaScript architecture! -->\n\n\n<p>一群无法无天的猪从无辜的小鸟那里偷走了所有的前端架构，现在小鸟们要把它们夺回来！一队特殊的小鸟英雄将攻击这些卑鄙的猪，直到夺回原本属于它们的前端 JavaScript 架构！</p>\n\n<!-- Will the birds be successful in the end? Will they defeat their bacon flavored foe? Let's find out together in another nail biting episode of Angry Birds of JavaScript! -->\n\n\n<p>小鸟们最终会成功吗？它们会打败那些培根味儿的敌人吗？让我们一起揭示 JavaScript 之愤怒的小鸟系列的另一个扣人心弦的章节！</p>\n\n<blockquote><p>译注：翻译“bacon flavored foe”时，想起来了《少林足球》里的“做人如果没有梦想，那跟咸鱼有什么区别？”，就翻译成了“咸猪敌人”，<a href=\"http://nuysoft.com/2013/04/21/angry-birds-of-javascript-orange-bird-templating/#comment-881925473\">@sunnylost</a> 建议翻译为“培根味儿的敌人”，应该更准确和有趣些。</p></blockquote>\n\n<!-- > Check out the **[series introduction post](http://www.elijahmanor.com/2013/03/angry-birds-of-javascript-series.html)** for a list of all the birds and their attack powers. -->\n\n\n<blockquote><p>阅读<strong><a href=\"http://www.elijahmanor.com/2013/03/angry-birds-of-javascript-series.html\">系列介绍文章</a></strong>，查看所有小鸟以及它们的攻击力。</p></blockquote>\n\n<p><img src=\"http://4.bp.blogspot.com/-MsnBfq6yXiQ/UV-aF4EH1EI/AAAAAAAAZ0o/bUCCPM5vfUQ/s1600/Orange_bird_space.png\" alt=\"\" /></p>\n\n<!-- ![](http://4.bp.blogspot.com/-MsnBfq6yXiQ/UV-aF4EH1EI/AAAAAAAAZ0o/bUCCPM5vfUQ/s1600/Orange_bird_space.png) -->\n\n\n\n\n<!-- ### Previous Attacks -->\n\n\n<h3>战报</h3>\n\n<!-- TODO -->\n\n\n<ul>\n  <li>\n    <a href=\"http://www.elijahmanor.com/2013/03/angry-birds-of-javascript-red-bird.html\" target=\"_blank\">\n      Red Bird - IIFE\n    </a>\n  </li>\n  <li>\n    <a href=\"http://www.elijahmanor.com/2013/03/angry-birds-of-javascript-blue-bird.html\" target=\"_blank\">\n      Blue Bird - Events\n    </a>\n  </li>\n  <li>\n    <a href=\"http://www.elijahmanor.com/2013/04/angry-birds-of-javascript-yellow-bird.html\" target=\"_blank\">\n      Yellow Bird - RequireJS\n    </a>\n  </li>\n  <li>\n    <a href=\"http://www.elijahmanor.com/2013/04/angry-birds-of-javascript-black-bird.html\" target=\"_blank\">\n      Black Bird - Backbone\n    </a>\n  </li>\n  <li>\n    <a href=\"http://www.elijahmanor.com/2013/04/angry-birds-of-javascript-white-bird.html\" target=\"_blank\">\n      White Bird - Linting\n    </a>\n  </li>\n  <li>\n    <a href=\"http://www.elijahmanor.com/2013/04/angry-birds-of-javascript-green-bird.html\" target=\"_blank\">\n      Green Bird - Mocking\n    </a>\n  </li>\n</ul>\n\n\n\n\n<!-- ### Orange Bird Attacks -->\n\n\n<h3>橙色小鸟的攻击</h3>\n\n<!-- In this post we will take a look at the Orange Bird. He first starts out small with a simple template, but then expands itself into a DOM blast that will surely send the message that the birds mean business. Slowly, one by one, the birds will take back what it theirs to keep! -->\n\n\n<p>在这篇文章中，我们将看看橙色小鸟。他开始时是一个简单的小模板，但随之扩大为一场 DOM 爆炸，这么做明确的传达了一个消息，那就是小鸟们是认真的。渐渐的，小鸟们将一个接一个地夺回属于它们的东西。</p>\n\n<!-- ## What Was Stolen by the Pigs? -->\n\n\n<h2>猪偷走了什么？</h2>\n\n<!-- For the last several years we have seen a trend that more and more work is being done on the front-end of web development. We communicate to the back-end via Ajax or Web Sockets and then display the data somehow in the UI. The birds found themselves mostly using string concatenation to build up the rich user interfaces, which resulted in a lot of code that was boring and also prone for errors. Thankfully an Orange Bird came along and said, \"Hey, isn't there something better than this? Can't we separate our view from our data somehow?\", and that is how templates became to be in the bird world. The Orange Bird borrowed templating libraries from the humans such as Underscore.js and [Handlebar.js](http://handlebarsjs.com/) to help fit this need among the foul. -->\n\n\n<p>在过去的几年里，我们已经看到一个趋势：越来越多的 Web 开发工作在前端完成。我们通过 Ajax 或 Web Sockets 与后端通信，然后在以某种方式在 UI 中显示数据。小鸟们发现它们主要使用字符串拼接来构建富用户界面，从而导致大量让人讨厌的代码，并且容易出现错误。庆幸的是，一只橙色小鸟站了出来，它说，“有没有比这更好的方式？我们不能通过某种方式把展示从数据中分离出来吗？”，就这样，模板进入了小鸟的世界。橙色小鸟通过借用人类的模板库，例如 Underscore.js 和 <a href=\"http://handlebarsjs.com/\">Handlebar.js</a> 来满足这种需求。</p>\n\n<!-- However, during a recent invasion the pigs stole the birds' templating libraries! As a result, one of the Orange Birds has been tasked to reclaim what has been stolen. He will use his exploding power to help destroy the pigs in order to take back what is theirs. -->\n\n\n<p>然而，在最近的一次入侵中，猪群偷走了小鸟们的模板库！现在，一只橙色小鸟被派去夺回失窃的模板库。它将用爆炸性的力量摧毁猪群，夺回属于它们的东西。</p>\n\n<!-- ## Why Use a Templating Engine? -->\n\n\n<h2>为什么要使用模板引擎？</h2>\n\n<!-- Before we get into what templating engines I recommend let's first look into why we might need one in the first place. The more I develop I try to find ways to separate the various parts of my application. I start to feel dirty when too much stuff is going on in the same place. Take a look at the following piece of code and tell me how you feel... -->\n\n\n<p>在开始模板引擎之前，我建议先看看为什么需要模板引擎。我开发的越多，就越想试图找到将应用的各个部分分开的方式。当太多的东西在同一个地方运行中，我开始觉得恶心。看看下面这段代码，然后告诉我你的感受...</p>\n\n<p>  <script src=\"https://gist.github.com/elijahmanor/5324961.js?file=before.js\">\n  </script></p>\n\n<!-- Yeah, I don't like all of the string concatenation either. I prefer not to have a bunch of presentation inside of my code if I can help it. On the plus side, it does work. You can see the output of the code in the following embedded jsFiddle. -->\n\n\n<p>是的，我不喜欢所有的字符串拼接。如果可能的话，我不希望在我的代码里出现一堆展现。唯一好的一面是它可以工作。你可以在下面的内嵌 jsFiddle 中看到这段代码的输出。</p>\n\n<p>  <iframe allowfullscreen=\"allowfullscreen\" frameborder=\"0\" height=\"200\" src=\"http://jsfiddle.net/B4fJB/embedded/result,js,html\" width=\"100%\">\n  </iframe></p>\n\n<!-- So, what can we do instead? This is where some type of templating engine can help us simplify our code and separate our markup from our code. -->\n\n\n<p>那么，我们能做些什么呢？某些类型的模板引擎对此能有所帮助，它们可以帮助我们简化代码，并从代码中分离标记。</p>\n\n<h2>Underscore.js</h2>\n\n<!-- ![](http://1.bp.blogspot.com/-t24RSU2yVNo/UWBpxcuBmUI/AAAAAAAAZ1I/1GQ-k_JuODA/s1600/underscore.png) -->\n\n\n<p><img src=\"http://1.bp.blogspot.com/-t24RSU2yVNo/UWBpxcuBmUI/AAAAAAAAZ1I/1GQ-k_JuODA/s320/underscore.png\" alt=\"\" /></p>\n\n<!-- We will first look at the template method in the Underscore.js library. I tend to use Underscore in all of my projects these days so I already have the power of its templating engine loaded. If what I am doing is pretty simple, then I mostly default to use Underscore for templating. However, as you'll see there are some limitations which make the next library we will look at much more appealing. -->\n\n\n<p>我们首先看看 Underscore.js 中的模板方法。目前我倾向于我的所有项目中使用 Underscore，所以我已经掌握了它的模板引擎。如果我正在做的事情很简单，那么通常我会默认使用 Underscore 的模板引擎。然而，你会看到它有一些局限性，使得我们看的下一个库更吸引人。</p>\n\n<!-- ### Take 1 -->\n\n\n<h3>示例1</h3>\n\n<!-- The following is the above code rewritten using Underscore's template. You'll notice that the code piece has been greatly simplified! Whoo hooo!-->\n\n\n<p>下面是将上面的代码用 Underscore 的模板重写后的代码。你会注意到代码块已经大大简化。Whoo hooo！</p>\n\n<p>  <script src=\"https://gist.github.com/elijahmanor/5324961.js?file=underscore-before.js\">\n  </script></p>\n\n<!-- ![](http://3.bp.blogspot.com/-3Kf0njai3FE/UWQqiAbjkII/AAAAAAAAZ5I/uqisM5XsOCQ/s1600/Inflated_orange_bird_sprite.png) -->\n\n\n<p><img src=\"http://3.bp.blogspot.com/-3Kf0njai3FE/UWQqiAbjkII/AAAAAAAAZ5I/uqisM5XsOCQ/s200/Inflated_orange_bird_sprite.png\" alt=\"\" /></p>\n\n<!-- The bulk of the work is being done by the template to explode it into a bunch of markup! As you can see to the left our orange bird looks quite different now lolz ;) -->\n\n\n<p>大部分工作由模板完成，模板则爆裂成一堆标记！正如你在左侧看到的，我们的橙色小鸟现在看起来完全不同了 ;)</p>\n\n<!-- We moved the layout into a `script` tag in our markup and gave it an identifier. The template has special markers `&lt;%= expression %&gt;` to denote where it should evaluate data passed to it. You can also use the `&lt;% statements %&gt;` symbols to put whatever JavaScript you want in there (think loops, branching, etc...)! -->\n\n\n<p>我们将布局移动到标记中的一个 <code>script</code> 标签中，并赋予它一个唯一标识。模板中的特殊标记 <code>&lt;%= expression &gt;</code> 表示传入数据的展现位置。你也可以用 <code>&lt;% statements &gt;</code> 语法放置任意 JavaScript（例如循环、分支等）！</p>\n\n<p>  <script src=\"https://gist.github.com/elijahmanor/5324961.js?file=underscore-before.html\">\n  </script></p>\n\n<!-- ![](http://3.bp.blogspot.com/-g0AGryuJAFE/UWB-rxhthnI/AAAAAAAAZ1g/o57Bn_sUSx8/s1600/with_great_power_comes_great_responsibility_by_itomibhaa-d4lajvl.png) -->\n\n\n<p><img src=\"http://3.bp.blogspot.com/-g0AGryuJAFE/UWB-rxhthnI/AAAAAAAAZ1g/o57Bn_sUSx8/s320/with_great_power_comes_great_responsibility_by_itomibhaa-d4lajvl.png\" alt=\"\" /></p>\n\n<!-- You can play around with the above code snippets in [jsFiddle](http://jsfiddle.net/wkH3k/). -->\n\n\n<p>你可以在 <a href=\"http://jsfiddle.net/wkH3k/\">jsFiddle</a> 中试验上面的代码片段。</p>\n\n<!-- As Uncle Ben said, \"With great power, comes great responsibility.\" -->\n\n\n<p>正如 Uncle Ben 所说，“能力越大，责任就越大。”</p>\n\n<!-- Being able to put whatever code you want in your template isn't the best idea in the world. By putting the date manipulation logic in the template it makes it really tough to Unit Test that piece of code. Just imagine if we started cluttering our template with more and more code blocks that like. If you go this route, then you aren't really solving the original problem at hand which was combining presentation and logic.  -->\n\n\n<p>允许在模板中放置任意代码终究不是最好的注意。在模板中放置数据操作逻辑会导致单元测试非常难以进行。试想一下，如果我们开始用越来越多的代码块把模板搞的凌乱不堪，情况会怎么样。如果你选择了这条路，那么你并没有真正解决最初的手头问题，即展示和逻辑混在一些。</p>\n\n<!-- ### Take 2 -->\n\n\n<h3>示例2</h3>\n\n<!-- The following is another take at using Underscore, but this time doing the data manipulation before. The downside is that I'm using the `_.map()` method and converting each date property to the relative version. There is some overhead in me having to loop over the data before handing it off to the templating engine. -->\n\n\n<p>下面是使用 Underscore 的另一个示例，但是这次是先做数据操作。在下面代码中，我用 <code>_.map()</code> 方法把每个 date 属性转换为合适的版本。在把数据传给模板之前遍历数据会导致一些性能开销。</p>\n\n<p>  <script src=\"https://gist.github.com/elijahmanor/5324961.js?file=underscore-after.js\">\n  </script></p>\n\n<!-- We were able to remove the date logic in the following template since we did that work above in the JavaScript before calling the template to do its work. The result is better than what we started with, but it could be better.  -->\n\n\n<p>我们可以移除下面模板中的数据逻辑，因为在调用模板之前，我们已经的在上面的 JavaScript 中完成了这项工作。结果比最初的版本要好，但还可以更好。</p>\n\n<p>  <script src=\"https://gist.github.com/elijahmanor/5324961.js?file=underscore-after.html\">\n  </script></p>\n\n<!-- You can play around with the above code snippets in [jsFiddle](http://jsfiddle.net/auBUX/). -->\n\n\n<p>你可以在 <a href=\"http://jsfiddle.net/wkH3k/\">jsFiddle</a> 中试验上面的代码片段。</p>\n\n<!-- ### Why use Underscore.js? -->\n\n\n<h3>为什么使用 Underscore.js？</h3>\n\n<!-- #### Pros -->\n\n\n<h4>赞成</h4>\n\n<!-- \nYou can stick arbitrary JavaScript in the template\nIt is very small\nIf you are already using Backbone.js then you have it\nIf you are already using Underscore.js then you have it\nYou can Compile the Templates\nCan Run on the Client and the Server\nCan you think of others? \n-->\n\n\n<ul>\n<li>你可以在模板中使用任意 JavaScript</li>\n<li>非常小</li>\n<li>如果你已经在使用 Backbone.js，那么可以直接使用它。</li>\n<li>如果你已经在使用 Underscore.js，那么可以直接使用它。</li>\n<li>你可以预编译</li>\n<li>可以同时运行在客户端和服务端</li>\n<li>你能想到其他的吗？</li>\n</ul>\n\n\n<!-- #### Cons -->\n\n\n<h4>反对</h4>\n\n<!-- \nYou can stick arbitrary JavaScript in the template\nDoesn't have the concept of `this` in templates\nCan you think of others?\n-->\n\n\n<ul>\n<li>你可以在模板中使用任意 JavaScript</li>\n<li>模板中没有 `this` 的概念</li>\n<li>你能想到其他的吗？</li>\n</ul>\n\n\n<h2>Handlebars.js</h2>\n\n<!-- ![](http://1.bp.blogspot.com/-ads8NbsvuFk/UWBqEezk1kI/AAAAAAAAZ1Q/N-LZmHnRDzM/s1600/handlebars_logo.png) -->\n\n\n<p><img src=\"http://1.bp.blogspot.com/-ads8NbsvuFk/UWBqEezk1kI/AAAAAAAAZ1Q/N-LZmHnRDzM/s320/handlebars_logo.png\" alt=\"\" /></p>\n\n<!-- Overall I tend to prefer the Handlebar.js over Underscore's template engine. Handlebars encourages you to separate your presenting from your logic, it is faster, and it provides a mechanism to precompile your templates that we will look at here in a bit. -->\n\n\n<p>总体而言，我倾向于选择 Handlebar.js 而不是 Underscore 的模板引擎。Handlebars 鼓励你分离展现和逻辑，并且速度更快，并且提供了一种预编译模板的机制，我们将对此做稍微深入的研究。</p>\n\n<!-- First let's take another look at the problem we have been addressing throughout this post. The following code uses Handlebars to template the solution. The code is still pretty clean as was the previous version. You'll notice that I am defining a custom helper called `fromNow` that can be used in the template. -->\n\n\n<p>首先，让我们换个角度看看这篇文章想解决的问题。下面的代码用 Handlebars 来模版化解决方案。这段和之前的版本一样干净。你会注意到，我自定义了一个称为 <code>fromNow</code> 的 helper，可以用在模板中。</p>\n\n<p>  <script src=\"https://gist.github.com/elijahmanor/5324961.js?file=handlebars.js\">\n  </script></p>\n\n<!-- And now for the templating syntax below. The syntax feels much more terse to me compared to Underscore, which I like. Inside the template we are using the `fromNow` template helper to convert the time. This is nice so we don't have to map over our array beforehand like we did with Underscore or put the logic in the template itself. -->\n\n\n<p>现在看看下面的模板化语法。这种语法与 Underscore 相比更加简洁，这正是我喜欢的。在模板内部，我们使用模板 helper <code>fromNow</code> 转换时间。这么做非常好，因为这样我们就不需要事先遍历数组了，就像我们在使用 Underscore 或把逻辑放入模板时做的。</p>\n\n<p>  <script src=\"https://gist.github.com/elijahmanor/5324961.js?file=handlebars.html\">\n  </script></p>\n\n<!-- You can play around with the above code snippets in [jsFiddle](http://jsfiddle.net/UeWHb/). -->\n\n\n<p>你可以在 <a href=\"http://jsfiddle.net/UeWHb/\">jsFiddle</a> 中试验上面的代码。</p>\n\n<!-- ### Precompiling Your Templates -->\n\n\n<h3>预编译模板</h3>\n\n<!-- ![](http://2.bp.blogspot.com/-0c96euSzkrg/UWB2qOZsEHI/AAAAAAAAZ1Y/__iqDNw7IwE/s1600/batman-unicorn-dolphins.jpg) -->\n\n\n<p><img src=\"http://2.bp.blogspot.com/-0c96euSzkrg/UWB2qOZsEHI/AAAAAAAAZ1Y/__iqDNw7IwE/s320/batman-unicorn-dolphins.jpg\" alt=\"\" /></p>\n\n<!-- I briefly mentioned above that one of the things I liked was that you can precompile your templates. What does that even mean!?! Well, with both Underscore and Handlebars you need to compile your template before you use it (technically you can do it in one step with Underscore, but it still has to be done under the covers). Compiling a template is good to do if you plan on using it more than once or if you just want it done before you need it.  -->\n\n\n<p>我在前面简要的提到过，我喜欢 Handlebars 的原因之一是，它可以预编译模板。这是什么意思！？！ Underscore 和 Handlebars 都需要你使用模板之前先编译模板（使用 Underscore 时你可以用一个步骤完成，但是在内部仍然需要先编译）。如果你打算多次重用模板，或者你只是希望模板在需要之前已经就绪，那么编译模板是很好的做法。</p>\n\n<!-- However, with Handlebars you can go one step further and compile the template on the server and include that on the front-end. This means that you can reduce that amount of work needed on the front-end AND there is a trimmed down version of the handlebars runtime that you can use that has only the parts necessary needed to execute a template (not compile it)! -->\n\n\n<p>然而，对 Handlebars 的使用可以走得更远，你可以在服务端编译模板，然后在前端应用它。这意味着可以减少大量的前端工作量，并且你可以使用 Handlebars 的运行时精简版本，其中只包含了执行模板（不是编译模板）所必需的部分。</p>\n\n<p>How cool is that? If your answer was \"It's just about as cool as Batman riding on a Rainbow Unicorn alongside dolphins!\", then you were right! Congratulations ;)\n这太酷了，不是吗？如果你的答案是“这就像蝙蝠侠骑着彩虹独角兽和海豚在一起一样！”，那么你是对的，恭喜 ;)</p>\n\n<p>So how does that work exactly? Well, first you install Handlebars on your server using Node...\n那么，它到底是如何工作的？好吧，首先你在服务器上用 Node 安装 Handlebars...</p>\n\n<p>  <script src=\"https://gist.github.com/elijahmanor/5324961.js?file=install-handlebars.sh\">\n  </script></p>\n\n<!-- Then you take your template contents (what is between the `script` tags) and save it to a file. In our case let's save it as `tweets.tmpl`. How run the `handlebars` precompiler against your template file. -->\n\n\n<p>然后提取模板内容（<code>script</code> 标签之间）并保存到一个文件中。在这里我们把它保存为 <code>tweets.tmpl</code>。现在运行 <code>handlebars</code> 预编译模板文件。</p>\n\n<p>  <script src=\"https://gist.github.com/elijahmanor/5324961.js?file=precompile-handlebars.sh\">\n  </script></p>\n\n<!-- Once all of that is done you have a precompiled version of your template that you can now include on your front-end application like the following... -->\n\n\n<p>所有动作完成后，你得到了模板的一个预编译版本，现在你可以在前端应用中应用它，就像下面这样...</p>\n\n<p>  <script src=\"https://gist.github.com/elijahmanor/5324961.js?file=handlebars-precompile-include.html\">\n  </script></p>\n\n<p>Now that your template is available on the page you can access it by asking <code>Handlebars</code> for the precompiled version and you are all set to start using it!\n现在，你的模板在页面上可访问的，你可以通过请求 <code>Handlebars</code> 得到预编译版本，现在你完全可以开始使用它了。</p>\n\n<p>  <script src=\"https://gist.github.com/elijahmanor/5324961.js?file=handlebars-precompile-include.js\">\n  </script></p>\n\n<!-- ### Why use Handlebars.js? -->\n\n\n<h3>为什么使用 Handlebars.js？</h3>\n\n<!-- #### Pros -->\n\n\n<h4>赞成</h4>\n\n<!-- \nIts a Logic-less Template Engine\nYou can Precompile Templates on the Server\nSupports Helper methods\nCan Run on the Client and the Server\nSupports the concept of `this` in templates\nIt iss a superset of Mustache.js\nCan you think of others?\n-->\n\n\n<ul>\n<li>它是一个弱逻辑模板引擎</li>\n<li>你可以在服务端预编译模板</li>\n<li>支持 Helper 方法</li>\n<li>可以运行在客户端和服务端</li>\n<li>在模板中支持 `this` 的概念</li>\n<li>它是 Mustache.js 的超集</li>\n<li>你能想到其他的吗？</li>\n</ul>\n\n\n\n\n<!-- #### Cons -->\n\n\n<h4>反对</h4>\n\n<!-- Can you think of any? -->\n\n\n<ul>\n<li>你能想到任何理由吗？</li>\n</ul>\n\n\n\n\n<!-- ## What About Other Templating Engines? -->\n\n\n<h2>其他模板引擎怎么样？</h2>\n\n<!-- That is a great question. Maybe your needs are different than mine or maybe you just don't like one of the engines that I've mentioned. If that is the case then you should check out a great tool created by Garann Means ([@garannm](http://twitter.com/garannm)) called the [Template Chooser](http://garann.github.io/template-chooser/). The chooser will ask you a set of questions that will help determine which templating engine is right for your needs. The following is an example of what the chooser looks like... -->\n\n\n<p>这个是一个好问题。也许你的需求和我的不同，或者你只是不喜欢某个我提到的模板引擎。如果是这样的话，那么你应该看看 Garann Means (<a href=\"http://twitter.com/garannm\">@garannm</a>) 创建的<a href=\"http://garann.github.io/template-chooser/\">模板选择器</a>，这是一个伟大的工具。选择器将询问你一组问题，来辅助判断哪个模板引擎适合你的需求。选择器看起就像下面的例子...</p>\n\n<!-- ![](http://2.bp.blogspot.com/-n_FEUjxHn_s/UWBZDHPelKI/AAAAAAAAZ04/67e-eXyZ3K4/s1600/template-chooser.png) -->\n\n\n<p><img src=\"http://2.bp.blogspot.com/-n_FEUjxHn_s/UWBZDHPelKI/AAAAAAAAZ04/67e-eXyZ3K4/s640/template-chooser.png\" alt=\"\" /></p>\n\n<!-- ## Additional Resources -->\n\n\n<h2>其他资源</h2>\n\n<ul>\n  <li>\n    <a href=\"http://net.tutsplus.com/tutorials/javascript-ajax/introduction-to-handlebars/\" target=\"_blank\">\n      An Introduction to Handlebars\n    </a>\n    by Gabriel Manricks (<a href=\"http://twitter.com/GabrielManricks\" target=\"_blank\">@GabrielManricks</a>)\n  </li>\n  <li>\n    <a href=\"http://net.tutsplus.com/tutorials/javascript-ajax/best-practices-when-working-with-javascript-templates/\" target=\"_blank\">Best Practices When Working With JavaScript Templates</a>\n    by Andrew Burgess (<a href=\"http://twitter.com/andrew8088\" target=\"_blank\">@andrew8088</a>)\n  </li>\n  <li>\n    <a href=\"http://css.dzone.com/articles/demo-handlebars-and-why-you\" target=\"_blank\">Demo of Handlebars, and Why You Should Consider a Templating Engine</a>\n    Raymond Camden (<a href=\"http://twitter.com/cfjedimaster\" target=\"_blank\">@cfjedimaster</a>)\n  </li>\n  <li>\n    <a href=\"http://www.html5rocks.com/en/tutorials/webcomponents/template/\" target=\"_blank\">\n      HTML's New Template Tag: Standardizing Client-Side Templating \n    </a>\n    by Eric Bidelman (<a href=\"http://twitter.com/ebidel\" target=\"_blank\">@ebidel</a>)\n  </li>\n</ul>\n\n\n\n\n<!-- ## Attack! -->\n\n\n<h2>攻击！</h2>\n\n<p>下面是一个用 <a href=\"http://incompl.github.com/boxbox/\">boxbox</a> 构建的简版 Angry Birds，boxbox 是一个用于 <a href=\"https://code.google.com/p/box2dweb/\">box2dweb</a> 的框架，由 <a href=\"http://bocoup.com\">Bocoup</a> 的 <a href=\"http://twitter.com/_gsmith\">Greg Smith</a> 编写。</p>\n\n<!-- > Press the <code>space bar</code> to launch the Orange Bird and you can also use the arrow keys. -->\n\n\n<blockquote><p>按下<code>空格键</code>来发射橙色小鸟，你也可以使用方向键。</p></blockquote>\n\n<p><a href=\"http://jsfiddle.net/U3qVB/show\"><img src=\"http://1.bp.blogspot.com/-PMJoeP3U0iU/UWCIzvwEXlI/AAAAAAAAZ1w/kJjp8Fd0ouQ/s1600/4-6-2013+3-41-27+PM.png\" alt=\"\" /></a></p>\n\n<!-- ## Conclusion -->\n\n\n<h2>结论</h2>\n\n<!-- Mixing markup in code can lead to some nasty looking code that is cumbersome, monotonous, and difficult to maintain. Being able to split these apart is a great benefit for developers to simplify their code and help keep each concern in its place. Thankfully libraries like Underscore and Handlebars help us out by providing a clean way to describe presentation apart from logic. THere is a lot of freedom depending on what library you use, but I'd encourage you to look around and find one that works for you. The answer to that may be not to use one and that is fine.  -->\n\n\n<p>在代码中混入标记会导致一些让人讨厌的代码，这样的代码繁琐、单调，并且难以维护。能够分离各个部分的能力，给开发人员简化代码并保证各部分各司其职带来了极大的好处。值得庆幸的是，像 Underscore 和 Handlebars 这样的库提供了一种清晰的方式，将展现描述从逻辑中分离出来。你可以自由选择使用什么库，但是我鼓励你多进行一些比较，找到最适合你的库。因此这个问题的答案可能是不仅仅使用一个库，这才是一个不错的选择。</p>\n\n<!-- There are many other front-end architecture techniques that have been stolen by the pigs. Tune in next time as the next Angry Bird takes its revenge! Dun, dun, daaaaaaa! -->\n\n\n<p>还有许多其他的前端架构技术被猪群偷走了。在下篇文章中，另一只愤怒的小鸟将继续复仇！Dun, dun, daaaaaaa!</p>\n\n<blockquote><p><a href=\"http://nuysoft.com/2013/04/21/angry-birds-of-javascript-orange-bird-templating/#comment-881925473\">@sunnylost</a> 补充：Dun, dun, daaaaaaaaaa! 应该是在模拟背景音乐，类似于这种 <a href=\"http://missingno.ocremix.org/musicpages/game_on.html\">http://missingno.ocremix.org/musicpages/game_on.html</a></p></blockquote>\n"
            ],
            "link": [
              "http://nuysoft.github.com/2013/04/21/angry-birds-of-javascript-orange-bird-templating"
            ],
            "guid": [
              "http://nuysoft.github.com/2013/04/21/angry-birds-of-javascript-orange-bird-templating"
            ],
            "pubDate": [
              "2013-04-21T00:00:00-07:00"
            ]
          },
          {
            "title": [
              "应用分层 & 解耦合"
            ],
            "description": [
              "<blockquote><p>原文：<a href=\"http://www.elijahmanor.com/2013/04/angry-birds-of-javascript-black-bird.html\">Angry Birds of JavaScript: Black Bird - Backbone</a></p></blockquote>\n\n<!-- ## Introduction -->\n\n\n<h2>简介</h2>\n\n<p><img src=\"http://2.bp.blogspot.com/-efyDWffod9w/UVpR-LEJYyI/AAAAAAAAZgE/w6UXvXY3u9w/s1600/000001611.jpg\" alt=\"\" /></p>\n\n<!-- ![](http://2.bp.blogspot.com/-efyDWffod9w/UVpR-LEJYyI/AAAAAAAAZgE/w6UXvXY3u9w/s200/000001611.jpg) -->\n\n\n\n\n<!-- A diabolical herd of pigs stole all of the front-end architecture from an innocent flock of birds and now they want it back! A team of special agent hero birds will attack those despicable pigs until they recover what is rightfully theirs, front-end JavaScript architecture! -->\n\n\n<p>一群无法无天的猪从无辜的小鸟那里偷走了所有的前端架构，现在小鸟们要把它们夺回来！一队特殊的小鸟英雄将攻击这些卑鄙的猪，直到夺回原本属于它们的前端 JavaScript 架构！</p>\n\n<!-- Will the birds be successful in the end? Will they defeat their bacon flavored foe? Let's find out together in another nail biting episode of Angry Birds of JavaScript! -->\n\n\n<p>小鸟们最终会成功吗？它们会打败那些培根味儿的敌人吗？让我们一起揭示 JavaScript 之愤怒的小鸟系列的另一个扣人心弦的章节！</p>\n\n<blockquote><p>译注：翻译“bacon flavored foe”时，想起来了《少林足球》里的“做人如果没有梦想，那跟咸鱼有什么区别？”，就翻译成了“咸猪敌人”，<a href=\"http://nuysoft.com/2013/04/21/angry-birds-of-javascript-orange-bird-templating/#comment-881925473\">@sunnylost</a> 建议翻译为“培根味儿的敌人”，应该更准确和有趣些。</p></blockquote>\n\n<!-- > Check out the **[series introduction post](http://www.elijahmanor.com/2013/03/angry-birds-of-javascript-series.html)** for a list of all the birds and their attack powers. -->\n\n\n<blockquote><p>阅读<strong><a href=\"http://www.elijahmanor.com/2013/03/angry-birds-of-javascript-series.html\">系列介绍文章</a></strong>，查看所有小鸟以及它们的攻击力。</p></blockquote>\n\n<p><span href=\"\" imageanchor=\"1\" style=\"clear: right; float: right; margin-bottom: 1em; margin-left: 1em;\"><img border=\"0\" src=\"http://4.bp.blogspot.com/-wjhQKJKNuks/UVdeWffTYoI/AAAAAAAAZNY/XpHY_8R3tQs/s1600/black-bird.png\" /></span></p>\n\n<!-- ### Previous Attacks -->\n\n\n<h3>战报</h3>\n\n<ul>\n    <li>\n      <a href=\"http://www.elijahmanor.com/2013/03/angry-birds-of-javascript-red-bird.html\" target=\"_blank\">Red Bird - IIFE</a>\n    </li>\n    <li>\n      <a href=\"http://www.elijahmanor.com/2013/03/angry-birds-of-javascript-blue-bird.html\" target=\"_blank\">Blue Bird - Events</a>\n    </li>\n    <li>\n      <a href=\"http://www.elijahmanor.com/2013/04/angry-birds-of-javascript-yellow-bird.html\" target=\"_blank\">Yellow Bird - RequireJS</a>\n    </li>\n</ul>\n\n\n\n\n<!-- ### Black Bird Attacks -->\n\n\n<h3>黑鸟的攻击</h3>\n\n<!-- In this post we will take a look at the Black Bird who will use the organized approach of the <a href=\"http://draft.blogger.com/backbonejs.org\" target=\"_blank\">Backbone.js</a> bomb to fight these porkers. Slowly, one by one, the birds will take back what it theirs to keep! -->\n\n\n<p>在这边文章中，我们将看看黑色小鸟，它用有组织条理的 Backbone.js 炸弹对付这些小肥猪。渐渐的，小鸟们将一个接一个地夺回属于它们的东西！</p>\n\n<!-- ## What Was Stolen by the Pigs? -->\n\n\n<h2>猪偷走了什么？</h2>\n\n<!-- The birds used to write their jQuery code like it was a tangled smorgasbord of worms. They would mix up their views, models, and presenter logic all together in a big interconnected pile of grubs. After a while one of their ancestors, a Black Bird, introduced the Backbone.js library and showed them a different way to think about developing front-end web applications. However, during a recent invasion the pigs stole Backbone.js from the birds and carried it back to their filthy sty. -->\n\n\n<p>小鸟们过去经常把 jQuery 代码写得像是一个令人纠结的蠕虫大杂烩。它们把视图、模型、展现逻辑混淆在了一起。过了一段时间之后，一只黑色小鸟，它们的祖先之一，引入了 Backbone.js 库，并向小鸟们展示了一种思考 Web 前端应用开发的不同方式。然而，在最近的入侵中，猪群从小鸟哪里偷走了 Backbone.js，并把它抬回了它们那肮脏的猪圈。</p>\n\n<!-- One of the black birds has been tasked to reclaim what has been stolen. He will use his explosive power of organization to help destroy the pigs in order to take back what is theirs. -->\n\n\n<p>一只黑色小鸟被派去夺回被盗的 Backbone.js。它将用爆炸性的组织之力（power of organization）摧毁猪群，夺回属于它们的东西。</p>\n\n<!-- ## Tangled Smorgasbord of Worms -->\n\n\n<h2>纠结的蠕虫大杂烩</h2>\n\n<!-- Let's take a look again at the following application that the <a href=\"http://draft.blogger.com/blogger.g?blogID=30404818\"> Blue Bird </a> dealt with in a previous attack. Instead of adding messages to untangle the mess we are going to introduce how using Backbone.js can help us out. Here is the running application below... -->\n\n\n<p>让我们再看看下面的应用，<a href=\"http://draft.blogger.com/blogger.g?blogID=30404818\">Blue Bird</a> 在之前的攻击中已经处理过。通过增加消息可以理清混乱，但这里要介绍的是如何使用 Backbone.js 达到同样的目的。下面是正在运行的程序...</p>\n\n<!-- > It appears <a href=\"http://plnkr.co/\">Plunker</a> is not embedding correctly at the moment. The application is a simple Netflix search interface that will show the results from Netflix. If Plunker doesn't start working soon I will move the demo somewhere else. Sorry for the inconvenience. -->\n\n\n<blockquote><p>有时 <a href=\"http://plnkr.co/\">Plunker</a> 不能正确的嵌入。这个应用是一个简单的 Netflix 搜索接口，会展示 Netflix 返回的结果。如果 Plunker 不能开始工作，我会把这个演示很快转移到别处。很抱歉给你带来不便。</p></blockquote>\n\n<p>  <iframe allowfullscreen=\"allowfullscreen\" frameborder=\"0\" src=\"http://embed.plnkr.co/td1ZTtptDT0RIxc7VIgM\" style=\"height: 300px; width: 100%;\">\n  </iframe></p>\n\n<!-- And to refresh your memory, here is the supporting code used for the above web application. You should notice that a lot of concerns are all being mixed together (DOM events, Modifying the View, AJAX Communication, etc...) -->\n\n\n<p>再次提醒你，这是上面的 Web 应用的实现代码。你应该注意的是，很多关注点被混合在了一起（DOM 事件、修改视图、Ajax 通信等）</p>\n\n<p>  <script src=\"https://gist.github.com/elijahmanor/5283260.js?file=jquery-worms.js\">\n  </script></p>\n\n<!-- Do you see the problem? It is so tempting to write code like the above, but I hope you see that it can be a bear to work with and maintain. Don't worry, we have all written code just like the above. The good news is that we don't have to continue to write it that way. Let's take a look at what Backbone.js is and how it can help us out in this situation.  -->\n\n\n<p>你发现了问题了吗？编写类似上面的代码非常诱人，但我希望你能看到，协同和维护这样的代码将是一种负担。不过不要担心，我们都写过类似上面的代码。好消息是我们不必再用那种方式写代码。让我们来看看 Backbone.js 是什么，以及在这种情况下它如何帮助我们。</p>\n\n<!-- > There are many other MV* front-end frameworks (Knockout, or AngularJS, EmberJS, & others) that could also bring structure to the above code. I would encourage you to pick a tool that you can be productive with and get comfortable with it. -->\n\n\n<blockquote><p>还有很多其他的前端 MV* 框架（Knockout、AngularJS、EmberJS 及其他）可以结构化上面的代码。我鼓励你选择一个工具，使用并适应它。</p></blockquote>\n\n<!-- ## Backbone.js Basics -->\n\n\n<h2>Backbone.js 基础</h2>\n\n<p>Backbone.js has several pieces that can all work together to make a web application. You don't have to use all of these components, but they are available if you choose to use them.\nBackbone.js 含有几个组件，它们可以协同合作构建一个 Web 应用。我不必使用所有这些组件，但是你如果选择使用它们，它们就是有用的。</p>\n\n<ul>\n  <li>模型 Model - 表示数据，以及数据相关的逻辑</li>\n  <!-- Model - Represents data and logic surrounding it -->\n  <li>集合 Collection - 模型的有序集合</li>\n  <!-- Collection - Ordered sets of Models -->\n  <li>视图 View - 一个模块，带有渲染方法、依赖一个模型</li>\n  <!-- View - A module backed by a Model with a render method -->\n  <li>路由 Router - 提供可链接和可分享 URL 的机制</li>\n  <!-- Router - Mechanism to provide linkable, sharable URLs -->\n  <li>事件 Event - 观察者事件模型</li>\n  <!-- Event - Observer Eventing module -->\n  <li>路由器 History - 提供操作历史的能力（支持后退按钮）</li>\n  <!-- History - Provides the ability to maintain history (back button support) -->\n  <li>同步 - 可扩展组件，提供与服务端的 RESTful 通信</li>\n  <!-- Sync - Extendable component providing RESTful communication to the server -->\n</ul>\n\n\n\n\n<!-- ## Refactoring the Tightly Coupled Code -->\n\n\n<h2>重构紧耦合代码</h2>\n\n<!-- Let's take a stab at refactoring the above jQuery mess and use Backbone.js to split out some of the various concerns.  -->\n\n\n<p>让我们试着重构上面的 jQuery 代码，并且使用 Backbone.js 分离各种关注点。</p>\n\n<!-- I'm not going to dive into all of the above pieces in this post, but will focus on 3 of the main pieces (Models, Collections, and Views). I'll touch on some of the Sync concerns, but as part of the other topics. I'll have resources listed at the end if you want to dig deeper into any of these topics. -->\n\n\n<p>在这篇文章中，我不打算涉及所有上述组件，只会专注于 3 个主要组件（模型、集合、视图）。我会涉及到一些 Sync 组件，但它是作为其他主题的一部分出现。如果你想深入钻研这些主题，我在末尾列出了一些资源。</p>\n\n<h3>RequireJS</h3>\n\n<!-- Before we get into the Models, Collections, and Views I want to show you how we took out all the scripts from the index.html page and used RequireJS to help us out. -->\n\n\n<p>在我们开始模型、集合和视图之前，我想先展示如何使用 RequireJS ，来帮助我们从 index.html 页面中提取出所有脚本。</p>\n\n<!-- > If you've never seen RequireJS before then you might want to check out the previous **[Yellow Angry Bird Post](http://www.elijahmanor.com/2013/04/angry-birds-of-javascript-yellow-bird.html)** about RequireJS. -->\n\n\n<blockquote><p>如果你之前从没见过 RequireJS，你可能需要阅读之前关于 RequireJS 的<strong><a href=\"http://www.elijahmanor.com/2013/04/angry-birds-of-javascript-yellow-bird.html\">愤怒的黄色小鸟</a></strong>一文。</p></blockquote>\n\n<h4>main.js</h4>\n\n<p>  <script src=\"https://gist.github.com/elijahmanor/5283260.js?file=main.js\">\n  </script></p>\n\n<!-- The above code is defining the paths for jQuery, Underscore, Backbone, Postal, and Bootstrap. We needed to shim Underscore, Backbone, and Bootstrap since they are not defined as AMD modules.  -->\n\n\n<p>上面的代码定义了 jQuery、Underscore、Backbone、Postal 和 Bootstrap 的路径。我们需要为 Underscore、Backbone、Bootstrap 使用垫片，因为它们没有被定义为 AMD 模块。</p>\n\n<!-- Then the `require` function is called to request a set of dependencies before the callback is invoked. At that point, jQuery and all the other views and models will be ready for usage! -->\n\n\n<p>然后，函数 <code>require</code> 被调用，用来在回调函数被调用之前请求一组依赖库。到那时，jQuery 和所有其他视图和模型将准备就绪。</p>\n\n<!-- ### Models -->\n\n\n<h3>模型</h3>\n\n<!-- We are going to make 2 models (Search and Movie) to represent the above application.  -->\n\n\n<p>我们将创建 2 个模型（Seach 和 Movie）来表示上面的应用。</p>\n\n<!-- The following Search Model is really simple and its main job is to respond when the `term` property has changed. We are using Backbone's events (Observer Events) to listen to changes on the model and then propagating the message to Postal.js (Mediated Events). For more information about those terms and how they are different you can reference the [Blue Angry Bird Post](http://www.elijahmanor.com/2013/03/angry-birds-of-javascript-blue-bird.html) about events. -->\n\n\n<p>下面的 Search 模型相当简单，它的主要任务是响应 <code>term</code> 属性的变化。我们使用 Backbone 的事件（观察者事件）来监听模型的变化，然后传播消息到 Postal.js（中介事件）。关于这些术语的更多信息以及它们的不同之处，可以参考关于事件的<a href=\"http://www.elijahmanor.com/2013/03/angry-birds-of-javascript-blue-bird.html\">愤怒的蓝色小鸟</a>一文。</p>\n\n<h4>search.js</h4>\n\n<p>  <script src=\"https://gist.github.com/elijahmanor/5283260.js?file=search.js\">\n  </script></p>\n\n<!-- The following Movie Model doesn't have a lot going on as well. It's main purpose is to parse the data returned from the server and map the results to something a little more manageable. In this case we are only concerned with the `releaseYear`, `rating`, and `name` properties.  -->\n\n\n<p>下面的 Movie 模型也没有很多事情要做。它的主要目的是解析服务端返回的数据，并把结果映射为更易于管理的结构。这样我们只需要关心 <code>releaseYear</code>, <code>rating</code>, 和 <code>name</code> 属性。</p>\n\n<h4>movie.js</h4>\n\n<p>  <script src=\"https://gist.github.com/elijahmanor/5283260.js?file=movie.js\">\n  </script></p>\n\n<!-- ### Collections -->\n\n\n<h3>集合</h3>\n\n<!-- As we described above, collections are just a set of models. The following code is just a set of Movie models. The collection is where you define where to get the list of models from the server. The back-end for this application is Netflix and their endpoint is a little complex so we are using a function to dynamically build that URL. We also defined a `parse` method to get directly to the array of contents that will be mapped to `Movie` models. Since this AJAX call will be using JSONP we also needed to override the `sync` method and provide some additional options. -->\n\n\n<p>正如我们在上面描述的，集合只是一组模型。下面的代码也只是一组 Movie 模型。集合定义了从服务器的哪个位置获取模型列表。这个应用的后端是 Netflix，并且稍微有点复杂，因为我们需要用一个函数来动态建立 URL。我们还定义了一个 <code>parse</code> 方法，用来直接获取内容数组，内容将被映射到 <code>Movie</code> 模型。因为这个 Ajax 使用的是 JSONP，我们还需要覆盖 <code>sync</code> 方法提供一些额外选项。</p>\n\n<h4>movies.js</h4>\n\n<p>  <script src=\"https://gist.github.com/elijahmanor/5283260.js?file=movies.js\">\n  </script></p>\n\n<!-- ### Views -->\n\n\n<h3>视图</h3>\n\n<p>I see the View as more of a Presenter than the typical MVC View you might normally think of. Anyway, We have 2 views in this application that we will briefly look at.\n我认为视图更像一个 Presenter，与通常认为的传统 MVC 视图相比。这个应用有 2 个视图，我们简要地看看。</p>\n\n<!-- The following `SearchView` handles the interactions with the DOM and the Model. The `events` property primarily is used to listen to DOM events and in this case is watching for clicks on the button or previous search links. Changes to these elements will be stored in the model as `term`. The `initialize` method sets up some events listening for changes in the `term` property. If `term` changes, then portions of the UI will change accordingly. -->\n\n\n<p>下面的 <code>SearchView</code> 处理与 DOM 和模型的交互。属性 <code>events</code> 主要用于监听 DOM 事件，在这里是等待点击按钮或点击搜索记录链接。这些元素的改变将存在在模型中，属性名为 <code>term</code>。方法 <code>initialize</code> 设置了一些事件来监听属性 <code>term</code> 的变化。如果 <code>term</code> 发生变化，部分 UI 会相应的发生变化。</p>\n\n<h4>search-view.js</h4>\n\n<p>  <script src=\"https://gist.github.com/elijahmanor/5283260.js?file=search-view.js\">\n  </script></p>\n\n<!-- The `MovieView` below is a little different than the above view. The first thing to point out is the weird `text!movie-template.html`. I am using the `text.js` plugin for RequireJS that let's us pull text resources as part of the dependency chain. This is really helpful for markup files used when using a templating engine or possibly a CSS file that is associated with a particular widget. Inside of the `initialize` method we are subscribing to a change in the term and then asking the collection to `fetch` the information from the server. The `render` method gets called after the data is retrieved from the server and we use Underscore to template the results to the DOM. -->\n\n\n<p>下面的 <code>MovieView</code> 与上面的视图略有不同。首先要指出的是怪异的 <code>text!movie-template.html</code>。我使用了 RequireJS 的 <code>text.js</code> 插件，允许将文本资源作为依赖练的一部分。这对于使用标记文件的场景很有用，可能是使用模板引擎时，也可能是使用与某个特定组件有关的 CSS 文件时。在方法 <code>initialize</code> 内部，我们订阅了 term 的变化消息，然后要求集合从服务器获取（<code>fetch</code>）信息。从服务器检索到数据之后，方法 <code>render</code> 被调用，并且使用 Underscore 将结果模板化为 DOM。</p>\n\n<h4>movie-view.js</h4>\n\n<p>  <script src=\"https://gist.github.com/elijahmanor/5283260.js?file=movie-view.js\">\n  </script></p>\n\n<!-- The following is the template file in case you were wondering. I'm using Underscore's templating engine which is similar to John Resig's micro-templating implementation that he wrote years ago. There are other templating libraries available, but I used this one because it comes with Underscore which is a prerequisite for Backbone. If I needed something more featured I would have used Handlebars instead, but that is a story for another Angry Bird ;) -->\n\n\n<p>下面是模板文件，假如你正疑惑的话。我使用了 Underscore 的模板引擎，类似于 John Resig 在数年前写的的 Micro-Templating 实现。还有其他可用的模板库，我选择这个是因为它所在的 Underscore 是 Backbone 的先决条件。如果我需要更多功能，我会选择 Handlebars，不过，那是另一只愤怒的小鸟的故事了 ;)</p>\n\n<h4>movie-template.html</h4>\n\n<p>  <script src=\"https://gist.github.com/elijahmanor/5283260.js?file=movie-template.html\">\n  </script></p>\n\n<!-- ## Additional Resources -->\n\n\n<h2>附加资源</h2>\n\n<!-- I only scratched the surface on all the things you can do with Backbone.js. If you are interesting in learning more about these concepts you may want to look at some of the following resources.  -->\n\n\n<p>关于 Backbone.js 可以做的事情，我只涉及到一些皮毛。如果有兴趣了解关于这些概念的更多信息，看看下面的资源。</p>\n\n<!-- > The following resources were taken from the **[Beginner HTML5, JavaScript, jQuery, Backbone, and CSS3 Resources](http://www.elijahmanor.com/2013/01/beginner-html5-javascript-jquery.html)** blog post. -->\n\n\n<blockquote><p>下面的资源从博客文章 <strong><a href=\"http://www.elijahmanor.com/2013/01/beginner-html5-javascript-jquery.html\">Beginner HTML5, JavaScript, jQuery, Backbone, and CSS3 Resources</a></strong> 获得。</p></blockquote>\n\n<ul>\n    <li>\n      <a href=\"http://backbonejs.org/\">\n        Backbone.js API\n      </a>\n    </li>\n    <li>\n      <a href=\"http://backbonejs.org/docs/backbone.html\">\n        Annotated Backbone.js Code\n      </a>\n    </li>\n    <li>\n      <a href=\"https://github.com/documentcloud/backbone/wiki/Extensions,-Plugins,-Resources\">\n        Backbone Extensions, Plugins, &amp; Resources\n      </a>\n    </li>\n    <li>\n      <a href=\"https://github.com/tbranyen/backbone-boilerplate\">\n        Backbone Boilerplate\n      </a>\n    </li>\n    <li>\n      <a href=\"https://github.com/addyosmani/backbone-fundamentals\">\n        Backbone Fundamentals eBook\n      </a>\n      by Addy Osmani(<a href=\"http://twitter.com/addyosmani\">@addyosmani</a>)\n    </li>\n    <li>\n      <a href=\"https://peepcode.com/products/backbone-js\">\n        Peep Code: Backbone.js Video Series\n      </a>\n      by Geoffery Grosenbach(<a href=\"http://twitter.com/topfunky\">@topfunky</a>) and David Goodlad(<a href=\"http://twitter.com/dgoodlad\">@dgoodlad</a>)\n    </li>\n    <li>\n      <a href=\"http://pragprog.com/screencasts/v-dback/hands-on-backbone-js\">\n        The Pragmatic Bookshelf: Hands-on Backbone.js\n      </a>\n      by Derick Bailey(<a href=\"http://twitter.com/derickbailey\">@derickbailey</a>)\n    </li>\n    <li>\n      <a href=\"http://backbonescreencasts.com/\">\n        Backbone.js Screencasts\n      </a>\n      by Joey Beninghove\n    </li>\n    <li>\n      <a href=\"http://www.pluralsight.com/training/Courses/TableOfContents/backbone-fundamentals\">\n        Pluralsight: Backbone.js Fundamentals\n      </a>\n      by Liam McLennan(<a href=\"http://twitter.com/liammclennan\">@liammclennan</a>)\n    </li>\n    <li>\n      <a href=\"http://codular.com/starting-with-backbone\">\n        The Skinny on BackboneJS\n      </a>\n      by Ben Howdle(<a href=\"http://twitter.com/benhowdle\">@benhowdle</a>)\n    </li>\n    <li>\n      <a href=\"http://backbonetutorials.com/\">\n        Backbone Tutorials\n      </a>\n    </li>\n    <li>\n      <a href=\"http://net.tutsplus.com/tag/backbone/\">\n        Backbone.js Tutorials\n      </a>\n      via Nettuts\n    </li>\n    <li>\n      <a href=\"http://javascriptplayground.com/blog/category/backbonejs\">\n        Exploring Backbone.js Series\n      </a>\n      by Jack Franklin(<a href=\"http://twitter.com/jack_franklin\">@jack_franklin</a>)\n    </li>\n</ul>\n\n\n\n\n<!-- ## Attack! -->\n\n\n<h2>攻击！</h2>\n\n<p>下面是一个用 <a href=\"http://incompl.github.com/boxbox/\">boxbox</a> 构建的简版 Angry Birds，boxbox 是一个用于 <a href=\"https://code.google.com/p/box2dweb/\">box2dweb</a> 的框架，由 <a href=\"http://bocoup.com\">Bocoup</a> 的 <a href=\"http://twitter.com/_gsmith\">Greg Smith</a> 编写。</p>\n\n<!-- > Press the `space bar` to launch the Black Bird and you can also use the arrow keys. -->\n\n\n<blockquote><p>按下<code>空格键</code>来发射黑色小鸟，你也可以使用方向键。</p></blockquote>\n\n<p><a href=\"http://4.bp.blogspot.com/-QBX6E-gJmzE/UVuGtHDEmMI/AAAAAAAAZuM/xXbC6KMc3OU/s1600/black-brid-game.png\"></p>\n\n<pre><code>&lt;img border=\"0\" src=\"http://4.bp.blogspot.com/-QBX6E-gJmzE/UVuGtHDEmMI/AAAAAAAAZuM/xXbC6KMc3OU/s1600/black-brid-game.png\" /&gt;\n</code></pre>\n\n<p></a></p>\n\n<!-- ## Conclusion -->\n\n\n<h2>结论</h2>\n\n<!-- Front-end web applications can get complicated quickly. Before you know it you have a pile of interconnected mess if you are not careful. Thankfully Backbone.js provides components to help you split out your application into consumable pieces that each have their own purpose. Thank you Black Bird for returning Backbone back to the birds. They will be able to rest easier knowing things are organized and in their proper place. -->\n\n\n<p>Web 前端应用可以快速变得相当复杂。在你知道这点之前，如果你不小心就会导致关系混乱。值得庆幸的是，Backbone.js 提供了组件来帮助你把应用分割为可用的小模块，并且每个小模块各司其职。感谢黑色小鸟为小鸟们夺回了 Backbone。事情被有条理地组织起来，并安排在合适的位置上，现在，小鸟们可以安心休息了。</p>\n\n<!-- There are many other front-end architecture techniques that have been stolen by the pigs. Tune in next time as the next Angry Bird takes its revenge! Dun, dun, daaaaaaa! -->\n\n\n<p>还有许多其他的前端架构技术被猪群偷走了。在下篇文章中，另一只愤怒的小鸟将继续复仇！Dun, dun, daaaaaaa!</p>\n\n<blockquote><p><a href=\"http://nuysoft.com/2013/04/21/angry-birds-of-javascript-orange-bird-templating/#comment-881925473\">@sunnylost</a> 补充：Dun, dun, daaaaaaaaaa! 应该是在模拟背景音乐，类似于这种 <a href=\"http://missingno.ocremix.org/musicpages/game_on.html\">http://missingno.ocremix.org/musicpages/game_on.html</a></p></blockquote>\n"
            ],
            "link": [
              "http://nuysoft.github.com/2013/04/21/angry-birds-of-javascript-black-bird-backbone"
            ],
            "guid": [
              "http://nuysoft.github.com/2013/04/21/angry-birds-of-javascript-black-bird-backbone"
            ],
            "pubDate": [
              "2013-04-21T00:00:00-07:00"
            ]
          },
          {
            "title": [
              "事件 & 消息"
            ],
            "description": [
              "<blockquote><p>原文：<a href=\"http://www.elijahmanor.com/2013/03/angry-birds-of-javascript-blue-bird.html\">Angry Birds of JavaScript: Blue Bird - Events</a></p></blockquote>\n\n<!-- ## Introduction -->\n\n\n<h2>简介</h2>\n\n<!-- Blue Bird - Events & Messaging http://jsfiddle.net/LrFVp/14/ http://jsfiddle.net/LrFVp/20/ -->\n\n\n<p><img src=\"http://2.bp.blogspot.com/-6ILPSz-pyp0/UVEnzs_iVfI/AAAAAAAAYVE/yXkm3RWutRs/s1600/angry-birds-game-for-windows-1.png\" alt=\"\" /></p>\n\n<!-- ![](http://2.bp.blogspot.com/-6ILPSz-pyp0/UVEnzs_iVfI/AAAAAAAAYVE/yXkm3RWutRs/s320/angry-birds-game-for-windows-1.png) -->\n\n\n\n\n<!-- A diabolical herd of pigs stole all of the front-end architecture from an innocent flock of birds and now they want it back! A team of special agent hero birds will attack those despicable pigs until they recover what is rightfully theirs, front-end JavaScript architecture! -->\n\n\n<p>一群无法无天的猪从无辜的小鸟那里偷走了所有的前端架构，现在小鸟们要把它们夺回来！一队特殊的小鸟英雄将攻击这些卑鄙的猪，直到夺回原本属于它们的前端 JavaScript 架构！</p>\n\n<!-- Will the birds be successful in the end? Will they defeat their bacon flavored foe? Let's find out together in another nail biting episode of Angry Birds of JavaScript! -->\n\n\n<p>小鸟们最终会成功吗？它们会打败那些培根味儿的敌人吗？让我们一起揭示 JavaScript 之愤怒的小鸟系列的另一个扣人心弦的章节！</p>\n\n<blockquote><p>译注：翻译“bacon flavored foe”时，想起来了《少林足球》里的“做人如果没有梦想，那跟咸鱼有什么区别？”，就翻译成了“咸猪敌人”，<a href=\"http://nuysoft.com/2013/04/21/angry-birds-of-javascript-orange-bird-templating/#comment-881925473\">@sunnylost</a> 建议翻译为“培根味儿的敌人”，应该更准确和有趣些。</p></blockquote>\n\n<!-- > Check out the [series introduction post](http://www.elijahmanor.com/2013/03/angry-birds-of-javascript-series.html) for a list of all the birds and their attack powers. -->\n\n\n<blockquote><p>阅读<strong><a href=\"http://www.elijahmanor.com/2013/03/angry-birds-of-javascript-series.html\">系列介绍文章</a></strong>，查看所有小鸟以及它们的攻击力。</p></blockquote>\n\n<!-- ### Previous Attacks -->\n\n\n<h3>战报</h3>\n\n<ul>\n<li><a href=\"http://www.elijahmanor.com/2013/03/angry-birds-of-javascript-red-bird.html\">Red Bird - IIFE</a></li>\n</ul>\n\n\n<!-- ###  Blue Bird Attack -->\n\n\n<h3>绿鸟的攻击</h3>\n\n<p><a href=\"http://3.bp.blogspot.com/-sJcdgjfGHVc/UU_R2M3GqgI/AAAAAAAAYSU/eb2T2_qHjxY/s1600/blue-bird.png\"><img src=\"http://3.bp.blogspot.com/-sJcdgjfGHVc/UU_R2M3GqgI/AAAAAAAAYSU/eb2T2_qHjxY/s200/blue-bird.png\" alt=\"\" /></a></p>\n\n<!-- In this post we will take a look at the Blue Bird who triggers events and messages that scatter to infiltrate the pig's castle. Slowly, one by one, the birds will take back what it theirs to keep! -->\n\n\n<p>在这篇文章中，我们将看看蓝色小鸟，它通过触发事件和消息来分散穿透猪群的城堡。渐渐的，小鸟们将一个接一个地夺回属于它们的东西！</p>\n\n<!-- ## What Was Stolen by the Pigs? -->\n\n\n<h2>猪偷走了什么？</h2>\n\n<!-- The birds used to build their web applications with components having hard dependencies on each-other. They eventually started to learn to reduce tight coupling by introducing events and messages. Unfortunately the pigs, during their invasion, stole the birds' observer secrets. -->\n\n\n<!-- One of the blue birds has been tasked with taking back what has been stolen and restore loose coupling components. -->\n\n\n<p>小鸟们过去经常用组件构建 Web 应用，而组件之间却是硬编码依赖关系。最终它们引入了事件和消息，开始学习如何降低耦合度。不幸的是，猪群在入侵中偷走了小鸟们的观察者秘密。一只蓝色小鸟被派去夺回被盗的东西，并恢复松耦合组件。</p>\n\n<!-- ## Sample Application -->\n\n\n<h2>应用程序示例</h2>\n\n<!-- In order to unpack the need for messages we will look at the following web application to search for movies from Netflix. We will uncover how this application was originally coded and then refactor along the way. -->\n\n\n<p>为了理解消息的必要性，我们先看看下面的 Web 应用，它从 Netflix 搜索电影。我们将展示这个应用的初始代码，然后重构它。</p>\n\n<p>  <iframe allowfullscreen=\"allowfullscreen\" frameborder=\"0\" height=\"350\" src=\"http://jsfiddle.net/LrFVp/14/embedded/result\" width=\"100%\">\n  </iframe></p>\n\n<!-- ## Tightly Coupled Code -->\n\n\n<h2>紧耦合代码</h2>\n\n<!-- The first version of the above application was coded using the following JavaScript code. Take a look at the code and let it start to sink in for a little bit. It may be painful, but please bar with me for a moment ;) -->\n\n\n<p>上面应用的第一个版本使用下面的 JavaScript 代码实现。看看这段代码，试着理解它。这可能很痛苦，但还是先忍一下 ;)</p>\n\n<p>  <script src=\"https://gist.github.com/elijahmanor/5235011.js?file=tightly-coupled.js\"></script></p>\n\n<!-- The above code sample is a typical jQuery example that you can find across the internet. The snippet works, but there is a lot of different things happening all in the same place. You can find event handling, data retrieval, and data manipulation all mixed together. You can imagine that over time this code might continue to grow and grow and become more and more prone for errors. -->\n\n\n<p>上面的代码示例是一个典型的 jQuery 示例，在互联网上随处可见。这段代码可以工作，但是在一个地方放置了很多不同功能的代码。事件处理、数据检索和数据处理都混在一起。你可以想象一下，这段代码可能会继续增长，从而变得越来越容易出现错误。</p>\n\n<!-- Before we get too far, let's take a side trip and look at what messages are and what types exist. -->\n\n\n<p>在我们想得太远之前，先顺便看看有些什么事件，以及事件有些什么类型。</p>\n\n<!-- ## Types of Messages -->\n\n\n<h2>消息类型</h2>\n\n<!-- ### Observer Events -->\n\n\n<h3>观察者事件</h3>\n\n<!-- An observer event is probably one that you are most used to if you are familiar with front-end web development. In relation to the DOM you can think of this as adding event handlers to an element. The element has a direct reference to the callbacks that will be invoked when the event type occurs. -->\n\n\n<p>如果你熟悉 Web 前端开发的话，观察者事件很可能是最常用的一种事件。在 DOM 中，你可以为一个元素添加事件处理函数。元素直接引用了回调函数，当事件发生时回调函数被调用。</p>\n\n<!-- #### Example -->\n\n\n<h4>示例</h4>\n\n<p>  <script src=\"https://gist.github.com/elijahmanor/5235011.js?file=observer-events.js\">\n  </script></p>\n\n<!-- ### Mediated Events -->\n\n\n<h3>中介事件</h3>\n\n<!-- A mediated event or message has become more common the last several years in front-end web development. The main idea here is that there is another entity that keeps track of publishing and subscribing of messages. The main difference between this and Observer events is that Mediated events aren't tied directly to the subject that invoked it. -->\n\n\n<p>在过去几年的 Web 前端开发中，中介事件或消息变得越来越普遍。其主要思想是用另外一个实体跟踪消息的发布和订阅。中介事件与观察者事件的主要区别在于，它不直接引用触发事件的主体。</p>\n\n<!-- #### Example -->\n\n\n<h4>示例</h4>\n\n<p>  <script src=\"https://gist.github.com/elijahmanor/5235011.js?file=mediated-events.js\">\n  </script></p>\n\n<!-- #### Implementations -->\n\n\n<h4>实现</h4>\n\n<!-- There are several libraries out there that facilitate mediated events. The following is a list of various libraries that you may want to choose from. My recommendation is that you look at Jim's [postal.js] library. -->\n\n\n<p>有几个库可以简化中介事件。下面是一份可供选择的清单。个人推荐试试 Jim 的 <a href=\"https://github.com/postaljs/postal.js\">postal.js</a> 库。</p>\n\n<ul>\n<li>Ben Alman's (<a href=\"http://twitter.com/cowboy\">@cowboy</a>) <a href=\"https://github.com/cowboy/jquery-tiny-pubsub\">Tiny jQuery Pub/Sub</a> library</li>\n<li>Peter Higgin's (<a href=\"http://twitter.com/phiggins\">@phiggins</a>) <a href=\"https://github.com/phiggins42/bloody-jquery-plugins/blob/master/pubsub.js\">pubsub.js</a> library</li>\n<li><strong>Jim Cowart's (<a href=\"http://twitter.com/ifandelse\">@ifandelse</a>) <a href=\"https://github.com/postaljs/postal.js\">postal.js</a> library &#8592; Recommended</strong></li>\n<li>Dustin Diaz's (<a href=\"http://twitter.com/ded\">@ded</a>) <a href=\"https://github.com/ded/reqwest\">reqwest</a> library</li>\n<li>appendTo's (<a href=\"http://twitter.com/appendTo\">@appendTo</a>) <a href=\"http://amplify.js/\">AmplifyJS Pub/Sub</a> component</li>\n</ul>\n\n\n<!-- ### Hybrid Events -->\n\n\n<h3>混合事件</h3>\n\n<!-- There is another type of event that is sort of a hybrid between observer and mediated. This type looks like a mediated event, but if you look hard enough there you could actually trace the origin of the event back to the original subject. A good example of this is jQuery's delegated event model. Delegated events are great, but it is based on the concept of events bubbling up the DOM and therefore we can trace where it came from.  -->\n\n\n<p>另外一种事件则混合了观察者事件和中介事件。它看起来像一个中介事件，但如果你仔细看的话，可以从事件的起源追溯到最初的主体。一个很好的例子是 jQuery 的代理事件模型。代理事件很棒，因为它基于事件沿着 DOM 树向上冒泡的概念，所以我们可以跟踪到事件源。</p>\n\n<!-- #### Example -->\n\n\n<h4>示例</h4>\n\n<p>  <script src=\"https://gist.github.com/elijahmanor/5235011.js?file=hybrid-events.js\">\n  </script></p>\n\n<!-- By the way, I don't recommend using the `$._data()` method as it is undocumented and therefore not guaranteed that it will be available in future versions of jQuery. It is an internal helper method that jQuery currently uses under the covers. However, I did want to show you that there is a way to poke around and get at information that the subscriber shouldn't have in a real \"mediated event\", which is why I'm calling it a hybrid event. Don't get me wrong, I love jQuery's delegated events. I just wanted to show how it is a hybrid of the two above concepts. -->\n\n\n<p>顺便说一句，我不建议使用 <code>$._data()</code> 方法，因为它不是公开方法，不能保证在未来的 jQuery 版本中是可用的。它是 jQuery 目前在使用的一个内部方法。我想告诉你的是，订阅者不需要一个真正的中介事件也能方便的获取信息。不要误会我的意思，我很喜欢 jQuery 的代理事件。我只想表达它是上述两种概念混合后的结果。</p>\n\n<!-- ### Which One Should Be Used? -->\n\n\n<h3>该用哪个？</h3>\n\n<!-- That information is all fine and good, but what type of event/message should you be using and when? That is a great question and one that my friend Jim addressed in a recent post that he wrote. The following is a quote from his article... -->\n\n\n<p>概念都讲清楚了，但是该使用哪些类型的事件或消息，以及何时使用呢？这是一个好问题，我的朋友 Jim 最近的一篇文章中也提到了这个问题。下面他文章的一段引用...</p>\n\n<blockquote><p>\"...use observer 'locally', inside a component, mediator 'remotely' between components. No matter what, be ready to use both in tandem.' -- <a href=\"http://freshbrewedcode.com/jimcowart/2013/02/07/client-side-messaging-essentials/\">Jim Cowart</a></p>\n\n<p>在组件内部使用观察者，在组件之间使用中介者。</p></blockquote>\n\n<!-- Jim recommends using observer events (jQuery's `.on()` method) when communicating within a module and to use mediated events (postal.js) when communicating between modules. -->\n\n\n<p>Jim 推荐模块内部的通信使用观察者事件（jQuery 的 <code>.on()</code> 方法），组件之间的通信则使用中介事件（postal.js）。</p>\n\n<!-- Another technique that Jim brings up in his article is to promote observer events into mediated events, which gives you the both of both worlds. He has some nice examples showing how that could look. I encourage you to take a look at his article referenced below in bold. -->\n\n\n<p>Jim 在他的文章中提出的另一项技术是提升观察者事件为中介事件，这样可以两全其美。他展示了一些很棒的例子。我推荐你去看看他的文章，在下面的参考资料中用粗体标记了出来。</p>\n\n<!-- ## Additional Resources -->\n\n\n<h2>附加资源</h2>\n\n<!-- If you are interesting in more information about the above concepts you may consider looking through some of the following resources about events and messaging.  -->\n\n\n<p>如果你想了解上述概念的更多信息，读读下面关于事件和消息的资源。</p>\n\n<ul>\n<li><strong>Jim Cowart's (<a href=\"http://twitter.com/ifandelse\">@ifandelse</a>) <a href=\"http://freshbrewedcode.com/jimcowart/2013/02/07/client-side-messaging-essentials/\">Client-side Messaging Essentials</a> article</strong></li>\n<li>Addy Osmani's (<a href=\"http://twitter.com/addyosmani\">@addyosmani</a>) <a href=\"http://msdn.microsoft.com/en-us/magazine/hh201955.aspx\">Understanding the Publish/Subscribe Pattern for Greater JavaScript Scalability</a> article</li>\n<li>Rebecca Murphey's (<a href=\"http://twitter.com/rmurphey\">@rmurphey</a>) <a href=\"http://net.tutsplus.com/tutorials/javascript-ajax/loose-coupling-with-the-pubsub-plugin/\">Loose Coupling with the pubsub Plugin</a> screencast</li>\n</ul>\n\n\n<!-- ## Loosely Coupled Code -->\n\n\n<h2>松耦合代码</h2>\n\n<!-- I was tempted to write the following code using Backbone.js or create constructor functions, but in order to keep it simple and convey the idea of messaging I tried to remove all of that. So, this probably isn't what you'd have in your code-base, but hopefully it gets the point across.  -->\n\n\n<p>我原打算用 Backbone.js 或构造函数来编写下面的代码，但是为了保持简单和表达消息的理念，我把它们都移除了。因此，虽然这可能不是实际代码库的代码，但我还是希望能表达的清楚些。</p>\n\n<p>  <script src=\"https://gist.github.com/elijahmanor/5235011.js?file=loosely-coupled.js\">\n  </script></p>\n\n<!-- ## Attack! -->\n\n\n<h2>攻击！</h2>\n\n<p>下面是一个用 <a href=\"http://incompl.github.com/boxbox/\">boxbox</a> 构建的简版 Angry Birds，boxbox 是一个用于 <a href=\"https://code.google.com/p/box2dweb/\">box2dweb</a> 的框架，由 <a href=\"http://bocoup.com\">Bocoup</a> 的 <a href=\"http://twitter.com/_gsmith\">Greg Smith</a> 编写。</p>\n\n<!-- > Press the `space bar` to launch the Red Bird and you can also use the arrow keys. If it takes you too long to destroy the pigs you might want to consider pressing the `space bar` several times ;) -->\n\n\n<blockquote><p>按下<code>空格键</code>来发射蓝色小鸟，你也可以使用方向键。如果花了很长时间也不能摧毁猪群，那么你可能要考虑多按几次<code>空格键</code>了 ;)</p></blockquote>\n\n<p><a href=\"http://jsfiddle.net/Gue8x/show\" imageanchor=\"1\" style=\"margin-left: 1em; margin-right: 1em;\" target=\"_blank\">\n  <img border=\"0\" src=\"http://4.bp.blogspot.com/-PRXEAO-ZYuM/UVPOS_7QrnI/AAAAAAAAYoQ/VntWqZzDWeI/s1600/Screenshot+on+3.27.2013+at+11.56.39+PM.png\" />\n</a></p>\n\n<!-- ## Conclusion -->\n\n\n<h2>结论</h2>\n\n<!-- Using events and messages across your web application can help with communication. Events allow a component to communicate with itself and messages can enable other components to listen in without having a hard dependency. -->\n\n\n<p>在 Web 应用中可以使用事件和消息实现组件通信。事件允许一个组件同自身通信，消息则允许一个组件以非硬编码的方式监听其他组件。</p>\n\n<!-- There are many other front-end architecture techniques that have been stolen by the pigs. Tune in next time as the next Angry Bird takes its revenge! Dun, dun, daaaaaaa! -->\n\n\n<p>还有许多其他的前端架构技术被猪群偷走了。在下篇文章中，另一只愤怒的小鸟将继续复仇！Dun, dun, daaaaaaa!</p>\n\n<blockquote><p><a href=\"http://nuysoft.com/2013/04/21/angry-birds-of-javascript-orange-bird-templating/#comment-881925473\">@sunnylost</a> 补充：Dun, dun, daaaaaaaaaa! 应该是在模拟背景音乐，类似于这种 <a href=\"http://missingno.ocremix.org/musicpages/game_on.html\">http://missingno.ocremix.org/musicpages/game_on.html</a></p></blockquote>\n"
            ],
            "link": [
              "http://nuysoft.github.com/2013/04/20/angry-birds-of-javascript-blue-bird-events"
            ],
            "guid": [
              "http://nuysoft.github.com/2013/04/20/angry-birds-of-javascript-blue-bird-events"
            ],
            "pubDate": [
              "2013-04-20T00:00:00-07:00"
            ]
          },
          {
            "title": [
              "自动化"
            ],
            "description": [
              "<blockquote><p>原文：<a href=\"http://www.elijahmanor.com/2013/04/angry-birds-of-javascript-mighty-eagle.html\">Angry Birds of JavaScript: Mighty Eagle - Automation</a></p></blockquote>\n\n<!-- ## Introduction -->\n\n\n<h2>简介</h2>\n\n<p><img src=\"http://2.bp.blogspot.com/-N7kG4eOFXzA/UWED8Hv6eiI/AAAAAAAAZ2g/bzakzkoKQgc/s1600/Angry-Birds-for-iOS-Mighty-Eagle-screenshot.png\" alt=\"\" /></p>\n\n<!-- ![](http://2.bp.blogspot.com/-N7kG4eOFXzA/UWED8Hv6eiI/AAAAAAAAZ2g/bzakzkoKQgc/s400/Angry-Birds-for-iOS-Mighty-Eagle-screenshot.png) -->\n\n\n\n\n<!-- A diabolical herd of pigs stole all of the front-end architecture from an innocent flock of birds and now they want it back! A team of special agent hero birds will attack those despicable pigs until they recover what is rightfully theirs, front-end JavaScript architecture! -->\n\n\n<p>一群无法无天的猪从无辜的小鸟那里偷走了所有的前端架构，现在小鸟们要把它们夺回来！一队特殊的小鸟英雄将攻击这些卑鄙的猪，直到夺回原本属于它们的前端 JavaScript 架构！</p>\n\n<!-- Will the birds be successful in the end? Will they defeat their bacon flavored foe? Let's find out together in another nail biting episode of Angry Birds of JavaScript! -->\n\n\n<p>小鸟们最终会成功吗？它们会打败那些培根味儿的敌人吗？让我们一起揭示 JavaScript 之愤怒的小鸟系列的另一个扣人心弦的章节！</p>\n\n<blockquote><p>译注：翻译“bacon flavored foe”时，想起来了《少林足球》里的“做人如果没有梦想，那跟咸鱼有什么区别？”，就翻译成了“咸猪敌人”，<a href=\"http://nuysoft.com/2013/04/21/angry-birds-of-javascript-orange-bird-templating/#comment-881925473\">@sunnylost</a> 建议翻译为“培根味儿的敌人”，应该更准确和有趣些。</p></blockquote>\n\n<!-- > Check out the **[series introduction post]** for a list of all the birds and their attack powers. -->\n\n\n<blockquote><p>阅读<strong><a href=\"http://www.elijahmanor.com/2013/03/angry-birds-of-javascript-series.html\">系列介绍文章</a></strong>，查看所有小鸟以及它们的攻击力。</p></blockquote>\n\n<!-- ### Previous Attacks -->\n\n\n<h3>战报</h3>\n\n<ul>\n<li><a href=\"http://www.elijahmanor.com/2013/03/angry-birds-of-javascript-red-bird.html\">Red Bird - IIFE</a></li>\n<li><a href=\"http://www.elijahmanor.com/2013/03/angry-birds-of-javascript-blue-bird.html\">Blue Bird - Events</a></li>\n<li><a href=\"http://www.elijahmanor.com/2013/04/angry-birds-of-javascript-yellow-bird.html\">Yellow Bird - RequireJS</a></li>\n<li><a href=\"http://www.elijahmanor.com/2013/04/angry-birds-of-javascript-black-bird.html\">Black Bird - Backbone</a></li>\n<li><a href=\"http://www.elijahmanor.com/2013/04/angry-birds-of-javascript-white-bird.html\">White Bird - Linting</a></li>\n<li><a href=\"http://www.elijahmanor.com/2013/04/angry-birds-of-javascript-green-bird.html\">Green Bird - Mocking</a></li>\n<li><a href=\"http://www.elijahmanor.com/2013/04/angry-birds-of-javascript-orange-bird.html\">Orange Bird - Templating</a></li>\n<li><a href=\"http://www.elijahmanor.com/2013/04/angry-birds-of-javascript-big-brother.html\">Big Brother Bird - Patterns</a></li>\n</ul>\n\n\n<!-- ### Mighty Eagle Bird Attacks -->\n\n\n<h3>神鹰的攻击</h3>\n\n<!-- ![](http://4.bp.blogspot.com/-9CHfr07ovWs/UWEETqEvgSI/AAAAAAAAZ2w/baqRjP09l1c/s1600/angrybirds-eagle.png) -->\n\n\n<p><img src=\"http://4.bp.blogspot.com/-9CHfr07ovWs/UWEETqEvgSI/AAAAAAAAZ2w/baqRjP09l1c/s320/angrybirds-eagle.png\" alt=\"\" /></p>\n\n<!-- In this post we will take a look at the Mightly Eagle who uses the most superior weapon of them all, a suite of tools that can organize and deploy all the other birds into battle against their soon to be vanquished foe. Slowly, one by one, the birds will take back what it theirs to keep! -->\n\n\n<p>在这篇文章中，我们将看看使用超级武器的神鹰，它用一套工具快速组织和部署其他小鸟到征服猪群的战斗中。渐渐的，小鸟们将一个接一个的夺回属于它们的东西！</p>\n\n<!-- ## What Was Stolen by the Pigs? -->\n\n\n<h2>猪偷走了什么？</h2>\n\n<!-- Over time the birds picked up RequireJS (Yellow Bird), JSHint (White Bird), Plato, Mustache (Orange Bird), and a bunch of other great tools, but all of them required a command line task to complete. It was getting quite annoying having to remember what was required to run each of these tools. In addition, it was easy to forget to run the tools to update their web application when necessary. Thankfully one day the Mighty Eagle introduced some tools to make things a little bit easier. The Eagle brought Grunt and Bowser to automate common tasks and to help easily bring in commonly used libraries that were necessary to e their applications.   -->\n\n\n<p>随着时间的推移，小鸟们拿出了 RequireJS（黄鸟）、JSHint（白鸟）、Mustache（橙鸟）以及一堆其他伟大的工具，然后所有任务都需要一个命令行任务来完成。这很烦人，因为你不得不记住运行每个工具所需的事情。此外，很容易在关键时刻时忘记运行这些工具来更新 Web 应用。值得庆幸的是，有一天神鹰引入了一些工具让事情变得稍微容易一些。神鹰用 Grunt 和 Bowser 自动执行常见任务，并让项目可以很容易的引入必需的常用库。</p>\n\n<p>However, during a recent invasion the pigs stole the birds' Gang of Foul book! As a result, one of the Big Brother Birds has been tasked to reclaim what has been stolen. He will use his overwhelming power of trickery to help destroy the pigs in order to take back what is theirs.</p>\n\n<blockquote><p>译注：这段原文应该有错误，本文介绍的是神鹰的自动化工具，不是大鸟哥的设计模式和有限自动机，因此暂不翻译。</p></blockquote>\n\n<h2>Grunt</h2>\n\n<p><img src=\"http://3.bp.blogspot.com/-CXGuzyWVyk8/UWELb7hUEQI/AAAAAAAAZ3g/joO4tCJ_eyc/s1600/toolset+2.png\" alt=\"\" />\n<img src=\"http://3.bp.blogspot.com/-CXGuzyWVyk8/UWELb7hUEQI/AAAAAAAAZ3g/joO4tCJ_eyc/s200/toolset+2.png\" alt=\"\" /></p>\n\n<!-- Grunt is a task-based command line tool that is written in JavaScript and helps automate the build of your front-end application. The community has really grabbed on to this tool and as a result there are tons of plugins that you can choose from to automate things like CoffeeScript, handlebars precompilation, less support, JSHint checking, etc... -->\n\n\n<p>Grunt 是一个基于任务的命令行工具，用 JavaScript 语言编写，用于自动执行前端应用的构建过程。社区被这个工具深深吸引，并产出了大量插件可供选择，例如自动化 CoffeeScript 编译、Handlebars 预编译、Less 支持、JSHint 检查等等...</p>\n\n<!-- Several really large projects already use Grunt to assist their builds and other automation tasks such as Twitter, jQuery, Modernizr, Sauce Labs, and others. -->\n\n\n<p>事实上已经有几个大型项目在使用 Grunt 辅助自动执行构建过程以及其他任务，例如 Twitter、jQuery、Modernizr、Sauce Labs 等。</p>\n\n<!-- ### Getting Started -->\n\n\n<h3>入门指南</h3>\n\n<!-- In order to get started you just need to install grunt from node with the following command... -->\n\n\n<p>首选，你需要在 node 中用下面的命令安装 Grunt...</p>\n\n<p>  <script src=\"https://gist.github.com/elijahmanor/5331806.js?file=grunt-install.sh\">\n  </script></p>\n\n<!-- Once you've installed grunt you'll need 2 main things for each of your projects -->\n\n\n<p>安装 Grun 之后，每个项目需要两个主要的文件：</p>\n\n<ul>\n<li>Gruntfile.js</li>\n<li>package.json</li>\n</ul>\n\n\n<h4>Gruntfile.js</h4>\n\n<!-- You can create your own `Gruntfile.js` from scratch, you can copy a starter Gruntfile.js from the documentation, or there is a use a `grunt-init gruntfile` project scaffold. To install the scaffold follow the instructions from Grunt's [Project Scaffolding](http://gruntjs.com/project-scaffolding) page. The following Gruntfile.js is an example from Grunt's [Get Started](http://gruntjs.com/getting-started) page... -->\n\n\n<p>你可以从头创建自己的 <code>Gruntfile.js</code>，也可以从文件中拷贝一份初始 Gruntfile.js，或者使用项目脚手架 <code>grunt-init gruntfile</code>。如何安装脚手架请参阅 Grunt 的<a href=\"http://gruntjs.com/project-scaffolding\">项目脚手架</a>页面的介绍。下面的 Gruntfile.js 示例来自 Grunt 的<a href=\"http://gruntjs.com/getting-started\">入门指南</a>页面...</p>\n\n<p>  <script src=\"https://gist.github.com/elijahmanor/5331806.js?file=Gruntfile.js\">\n  </script></p>\n\n<h4>package.json</h4>\n\n<!-- The `package.json` describes your project's name, version, and any dependencies it might have such as grunt and any grunt plugins. You can copy an example package.json from the Grunt's [Get Started](http://gruntjs.com/getting-started) page... (see below) -->\n\n\n<p><code>package.json</code> 描述了项目名称、版本，以及可能有的依赖，例如 Grunt 和 Grunt 插件。你可以从 Grunt 的<a href=\"http://gruntjs.com/getting-started\">入门指南</a>页面拷贝一份 package.json 示例...（如下所示）</p>\n\n<p>  <script src=\"https://gist.github.com/elijahmanor/5331806.js?file=package.json\">\n  </script></p>\n\n<!-- #### Grunt Plugins -->\n\n\n<h4>Grunt 插件</h4>\n\n<!-- Now that hopefully everything is setup, you can start using a whole suite of plugins to automate tasks. Here are a few interesting ones that you might enjoy... -->\n\n\n<p>现在一切就绪，你可以使用一整套插件开始自动执行任务。这里有几个有趣的插件，你可以会喜欢...</p>\n\n<ul>\n<li>grunt-contrib-coffee - 把 CoffeeScript 编译为 JavaScript</li>\n</ul>\n\n\n<!-- Compile CoffeeScript files into JavaScript -->\n\n\n<ul>\n<li>grunt-contrib-compass - 把 Compass 编译为 CSS</li>\n</ul>\n\n\n<!-- Compile Compass into CSS -->\n\n\n<ul>\n<li>grunt-contrib-concat - 合并文件</li>\n</ul>\n\n\n<!-- Concatenates files -->\n\n\n<ul>\n<li>grunt-contrib-connect - 启动一个 Web 服务</li>\n</ul>\n\n\n<!-- Starts a connect web server -->\n\n\n<ul>\n<li>grunt-contrib-csslint - 检查 CSS 文件</li>\n</ul>\n\n\n<!-- Lints your CSS files -->\n\n\n<ul>\n<li>grunt-contrib-handlebars - 预编译 Handlebar 模板</li>\n</ul>\n\n\n<!-- Precompiles your Handlebar tempaltes -->\n\n\n<ul>\n<li>grunt-contrib-htmlmin - 压缩 HTML 代码</li>\n</ul>\n\n\n<!-- Minify your HTML markup -->\n\n\n<ul>\n<li>grunt-contrib-imagemin - 演说 PNG 和 JPEG 图片</li>\n</ul>\n\n\n<!-- Minify PNG and JPEG images -->\n\n\n<ul>\n<li>grunt-contrib-jshint - 用 JSHint 检查文件</li>\n</ul>\n\n\n<!-- Validate files with JSHint -->\n\n\n<ul>\n<li>grunt-contrib-less - 把 LESS 编译为 CSS</li>\n</ul>\n\n\n<!-- Compile LESS to CSS -->\n\n\n<ul>\n<li>grunt-contrib-nodeunit - 运行 Nodeunit 单元测试</li>\n</ul>\n\n\n<!-- Run Nodeunit unit test -->\n\n\n<ul>\n<li>grunt-contrib-watch - 当文件发生变化时运行与定义任务</li>\n</ul>\n\n\n<!-- Run predefined tasks when files change -->\n\n\n<ul>\n<li>grunt-contrib-requirejs - 使用 r.js 优化 RequireJS 项目</li>\n</ul>\n\n\n<!-- Optimize RequireJS projects using r.js -->\n\n\n<ul>\n<li>grunt-contrib-uglify - 用 UglifyJS 压缩文件</li>\n</ul>\n\n\n<!-- Minify files with UglifyJS -->\n\n\n<ul>\n<li>grunt-contrib-yuidoc - 编译 YUIDocs 文档</li>\n</ul>\n\n\n<!-- Compile YUIDocs Documentation -->\n\n\n<ul>\n<li>... more ...</li>\n</ul>\n\n\n<!-- #### jQuery's Gruntfile -->\n\n\n<h4>jQuery 的 Gruntfile</h4>\n\n<!-- I pulled down jQuery from their GitHub repository to see how they use Grunt and the following is the output when get when executing the tool.  -->\n\n\n<p>我从 GitHub 上拉去了一份 jQuery，用来查看 jQuery 是如何使用 Grunt 的，下面是执行 Grunt 时得到的输出。</p>\n\n<p><img src=\"http://2.bp.blogspot.com/-qdV01Mu1uO4/UWJLrncu2WI/AAAAAAAAZ4A/bges3xKOJ_o/s1600/grunt-jquery.png\" alt=\"\" /></p>\n\n<!-- ![](http://2.bp.blogspot.com/-qdV01Mu1uO4/UWJLrncu2WI/AAAAAAAAZ4A/bges3xKOJ_o/s640/grunt-jquery.png) -->\n\n\n<p>If you look closely you'll notice they update their git submodules, build a version of jQuery from it's modules, run JSHint against the built jquery.js and tests files, creates sourcemaps, and runs a special compare file size task. If you dig deep into their Gruntfile you'll find they've also setup a custom way to run their unit tests against Browserstack, which is pretty cool if you ask me ;)\n如果你仔细上面的图看会发现执行了以下任务：更新 Git 子模块（Sizzle、QUnit），构建 jQuery 的一个版本，对构建的 jquery.js 执行 JSHint 检查，创建 Source Maps，并运行一个比较指定的文件大小的任务。如果你深挖 Gruntfile.js 的话，你还会发现它自定义了一种不同于 Browserstack 的方式来运行单元测试。</p>\n\n<blockquote><p>译注：<a href=\"http://www.ruanyifeng.com/blog/2013/01/javascript_source_map.html\">JavaScript Source Map 详解</a>, <a href=\"https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.1ce2c87bpj24\">Source Map Revision 3 Proposal</a>, <a href=\"http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/\">Introduction to JavaScript Source Maps</a>, <a href=\"http://www.browserstack.com/\">BrowserStack</a></p></blockquote>\n\n<!-- #### Modernizr's Gruntfile -->\n\n\n<h4>Modernizr 的 Gruntfile</h4>\n\n<!-- In the same way I pulled down the Modernizr repository and typed `grunt qunit` to watch their 746 unit tests execute and pass in 369ms using the PhantomJS headless browser! -->\n\n\n<p>我用同样的方式拉取了 Modernizr 库，然后输入 <code>grunt qunit</code> 观察它的 746 项单元测试的测试过程，并在 369ms 内测试通过，测试使用了无界面的浏览器引擎 PhantomJS。</p>\n\n<blockquote><p>译注：<a href=\"http://phantomjs.org/\">PhantomJS</a>, <a href=\"http://www.cnblogs.com/ziyunfei/archive/2012/09/28/2706061.html\">PhantomJS 中文主页</a></p></blockquote>\n\n<p><img src=\"http://1.bp.blogspot.com/-XvfSNrxCTMQ/UWJLxIfNMPI/AAAAAAAAZ4M/AXAjvelHjZQ/s1600/grunt-modernizr.png\" alt=\"\" /></p>\n\n<!-- ![](http://1.bp.blogspot.com/-XvfSNrxCTMQ/UWJLxIfNMPI/AAAAAAAAZ4M/AXAjvelHjZQ/s640/grunt-modernizr.png) -->\n\n\n\n\n<!-- ### Grunt Resources -->\n\n\n<h3>Grunt 资源</h3>\n\n<!-- The intent of this post wasn't to teach you all there is to know about Grunt, but to make you aware of it if you didn't know already. It is a very nice tool to help you automatic ALL THE front-end THINGS. Check out the following resources to help you unpack how to get started... -->\n\n\n<p>这篇文章的目的不是教你了解 Grunt，而是为了让你意识到它的存在，如果你还不知道的话。这个一个非常棒的工具，用来帮助你自动化所有前端事务。参阅下面的资源，可以帮助你理解如何开始...</p>\n\n<blockquote><p>译注：知其意而不能言其意，汗颜呐。</p></blockquote>\n\n<ul>\n<li><a href=\"http://www.youtube.com/watch?v=q3Sqljpr-Vc\">The Grunt Basics</a> by Cary Landholt (<a href=\"http://twitter.com/carylandholt\">@carylandholt</a>)</li>\n<li><a href=\"http://merrickchristensen.com/articles/gruntjs-workflow.html\">Grunt.js Workflow</a> by Merrick Christensen (<a href=\"http://twitter.com/iammerrick\">@iammerrick</a>)</li>\n<li><a href=\"http://net.tutsplus.com/tutorials/javascript-ajax/meeting-grunt-the-build-tool-for-javascript/\">Meet Grunt: The Build Tool for JavavScript</a> by Andrew Burgess (<a href=\"http://twitter.com/andrew8088\">@andrew8088</a>)</li>\n</ul>\n\n\n<h2>Twitter Bower</h2>\n\n<blockquote><p>译注：bower - 凉亭，树阴处</p></blockquote>\n\n<p><img src=\"http://1.bp.blogspot.com/-L7pXsxuBnVA/UWELyS9lG0I/AAAAAAAAZ3w/ptGkkE9j1ms/s1600/toolset+3.png\" alt=\"\" />\n<img src=\"http://1.bp.blogspot.com/-L7pXsxuBnVA/UWELyS9lG0I/AAAAAAAAZ3w/ptGkkE9j1ms/s200/toolset+3.png\" alt=\"\" /></p>\n\n<!-- For those of you that have used Node or Ruby you'll be familiar with npm or gems, however, there hasn't been anything like that for front-end browser scripts and styles... at least until now!  -->\n\n\n<p>使用 Node 或 Ruby 的开发人员可能已经熟悉了 npm 或 gems，但是对于浏览器脚本和样式没有类似的工具...至少到目前为止！</p>\n\n<!-- The Twitter Bower project seeks to solve that problem by providing a package manager for the web (HTML, CSS, and JavaScript).  -->\n\n\n<p>Twitter Bower 项目旨在通过 Web（HTML、CSS 和 JavaScript）提供一套包管理器来解决这个问题。</p>\n\n<p>  <script src=\"https://gist.github.com/elijahmanor/5331806.js?file=bower-install.sh\">\n  </script></p>\n\n<!-- Once you've installed bowser, then you can start downloading libraries! For example, if we wanted to pull down the latest version of jQuery we could just `bower install jquery` and you'll see the following... -->\n\n\n<p>安装 Bower 之后你就可以开始下载库！，例如，我们想拉去最新版本的 jQuery，只需要运行 <code>bower install jquery</code>，然后你会看到下面的输出...</p>\n\n<p><a href=\"http://3.bp.blogspot.com/-s8ERF-X_x70/UWLBuSeWcpI/AAAAAAAAZ4Y/uWUIb5eWuLg/s1600/bower-install-jquery.png\"><img src=\"http://3.bp.blogspot.com/-s8ERF-X_x70/UWLBuSeWcpI/AAAAAAAAZ4Y/uWUIb5eWuLg/s640/bower-install-jquery.png\" alt=\"\" /></a></p>\n\n<!-- ### Bower Resources -->\n\n\n<h3>Bower 资源</h3>\n\n<!-- If you want to find out more about bower then I encourage you to check out some of the nice resources below. -->\n\n\n<p>如果想更多的了解 Bower，建议去看看下面的这些好资源。</p>\n\n<ul>\n<li><a href=\"http://net.tutsplus.com/tutorials/tools-and-tips/meet-bower-a-package-manager-for-the-web/\">Meet Bower: A Package Manager For The Web</a> by Andrew Burgess (<a href=\"http://twitter.com/andrew8088\">@andrew8088</a>)</li>\n<li><a href=\"http://net.tutsplus.com/tutorials/javascript-ajax/a-requirejs-backbone-and-bower-starter-template/\">A RequireJS, Backbone, and Bower Starter Template</a> by Jeffrey Way (<a href=\"http://twitter.com/jeffrey_way\">@jeffrey_way</a>)</li>\n</ul>\n\n\n<h2>Yeoman</h2>\n\n<blockquote><p>译注：yeoman -  自耕农，自由民，仆人</p></blockquote>\n\n<p><img src=\"http://3.bp.blogspot.com/-Rp0_He-oQgI/UWELh24_5kI/AAAAAAAAZ3o/J8F2Jj_LV4w/s1600/toolset+1.png\" alt=\"\" />\n<img src=\"http://3.bp.blogspot.com/-Rp0_He-oQgI/UWELh24_5kI/AAAAAAAAZ3o/J8F2Jj_LV4w/s200/toolset+1.png\" alt=\"\" /></p>\n\n<!-- The yeoman project is a scaffolding engine that works along with Grunt and Bower. You can think of yeoman as the scaffolding piece that can get your applications going quickly. In order to get started you need to install yeoman by using the following syntax... -->\n\n\n<p>Yeoman 项目是一款与 Grunt 和 Bower 协同工作的脚手架引擎。可以让你的应用快速运行起来。要使用 Yeoman，你需要先用下面的语法安装它...</p>\n\n<p>  <script src=\"https://gist.github.com/elijahmanor/5331806.js?file=yo-install.sh\">\n  </script></p>\n\n<!-- Once yeoman is installed then you can generate a variety of different types of projects. In the following screenshot I asked yeoman to create a new webapp. It will ask me several questions along the way to tailor the application to my needs. -->\n\n\n<p>Yeoman 安装之后，你可以生成各种不同类型的项目。在下面的的截图中，我用 Yeoman 创建了一个 Web 应用。在按我的需求订制应用的过程中，它会问几个问题。</p>\n\n<p><a href=\"http://1.bp.blogspot.com/-hgpccVDN7Gg/UWLB_oM2gWI/AAAAAAAAZ4g/_XFTx_MJsTw/s1600/yo-webapp.png\"><img src=\"http://1.bp.blogspot.com/-hgpccVDN7Gg/UWLB_oM2gWI/AAAAAAAAZ4g/_XFTx_MJsTw/s640/yo-webapp.png\" alt=\"\" /></a></p>\n\n<!-- There are other scaffolds such as [Backbone](https://github.com/yeoman/generator-backbone), [AngularJS](https://github.com/yeoman/generator-angular), etc... that you can install and get your project underway. You can view a list of [more generators](https://github.com/yeoman) from the Yeoman GitHub page. -->\n\n\n<p>还有其他的脚手架，例如 <a href=\"https://github.com/yeoman/generator-backbone\">Backbone</a>、<a href=\"https://github.com/yeoman/generator-angular\">AngularJS</a> 等，你可以安装它们，然后开始你的项目。可以在 Yeoman 的 GitHub 页面看到<a href=\"https://github.com/yeoman\">更多的生成器</a>列表。</p>\n\n<!-- For example in the following screenshots I first create a new Backbone app and then immediately create a new `bird` model. -->\n\n\n<p>例如在下面的截图中，我先创建了一个新的 Backbone 应用，然后立即创建了一个新的 <code>bird</code> 模型。</p>\n\n<p><a href=\"http://2.bp.blogspot.com/-WADbKLpIFUA/UWLSpw7ya6I/AAAAAAAAZ4w/QrqLbXZ8AD8/s1600/yo-backbone-app.png\"><img src=\"http://2.bp.blogspot.com/-WADbKLpIFUA/UWLSpw7ya6I/AAAAAAAAZ4w/QrqLbXZ8AD8/s640/yo-backbone-app.png\" alt=\"\" /></a>\n<a href=\"http://1.bp.blogspot.com/-RO_QnEkhVnw/UWLS_Y-HNBI/AAAAAAAAZ44/I7jZC_SJGZA/s1600/yo-backbone-model.png\"><img src=\"http://1.bp.blogspot.com/-RO_QnEkhVnw/UWLS_Y-HNBI/AAAAAAAAZ44/I7jZC_SJGZA/s640/yo-backbone-model.png\" alt=\"\" /></a></p>\n\n<!-- > Yeoman is currently 1.0 beta and the website says there are some issues with Windows. I've been able to use it to some extend, but I'm sure there are some features that aren't yet supported, but the plan is to have it fully supported. -->\n\n\n<blockquote><p>Yeoman 目前是 1.0 测试版，网站上说在 Windows 下有一些问题。虽然我已经能用它做一些扩展，但是我敢肯定有一些计划完全支持的功能尚不支持。</p></blockquote>\n\n<!-- ## Attack! -->\n\n\n<h2>攻击！</h2>\n\n<p>下面是一个用 <a href=\"http://incompl.github.com/boxbox/\">boxbox</a> 构建的简版 Angry Birds，boxbox 是一个用于 <a href=\"https://code.google.com/p/box2dweb/\">box2dweb</a> 的框架，由 <a href=\"http://bocoup.com\">Bocoup</a> 的 <a href=\"http://twitter.com/_gsmith\">Greg Smith</a> 编写。</p>\n\n<!-- > Press the `space bar` to launch the Mighty Eagle Bird and you can also use the arrow keys. -->\n\n\n<blockquote><p>按下<code>空格键</code>来发射神鹰，你也可以使用方向键。</p></blockquote>\n\n<p><a href=\"http://jsfiddle.net/GWDDv/show\"><img src=\"http://3.bp.blogspot.com/-KQKPPj6GV_I/UWEKCNFskjI/AAAAAAAAZ3A/eufuyrkvR2I/s1600/eagle-game.png\" alt=\"\" /></a></p>\n\n<!-- ## Conclusion -->\n\n\n<h2>结论</h2>\n\n<!-- Embracing Grunt, Bower, and Yeoman can help automate various parts of your development, testing, and deployment process. The community for these tools are very active and you can find plugins to help cater these to your application's needs.  -->\n\n\n<p>拥抱 Grunt、Bower 和 Yeoman 可以帮助自动化开发、测试、部署过程中的各个环节。这些工具的社区非常活跃，你可以在上面找到满足你应用需求的插件。</p>\n\n<!-- There is one more front-end architecture technique that has been stolen by the pigs. Tune in next time as the next Angry Bird takes its revenge! Dun, dun, daaaaaaa! -->\n\n\n<p>还有更多的前端架构技术被猪群偷走了。在下篇文章中，另一只愤怒的小鸟将继续复仇！Dun, dun, daaaaaaa!</p>\n\n<blockquote><p><a href=\"http://nuysoft.com/2013/04/21/angry-birds-of-javascript-orange-bird-templating/#comment-881925473\">@sunnylost</a> 补充：Dun, dun, daaaaaaaaaa! 应该是在模拟背景音乐，类似于这种 <a href=\"http://missingno.ocremix.org/musicpages/game_on.html\">http://missingno.ocremix.org/musicpages/game_on.html</a></p></blockquote>\n"
            ],
            "link": [
              "http://nuysoft.github.com/2013/04/19/angry-birds-of-javascript-mighty-eagle-automation"
            ],
            "guid": [
              "http://nuysoft.github.com/2013/04/19/angry-birds-of-javascript-mighty-eagle-automation"
            ],
            "pubDate": [
              "2013-04-19T00:00:00-07:00"
            ]
          },
          {
            "title": [
              "代码质量"
            ],
            "description": [
              "<blockquote><p>原文：<a href=\"http://www.elijahmanor.com/2013/04/angry-birds-of-javascript-white-bird.html\">Angry Birds of JavaScript: White Bird Linting</a></p>\n\n<p>私货：<a href=\"https://github.com/nuysoft/Aristotle\">nuysoft/Aristotle</a></p></blockquote>\n\n<!-- ## Introduction -->\n\n\n<h2>简介</h2>\n\n<p><img src=\"http://4.bp.blogspot.com/-hbs_feLNzNE/UVx7DKXG-cI/AAAAAAAAZug/vDk6cFJ7Jgk/s1600/angry_birds_wall_decal_by_graphicwolf-d4fwzrc.jpg\" alt=\"\" /></p>\n\n<!-- ![](http://4.bp.blogspot.com/-hbs_feLNzNE/UVx7DKXG-cI/AAAAAAAAZug/vDk6cFJ7Jgk/s400/angry_birds_wall_decal_by_graphicwolf-d4fwzrc.jpg) -->\n\n\n\n\n<!-- A diabolical herd of pigs stole all of the front-end architecture from an innocent flock of birds and now they want it back! A team of special agent hero birds will attack those despicable pigs until they recover what is rightfully theirs, front-end JavaScript architecture! -->\n\n\n<p>一群无法无天的猪从无辜的小鸟那里偷走了所有的前端架构，现在小鸟们要把它们夺回来！一队特殊的小鸟英雄将攻击这些卑鄙的猪，直到夺回原本属于它们的前端 JavaScript 架构！</p>\n\n<p>Will the birds be successful in the end? Will they defeat their bacon flavored foe? Let's find out together in another nail biting episode of Angry Birds of JavaScript!\n小鸟们最终会成功吗？它们会打败那些培根味儿的敌人吗？让我们一起揭示 JavaScript 之愤怒的小鸟系列的另一个扣人心弦的章节！</p>\n\n<blockquote><p>译注：翻译“bacon flavored foe”时，想起来了《少林足球》里的“做人如果没有梦想，那跟咸鱼有什么区别？”，就翻译成了“咸猪敌人”，<a href=\"http://nuysoft.com/2013/04/21/angry-birds-of-javascript-orange-bird-templating/#comment-881925473\">@sunnylost</a> 建议翻译为“培根味儿的敌人”，应该更准确和有趣些。</p></blockquote>\n\n<!-- > Check out the [series introduction post] for a list of all the birds and their attack powers. -->\n\n\n<blockquote><p>阅读<strong><a href=\"http://www.elijahmanor.com/2013/03/angry-birds-of-javascript-series.html\">系列介绍文章</a></strong>，查看所有小鸟以及它们的攻击力。</p></blockquote>\n\n<!-- ![](http://3.bp.blogspot.com/-c3JawpCl3ys/UVx7L_dMWxI/AAAAAAAAZuo/YEClyACJaZg/s1600/white-bird.png) -->\n\n\n<p><img src=\"http://3.bp.blogspot.com/-c3JawpCl3ys/UVx7L_dMWxI/AAAAAAAAZuo/YEClyACJaZg/s1600/white-bird.png\" alt=\"\" /></p>\n\n<!-- ### Previous Attacks -->\n\n\n<h3>战报</h3>\n\n<ul>\n<li><a href=\"http://www.elijahmanor.com/2013/03/angry-birds-of-javascript-red-bird.html\">Red Bird - IIFE</a></li>\n<li><a href=\"http://www.elijahmanor.com/2013/03/angry-birds-of-javascript-blue-bird.html\">Blue Bird - Events</a></li>\n<li><a href=\"http://www.elijahmanor.com/2013/04/angry-birds-of-javascript-yellow-bird.html\">Yellow Bird - RequireJS</a></li>\n<li><a href=\"http://www.elijahmanor.com/2013/04/angry-birds-of-javascript-yellow-bird.html\">Black Bird - Backbone</a></li>\n</ul>\n\n\n<!-- ### White Bird Attacks -->\n\n\n<h3>白鸟的攻击</h3>\n\n<!-- In this post we will take a look at the White Bird who appears to be seemingly harmless, but when it pulls out it's strict coding style and bursts of quality checks the hogs are sure to squeal. Slowly, one by one, the birds will take back what it theirs to keep! -->\n\n\n<p>在这篇文章中，我们将看看白鸟，它看似无害，但当它祭出严格编码风格和质量突击检查时，猪群无疑要开始尖叫了。渐渐的，小鸟们将一个接一个地夺回属于它们的东西。</p>\n\n<!-- ## What Was Stolen by the Pigs? -->\n\n\n<h2>猪偷走了什么？</h2>\n\n<!-- The birds all learned how to program in a slightly different way. Some birds were self-taught and some birds went to college for computer science. Even among those groups there were a wide range of experiences and talent. When the birds got together to build their first large application it was a huge disaster. Each bird thought their coding standard was the \"right way\" and it started to become an issue. One day a wise White Bird came along and suggested that they come up with a common set of coding practices to follow. In addition, the White Bird introduced a few tools to help them conform to a standard and to help find issues and concerns early before they became a huge issue later. -->\n\n\n<p>小鸟们学习如何编程的方式略有不同。有些小鸟是自学成才，而有些小鸟则是上大学学习计算机科学。即使这些群体中不乏经验丰富和才华惊艳之才，但是当小鸟们聚在一起构建它们的第一个大型应用时，这变成了一场巨大的灾难。每个小鸟都认为它们的编码标准才是正确的方法，这种想法导致了问题和冲突。有一天出现了一只智慧的白鸟，它建议大家制定一套通用的编码实践并遵循它。此外，这只白鸟还引入了一些工具，来帮助大家确立标准和发现问题，并提前关注可能恶化的问题。</p>\n\n<!-- However, during a recent invasion the pigs stole the birds' coding standards document and their code quality tools! As a result, one of the White Birds has been tasked to reclaim what has been stolen. He will use his overwhelming power of quality to help destroy the pigs in order to take back what is theirs. -->\n\n\n<p>然而在最近的一次入侵中，猪群偷走了小鸟们的编码标准文档和代码质量工具！现在，一只白鸟被派去夺回被盗的文档和工具。它将用压倒性的质量之力摧毁猪群，夺回属于它们的东西。</p>\n\n<!-- ## JavaScript Coding Standards -->\n\n\n<h2>JavaScript 编码标准</h2>\n\n<!-- There are many coding standards out there to choose from. The most important thing is that you pick one and stick to it. If you are working with a team, they should also agree on some standard. If you can't find a standard you exactly agree on, then find one that is close and make some exceptions. -->\n\n\n<p>有很多编码标准可供选择。重要的是选择一个并坚持下去。如果是你在一个团队中，其他成员也应该在某些标准上达成一致意见。如果找不到大家都同意的标准，那么选择一个近似的，并允许有一些例外。</p>\n\n<!-- By doing so you'll find that... -->\n\n\n<p>通过这样做你会发现...</p>\n\n<!-- \nA developer will be able to make sense of other code more quickly\nMerges in your code repository won't be as awful\nHaving a standard will actually reduce defects\nThe codebase will feel more unified\nDisagreements about who is \"right\" will lessen\n... insert your benefit here ... \n-->\n\n\n<ul>\n<li>开发人员将能更块的理解其他人的代码</li>\n<li>合并代码库不再是一件可怕的事</li>\n<li>建立标准确实可以减少缺陷</li>\n<li>代码库更统一</li>\n<li>关于谁才是正确的分歧将减少</li>\n<li>...写下你发现的好处...</li>\n</ul>\n\n\n\n\n<!-- Here are some of the coding standards that I am aware of... -->\n\n\n<p>这里有一些我知道的编码标准...</p>\n\n<!-- * Douglas Crockford's [Code Conventions for the JavaScript Programming Language](http://javascript.crockford.com/code.html)\n* **Rich Waldron's ([@rwaldron](http://twitter.com/rwaldron)) [Idiomatic.js - Principles of Writing Consistent, Idiomatic JavaScript](https://github.com/rwldrn/idiomatic.js) &#8592; Recommended**\n* ** jQuery's [JavaScript Style Guide ](http://contribute.jquery.org/style-guide/js/?rdfrom=http%3A%2F%2Fdocs.jquery.com%2Fmw%2Findex.php%3Ftitle%3DJQuery_Core_Style_Guidelines%26redirect%3Dno) &#8592; Recommended**\n* Google's [JavaScript Style Guide](http://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml) -->\n\n\n<ul>\n<li>Douglas Crockford 的 <a href=\"http://javascript.crockford.com/code.html\">JavaScript 编程语言代码约定</a></li>\n<li><strong>Rich Waldron（<a href=\"http://twitter.com/rwaldron\">@rwaldron</a>）的 <a href=\"https://github.com/rwldrn/idiomatic.js\">Idiomatic.js - 通用一致的 JavaScript 编写原则</a> &#8592; 推荐</strong></li>\n<li><strong><a href=\"http://contribute.jquery.org/style-guide/js/?rdfrom=http%3A%2F%2Fdocs.jquery.com%2Fmw%2Findex.php%3Ftitle%3DJQuery_Core_Style_Guidelines%26redirect%3Dno\">jQuery 的 JavaScript 风格指南</a> &#8592; 推荐</strong></li>\n<li><a href=\"http://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml\">Google 的 JavaScript 风格指南</a></li>\n</ul>\n\n\n<!-- Addy Osmani ([@addyosmani](http://twitter.com/addyosmani)) has a nice post entitled [JavaScript Style Guides And Beautifiers](http://addyosmani.com/blog/javascript-style-guides-and-beautifiers/) that covers some of these styles in depth with examples showing how to abide by the standards recommended. -->\n\n\n<p>Addy Osmani 曾写过一篇很棒的文章 [JavaScript 风格指南和美化工具]，深入地阐述了各种代码风格，并用示例演示了如何遵守推荐的标准。</p>\n\n<h2>JavaScript Linting</h2>\n\n<!-- A linter is a tool that helps find errors and possible issues with your code. In many cases it can help enforce whatever coding standard you chose from the above list. -->\n\n\n<p>Linter 工具可以帮助查找代码中的错误和潜在问题。通常 Linter 还可以帮助你实施编码标准，无论你选择的是上述列表中的哪种编码标准。</p>\n\n<!-- There are actually several JavaScript linters out there, but the one I like the best is [JSHint](http://jshint.com/) created by Anton Kovalyov ([@valueof](http://twitter.com/valueof)). It grew out of a community effort to fork the popular JSLint library written by Douglas Crockford. I've enjoyed watching the project grow and see bugs and new features being added. JSHint has a lot of options that you can choose to opt-in or opt-out of which enables a team to figure out what works best for them. -->\n\n\n<p>实际上有几种 JavaScript Linter 可供选择，其中我最喜欢的是 Anton Kovalyov 创建的 <a href=\"http://jshint.com/\">JSHint</a>。JSHint 是社区共同努力的成果，前身是广受欢迎的 JSLint 库，由 Douglas Crockford 编写。关注这个项目的成长过程让我很享受。JSHint 有大量的选项，你可以选择开启或禁用，然后找出最适合团队的配置。</p>\n\n<!-- Some of the standard checks that JSHint can verify include... -->\n\n\n<p>JSHint 可以执行的标准检查包括...</p>\n\n<!-- * The use of `===` instead of `==`\n* Using variables that aren't defined\n* Declaring variables that are never used\n* Declaring functions inside of loops\n* And lots more... -->\n\n\n<ul>\n<li>用 <code>===</code> 代替 <code>==</code></li>\n<li>使用未定义的变量</li>\n<li>声明未使用的变量</li>\n<li>在循环中声明函数</li>\n<li>还有很多...</li>\n</ul>\n\n\n\n\n<!-- For a full list of options see the [JSHint Docs](http://jshint.com/docs/). -->\n\n\n<p>完整的选项列表请参阅 <a href=\"http://jshint.com/docs/\">JSHint 文档</a>。</p>\n\n<!-- Some of the more recent additions that I've really enjoyed include: -->\n\n\n<p>我很喜欢最近添加的一些选项，包括：</p>\n\n<!-- \n* `maxcomplexity` - Maximum cyclomatic complexity (see following Wikipedia quote)\n* `maxstatements` - Maximum number of statements allowed in a function\n* `maxparams` - Maximum number of parameter allowed in a function\n* `maxdepth` - Maximum depth allowed in a function\n* `maxlen` - Maximum length of line in code\n -->\n\n\n<ul>\n<li><code>maxcomplexity</code> - 最大循环复杂度（参见后面引用的维基百科）</li>\n<li><code>maxstatements</code> - 函数允许的语句条数最大值</li>\n<li><code>maxparams</code> - 函数允许的参数个数最大值</li>\n<li><code>maxdepth</code> - 函数允许的最大深度</li>\n<li><code>maxlen</code> - 单行代码的最大长度</li>\n</ul>\n\n\n<!-- > \"The cyclomatic complexity of a section of source code is the count of the number of linearly independent paths through the source code.\" -- [http://en.wikipedia.org/wiki/Cyclomatic_complexity](http://en.wikipedia.org/wiki/Cyclomatic_complexity) -->\n\n\n<blockquote><p>“一段代码的循环复杂度是指代码中线性独立路径的个数。” -- <a href=\"http://en.wikipedia.org/wiki/Cyclomatic_complexity\">http://en.wikipedia.org/wiki/Cyclomatic_complexity</a></p></blockquote>\n\n<p>  <script src=\"https://gist.github.com/elijahmanor/5307478.js?file=jshint.js\">\n  </script></p>\n\n<!-- The following errors are generated by JSHint after running it against the above code snippet. -->\n\n\n<p>JSHint 在检查上面的代码片段后生成下面的错误：</p>\n\n<p><img src=\"http://1.bp.blogspot.com/-Jj5KYftluoQ/UVz04mayIXI/AAAAAAAAZvQ/P9diYW0g8UE/s1600/4-3-2013+10-33-12+PM.png\" alt=\"\" /></p>\n\n<!-- ![](http://1.bp.blogspot.com/-Jj5KYftluoQ/UVz04mayIXI/AAAAAAAAZvQ/P9diYW0g8UE/s640/4-3-2013+10-33-12+PM.png) -->\n\n\n\n\n<!-- Thankfully you don't have to run JSHint from the website every time to check your code. There are several ways to integrate it into your code editor of choice: -->\n\n\n<p>幸运的是， 你不必每次都运行 JSHint 来检查整个网站的代码。有几种方式可以将 JSHint 集成到你的代码编辑器：</p>\n\n<ul>\n<li>VIM Plugin (<a href=\"https://github.com/walm/jshint.vim\">jshint.vim</a>)</li>\n<li>Sublime Text 2 Extension (<a href=\"https://github.com/Kronuz/SublimeLinter\">Sublime Linter</a>)</li>\n<li>TextMate Bundle (<a href=\"http://fgnass.posterous.com/jslint-in-textmate\">JSHint TextMate Bundle</a>)</li>\n<li>Visual Studio <a href=\"http://vswebessentials.com/\">Web Essentials</a></li>\n<li>Eclipse IDE (<a href=\"http://github.eclipsesource.com/jshint-eclipse/\">JSHint Integration</a>)</li>\n</ul>\n\n\n<!-- > In the Mighty Eagle post we'll talk about another way to use the JSHint from the command line and automatically. -->\n\n\n<blockquote><p>在无敌神鹰一文中，我们将谈论使用 JSHint 的另一种方式：命令行，以及如何使 JSHint 自动化。</p></blockquote>\n\n<h2>JavaScript Analysis</h2>\n\n<!-- Code linting is great, but sometimes it is nice to get a high level overview of your codebase and then be able to drill down and analyze small portions of your application. -->\n\n\n<p>代码 Linting 很棒，但有时我们希望能看到代码库的简要概览，并且可以深入分析代码的一小部分。</p>\n\n<!-- Thankfully there is a tool called [Plato](https://github.com/jsoverson/plato) that will analyse your code and provide a visual report where you can view the complexity of your application. The tool runs in Node and you can install it using `npm install plato -g`. -->\n\n\n<p>幸运的是有一个叫 <a href=\"https://github.com/jsoverson/plato\">Plato</a> 的工具可以分析你的代码，并提供可视化的报表，你可以通过报表浏览应用的复杂度。这个工具需要 Node 环境，通过 <code>npm install plato -g</code> 安装。</p>\n\n<blockquote><p>译注：Plato - 柏拉图（古希腊哲学家）。</p></blockquote>\n\n<!-- Once installed you can run the tool on the command line by `plato -r -d report myDirectory` , which will recursively analyse the code in the `myDirectory` folder and export the results to the `report` folder. -->\n\n\n<p>安装 Plato 之后，你可以在命令行中运行 <code>plato -r -d report myDirectory</code>，将递归分析 <code>myDirectory</code> 目录中的代码，并将结果导出到 <code>report</code> 目录。</p>\n\n<!-- If you were to run the report on the jQuery source code it would look much like the following report. As you can see, the average number of lines is decreasing over time, which is good. The maintainability is decent and then a breakdown of the maintainability of each JavaScript file is listed in a bar chart. Further down in the report there are a bar charts for Lines of code broken per file, Estimated errors per file, and also JSLint errors per file. -->\n\n\n<p>如果你在 jQuery 的源代码上运行 Plato，将生成类似下面的报告。正如你所见，平均代码行数随着时间减少，这是个好现象。可维护性也不错，然后柱状图详细列出了每个 JavaScript 文件的可维护性。再往下的柱状图列出了每个文件的代码行数、每个文件的预计错误数，以及每个文件的 JSLint 错误数。</p>\n\n<p><a href=\"http://2.bp.blogspot.com/-WfsE5xqGhjc/UV0Fi3Kd9vI/AAAAAAAAZvg/IWnkno7LaK8/s1600/jquery-top-level.png\"><img src=\"http://2.bp.blogspot.com/-WfsE5xqGhjc/UV0Fi3Kd9vI/AAAAAAAAZvg/IWnkno7LaK8/s640/jquery-top-level.png\" alt=\"\" /></a></p>\n\n<!-- If you drill into one of the particular files from above you'll see a view that looks like the following. The nice part about this report is that it breaks down each function into complexity and lines of code in a way that is easy to grasp. You can quickly jump to various parts of the file to review the concerns the tool is identifying. -->\n\n\n<p>如果深入到某个文件，你将看到下面的视图。这份报告最棒的地方是用一种容易掌握的方式展示了每个函数的复杂度和代码行数。你可以快速跳到文件的不同部分，审查该工具标识出的关注点。</p>\n\n<p><a href=\"http://2.bp.blogspot.com/-GHHmjChHTdo/UV0Fn9yzTwI/AAAAAAAAZvo/qMwHcRxb3p8/s1600/jquery-drill-complexity.png\"><img src=\"http://2.bp.blogspot.com/-GHHmjChHTdo/UV0Fn9yzTwI/AAAAAAAAZvo/qMwHcRxb3p8/s640/jquery-drill-complexity.png\" alt=\"\" /></a></p>\n\n<!-- You can view the above [jQuery Report](http://jsoverson.github.com/plato/examples/jquery/) from Plato's GitHub repository. -->\n\n\n<p>你可以到 Plato 的 GitHub 库查看上面的 <a href=\"http://jsoverson.github.com/plato/examples/jquery/\">jQuery 报告</a>。</p>\n\n<!-- ## Attack! -->\n\n\n<h2>进攻！</h2>\n\n<p>下面是一个用 <a href=\"http://incompl.github.com/boxbox/\">boxbox</a> 构建的简版 Angry Birds，boxbox 是一个用于 <a href=\"https://code.google.com/p/box2dweb/\">box2dweb</a> 的框架，由 <a href=\"http://bocoup.com\">Bocoup</a> 的 <a href=\"http://twitter.com/_gsmith\">Greg Smith</a> 编写。</p>\n\n<blockquote><p>Press the <code>space bar</code> to launch the White Bird and you can also use the arrow keys.\n按下<code>空格键</code>来发射白鸟，你也可以使用方向键。</p></blockquote>\n\n<p><a href=\"http://jsfiddle.net/4QG5Q/1/show\"><img src=\"http://3.bp.blogspot.com/-eLUAASpDUy0/UV0NIExF6RI/AAAAAAAAZwA/uCKAm54p5W4/s640/Screenshot+on+4.4.2013+at+12.14.59+AM.png\" alt=\"\" /></a></p>\n\n<!-- ## Conclusion -->\n\n\n<h2>结论</h2>\n\n<!-- Front-end web applications can get complicated quickly. If your developers aren't all on the same page then things can fall apart in a heartbeat, especially on a large project. Having a unified coding standard and implementing some tools to help find issues before they become a problem can really help to make your project a success.  -->\n\n\n<p>前端 Web 应用可以很快变得相当复杂。如果开发人员不能达成共识，事情可能马上土崩瓦解，特别是在一个大型项目中。形成统一的代码标准和使用一些工具来避免问题，才能真正有助于项目成功。</p>\n\n<!-- There are many other front-end architecture techniques that have been stolen by the pigs. Tune in next time as the next Angry Bird takes its revenge! Dun, dun, daaaaaaa! -->\n\n\n<p>还有很多其他前端架构技术被猪偷走了。在下篇文章中，另一只愤怒的小鸟将继续复仇！Dun, dun, daaaaaaa!</p>\n\n<blockquote><p><a href=\"http://nuysoft.com/2013/04/21/angry-birds-of-javascript-orange-bird-templating/#comment-881925473\">@sunnylost</a> 补充：Dun, dun, daaaaaaaaaa! 应该是在模拟背景音乐，类似于这种 <a href=\"http://missingno.ocremix.org/musicpages/game_on.html\">http://missingno.ocremix.org/musicpages/game_on.html</a></p></blockquote>\n"
            ],
            "link": [
              "http://nuysoft.github.com/2013/04/18/angry-birds-of-javascript-white-bird-linting"
            ],
            "guid": [
              "http://nuysoft.github.com/2013/04/18/angry-birds-of-javascript-white-bird-linting"
            ],
            "pubDate": [
              "2013-04-18T00:00:00-07:00"
            ]
          },
          {
            "title": [
              "模式"
            ],
            "description": [
              "<blockquote><p>原文：<a href=\"http://www.elijahmanor.com/2013/04/angry-birds-of-javascript-big-brother.html\">Angry Birds of JavaScript: Big Brother Bird - Patterns</a></p></blockquote>\n\n<!-- ## Introduction -->\n\n\n<h2>简介</h2>\n\n<p><img src=\"http://3.bp.blogspot.com/-mwxJ0DGmvGI/UWCKOt-Lx6I/AAAAAAAAZ14/od_wDw_B5mk/s1600/angry-birds-big-red-bird.jpg\" alt=\"\" /></p>\n\n<!-- ![](http://3.bp.blogspot.com/-mwxJ0DGmvGI/UWCKOt-Lx6I/AAAAAAAAZ14/od_wDw_B5mk/s320/angry-birds-big-red-bird.jpg) -->\n\n\n\n\n<!-- A diabolical herd of pigs stole all of the front-end architecture from an innocent flock of birds and now they want it back! A team of special agent hero birds will attack those despicable pigs until they recover what is rightfully theirs, front-end JavaScript architecture! -->\n\n\n<p>一群无法无天的猪从无辜的小鸟那里偷走了所有的前端架构，现在小鸟们要把它们夺回来！一队特殊的小鸟英雄将攻击这些卑鄙的猪，直到夺回原本属于它们的前端 JavaScript 架构！</p>\n\n<!-- Will the birds be successful in the end? Will they defeat their bacon flavored foe? Let's find out together in another nail biting episode of Angry Birds of JavaScript! -->\n\n\n<p>小鸟们最终会成功吗？它们会打败那些培根味儿的敌人吗？让我们一起揭示 JavaScript 之愤怒的小鸟系列的另一个扣人心弦的章节！</p>\n\n<blockquote><p>译注：翻译“bacon flavored foe”时，想起来了《少林足球》里的“做人如果没有梦想，那跟咸鱼有什么区别？”，就翻译成了“咸猪敌人”，<a href=\"http://nuysoft.com/2013/04/21/angry-birds-of-javascript-orange-bird-templating/#comment-881925473\">@sunnylost</a> 建议翻译为“培根味儿的敌人”，应该更准确和有趣些。</p></blockquote>\n\n<!-- > Check out the **[series introduction post]** for a list of all the birds and their attack powers. -->\n\n\n<blockquote><p>阅读<strong><a href=\"http://www.elijahmanor.com/2013/03/angry-birds-of-javascript-series.html\">系列介绍文章</a></strong>，查看所有小鸟以及它们的攻击力。</p></blockquote>\n\n<!-- ![](http://4.bp.blogspot.com/-wqME_pIXlMg/UWCKU5PVcVI/AAAAAAAAZ2A/yoODl8TYwKU/s1600/big-brother-bird.png) -->\n\n\n<p><img src=\"http://4.bp.blogspot.com/-wqME_pIXlMg/UWCKU5PVcVI/AAAAAAAAZ2A/yoODl8TYwKU/s1600/big-brother-bird.png\" alt=\"\" /></p>\n\n<!-- ### Previous Attacks -->\n\n\n<h3>战报</h3>\n\n<ul>\n<li><a href=\"http://www.elijahmanor.com/2013/03/angry-birds-of-javascript-red-bird.html\">Red Bird - IIFE</a></li>\n<li><a href=\"http://www.elijahmanor.com/2013/03/angry-birds-of-javascript-blue-bird.html\">Blue Bird - Events</a></li>\n<li><a href=\"http://www.elijahmanor.com/2013/04/angry-birds-of-javascript-yellow-bird.html\">Yellow Bird - RequireJS</a></li>\n<li><a href=\"http://www.elijahmanor.com/2013/04/angry-birds-of-javascript-black-bird.html\">Black Bird - Backbone</a></li>\n<li><a href=\"http://www.elijahmanor.com/2013/04/angry-birds-of-javascript-white-bird.html\">White Bird - Linting</a></li>\n<li><a href=\"http://www.elijahmanor.com/2013/04/angry-birds-of-javascript-green-bird.html\">Green Bird - Mocking</a></li>\n<li><a href=\"http://www.elijahmanor.com/2013/04/angry-birds-of-javascript-orange-bird.html\">Orange Bird - Templating</a></li>\n</ul>\n\n\n<!-- ### Big Brother Bird Attacks -->\n\n\n<h3>大鸟哥的攻击</h3>\n\n<!-- In this post we will take a look at the Big Brother Bird who pulls out the big guns with his finite state machine and other proven design patterns of destruction. Slowly, one by one, the birds will take back what it theirs to keep! -->\n\n\n<p>在这篇文章中，我们将看到大鸟哥祭出它的大规模杀伤性武器：有限状态机以及成熟的设计模式。渐渐的，小鸟们将一个接一个的夺回属于它们的东西！</p>\n\n<!-- ## What Was Stolen by the Pigs? -->\n\n\n<h2>猪偷走了什么？</h2>\n\n<!-- The birds knew how to program for the most part, but they never had a common terminology that they all understood to represent common scenarios they kept encountering. Then one day a Big Brother Bird came along and documented a set of common Design Patterns and them names and descriptions so they could all be on the same page when talking about architecture. Big Brother Bird ended up writing these patterns in a popular piece that became known as the **Gang of Foul** book. -->\n\n\n<p>小鸟们了解如何编程的大部分知识，但是从未形成通用的术语，一些代表了常见场景、同时能被大家理解的术语。然后某一天大鸟哥出现了，并记录了一组常见的设计模式的名称和描述，这样它们在谈论架构时就可以达成共识（就有了共同的语言）。最终大鸟哥的模式广受欢迎，并以<strong>四人帮</strong>一书闻名于鸟界。</p>\n\n<blockquote><p>译注：这段文字欢乐的很。</p></blockquote>\n\n<!-- However, during a recent invasion the pigs stole the birds' Gang of Fowl book! As a result, one of the Big Brother Birds has been tasked to reclaim what has been stolen. He will use his overwhelming power of trickery to help destroy the pigs in order to take back what is theirs. -->\n\n\n<p>然而在最近的一次猪群入侵中，小鸟们的<strong>四人帮</strong>书惨重失窃！现在，大鸟哥被派去找回被盗的书。它将用压到一切诡计的力量摧毁猪群，夺回属于它们的东西。</p>\n\n<!-- ## Gang of Fowl Patterns -->\n\n\n<h2>鸟界的四人帮（23 种）</h2>\n\n<!-- ### Creational Patterns -->\n\n\n<h3>创建模式（5 种）</h3>\n\n<p>创建模式涉及到将对象实例化，这类模式都提供一个方法，将客户从所需实例化的对象中解耦。</p>\n\n<ul>\n<li><strong>Abstract Factory</strong> <br> 抽象工厂。提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。</li>\n<li><strong>Builder</strong> <br> 构造器。封装一个产品的构造过程，并允许按步骤构造。</li>\n<li><strong>Factory Method</strong> <br> 工厂方法。定义了一个创建对象的方法，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。</li>\n<li><strong>Prototype</strong> <br> 原型。当创建给定类的实例的过程很昂贵或很复杂时，就使用原型模式。</li>\n<li><strong>Singleton</strong> <br> 单例。确保一个类只有一个实例，并提供一个全局访问点。</li>\n</ul>\n\n\n<!-- ### Structural Patterns -->\n\n\n<h3>结构模式（7 种）</h3>\n\n<p>结构模式可以让你把类或对象组合到更大的结构中</p>\n\n<ul>\n<li><strong>Adapter</strong> <br> 适配器。将一个类的接口，转换成客户期望的另一个接口。适配器让原来接口不兼容的类可以合作无间。</li>\n<li><strong>Bridge</strong> <br> 桥接。不只改变你的实现，也改变你的抽象。</li>\n<li><strong>Composite</strong> <br> 组合。允许你将对象组合成树形结构来表现“整体/部分”层次结构。组合能让客户以一致的方式处理个别对象以及对象组合。</li>\n<li><strong>Decorator</strong> <br> 装饰者。动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。</li>\n<li><strong>Facade</strong> <br> 外观。提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。</li>\n<li><strong>Flyweight</strong> <br> 蝇量。让某个类的一个实例能用来提供许多“虚拟实例”。</li>\n<li><strong>Proxy</strong> <br> 代理。为另一个对象提供一个替身或占位符以控制对这个对象的访问。</li>\n</ul>\n\n\n<!-- ### Behavioral Patterns -->\n\n\n<h3>行为模式（11 种）</h3>\n\n<ul>\n<li><strong>Chain of Resp.</strong> <br> 责任链。让一个以上的对象有机会处理某个请求。</li>\n<li><strong>Command</strong> <br> 命令。将“请求”封装成对象，以便使用不同的请求，队列或者日志来参数化其他对象。命令模式也支持可撤销的操作。</li>\n<li><strong>Interpreter</strong> <br> 解释器。为语言创建解释器。</li>\n<li><strong>Iterator</strong> <br> 迭代器。提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。</li>\n<li><strong>Mediator</strong> <br> 中介者。集中相关对象之间复杂的沟通和控制方式。</li>\n<li><strong>Memento</strong> <br> 备忘录。让对象返回之前的状态。</li>\n<li><strong>Observer</strong> <br> 观察者。定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。</li>\n<li><strong>State</strong> <br> 状态。允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。</li>\n<li><strong>Strategy</strong> <br> 策略。定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。</li>\n<li><strong>Template Method</strong> <br> 模板方法。在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法的某些步骤。</li>\n<li><strong>Visitor</strong> <br> 访问者。当你想要为一个对象的组合增加新的能力，且封装并不重要时，就使用访问者模式。</li>\n</ul>\n\n\n<!-- ## Some These Patterns in JavaScript -->\n\n\n<h2>JavaScript 中的设计模式</h2>\n\n<!-- ### Singleton -->\n\n\n<h3>单例模式</h3>\n\n<!-- The most basic form of singleton is the object literal as shown below. We are basically just creating an object and there is one of them. Technically someone could `Object.create` on us, but for the most part this fulfills the singleton definition. You can find a more robust solution in one of the resources recommended near the end of this post. -->\n\n\n<p>单例模式最简单的实现是采用对象字面量，如下面的代码所示。基本上，我们只是创建了一个对象，含有一些属性。从技术角度讲，有人可能会建议使用 <code>Object.create</code>，但是大部分情况下，对象字面量符合单例模式的定义。你可以在本文末尾的推荐资源中找到更强大的解决方案。</p>\n\n<blockquote><p>译注：Object.create(proto [, propertiesObject ]) 创建一个拥有指定原型和若干个指定属性的对象。</p></blockquote>\n\n<p>  <script src=\"https://gist.github.com/elijahmanor/5328936.js?file=singleton.js\">\n  </script></p>\n\n<!-- ### Factory -->\n\n\n<h3>工厂模式</h3>\n\n<!-- A factory is a way to create new objects without actually using the `new` keyword. The idea is that there is something abstracted away from you in the factory method. In the following example we are aren't necessarily doing anything fancy, but you could imagine that we could add some custom code down the road and the external API wouldn't change, which is the point of this pattern. -->\n\n\n<p>工厂模式实际是一种不使用 <code>new</code> 关键字来创建新对象的方式。理念是在工厂方法中提取抽象。在下面的例子中，我们不一定要做很多事情，但是你可以想象的到，我们可以沿着这个方向添加一些自定义代码和不会改变的额外 API，这才是工厂模式的关键点所在。</p>\n\n<p>  <script src=\"https://gist.github.com/elijahmanor/5328936.js?file=factory.js\">\n  </script></p>\n\n<!-- ### Bridge -->\n\n\n<h3>桥接模式</h3>\n\n<!-- In the following snippet of code we are creating a small bridge between an event handler and the code that will be executed. By creating a little bridge it will enabled the executed code to be tested easier since it won't have a dependency on the element context that was passed by jQuery. -->\n\n\n<p>在下面的代码片段中，我们在事件处理函数和将要执行的代码（<code>getUrl( url, callback )</code>）之间建立了一个简单的桥接。从而使得被执行的代码（<code>getUrl( url, callback )</code>）更易于测试，因为它不再依赖于 jQuery 传入的上下文元素。</p>\n\n<p>  <script src=\"https://gist.github.com/elijahmanor/5328936.js?file=bridge.js\">\n  </script></p>\n\n<!-- ### Facade -->\n\n\n<h3>外观模式</h3>\n\n<!-- A facade is common place in front-end web development since there is so much cross-browser inconsistencies. A facade brings a common API to something that could vary under the covers. In the following snippet we abstract the addEventListener logic for various browser implementations. -->\n\n\n<p>外观模式在 Web 前端开发中很普遍，因为有如此多的跨浏览器不一致问题。外观模式为这种不一致提供了一个统一的 API。在下面的代码中，我们将 addEventListener 在不同浏览器中的实现进行逻辑抽象。</p>\n\n<p>  <script src=\"https://gist.github.com/elijahmanor/5328936.js?file=facade.js\">\n  </script></p>\n\n<!-- ### Adapter -->\n\n\n<h3>适配器模式</h3>\n\n<!-- An adapter is a nice way to massage one piece of code to work with another piece of code. This can be useful when you need to switch to another library, but can't afford to rewrite much of your code. In the following example we are modifying jQuery's `$.when` method to work with the `WinJS.Promise`. This is some code I wrote back when I worked for appendTo when we were making jQuery working with Windows 8 apps. You can find this repository at [jquery-win8]. -->\n\n\n<p>一个适配器可以轻量的处理一段代码，让其与另一段代码无间合作。当你需要切换到另一个库又无法忍受重写大量代码时，适配器会非常有用。在下面的示例中，我们将修改 jQuery 的 <code>$.when</code> 方法以支持 <code>WinJS.Promise</code>。这是我在 appendTo 工作期间写下的代码，当时我们想让 Windows 8 APP 可以使用 jQuery。你可以在 <a href=\"https://github.com/appendto/jquery-win8\">jquery-win8</a> 找到这个库。</p>\n\n<!-- > Much of the jquery-win8 repository is not needed anymore since Jonathan Sampson has worked with the jQuery team to make sure the changes he made to the shim was added to the 2.0 version of jQuery as noted in the [following blog post] -->\n\n\n<blockquote><p>jquery-win8 库的大部分功能已经不再需要了，因为 Jonathan Sampson 已经与 jQuery 开发团队一起协作，以确保他对这一垫片的更新被添加到 jQuery 2.0 版本中，<a href=\"http://appendto.com/blog/2013/03/windows-store-applications-with-jquery-2-0/\">这篇文章</a>记录了这一点。</p></blockquote>\n\n<p>  <script src=\"https://gist.github.com/elijahmanor/5328936.js?file=adapter.js\">\n  </script></p>\n\n<!-- ### Observer -->\n\n\n<h3>观察者模式</h3>\n\n<!-- We've covered the Observer pattern already in the [Blue Bird] past a while back in this series, but it is a powerful pattern that can help decouple various components. My recommendation is to use the [postal.js library]. -->\n\n\n<p>我们已经在这个系列的 <a href=\"http://www.elijahmanor.com/2013/03/angry-birds-of-javascript-blue-bird.html\">Blue Bird</a> 一文中阐述了观察者模式，这是一个功能强大的模式，可以实现各种组件的解耦。个人推荐使用 <a href=\"https://github.com/postaljs/postal.js\">postal.js 库</a>。</p>\n\n<p>  <script src=\"https://gist.github.com/elijahmanor/5328936.js?file=observer.js\">\n  </script></p>\n\n<!-- ## Many More Patterns -->\n\n\n<h2>更多模式</h2>\n\n<!-- ### Inheritance -->\n\n\n<h3>继承</h3>\n\n<!-- There are several ways to implement inheritance in JavaScript. It is good to know some of these patterns as you create new objects in your application. -->\n\n\n<p>在 JavaScript 中有多种方式实现继承。当你在应用程序中创建对象时，最好了解一下这些模式。</p>\n\n<!-- **Prototypal Inheritance** -->\n\n\n<p><strong>原型继承</strong></p>\n\n<p>  <script src=\"https://gist.github.com/elijahmanor/5328936.js?file=prototypal-inheritance.js\">\n  </script></p>\n\n<!-- **Pseudoclassical Ineritance** -->\n\n\n<p><strong>模拟继承</strong></p>\n\n<p>  <script src=\"https://gist.github.com/elijahmanor/5328936.js?file=pseudoclassical-inheritance.js\">\n  </script></p>\n\n<!-- ### Chaining -->\n\n\n<h3>链式语法</h3>\n\n<!-- In the front-end world chaining became popular by the jQuery library. It is actually a really easy pattern to implement. You essentially just have to return `this` from every function so that other functions can be immediately called. See the following for an example. -->\n\n\n<p>因为 jQuery 库的缘故，链式语法在前端界变得非常流行。实际上这是一种非常容易实现的模式。基本上，你只需要让每个函数返回 'this'，这样其他函数就可以立即被调用。看看下面的例子。</p>\n\n<p>  <script src=\"https://gist.github.com/elijahmanor/5328936.js?file=chaining.js\">\n  </script></p>\n\n<!-- ### Encapsulating -->\n\n\n<h3>封装模式</h3>\n\n<!-- We've already covered encapsulating in the [Red Bird](http://www.elijahmanor.com/2013/03/angry-birds-of-javascript-red-bird.html) past where we talked about the IIFE pattern. This allows you to have public and private properties and methods to help encapsulate your code. The follow is a very brief example of that. Check out the [Red Bird](http://www.elijahmanor.com/2013/03/angry-birds-of-javascript-red-bird.html) post for more details. -->\n\n\n<p>我们在 <a href=\"http://www.elijahmanor.com/2013/03/angry-birds-of-javascript-red-bird.html\">Red Bird</a> 一文中已经阐述了封装模式，不过当时说的 IIFE 模式。封装模式允许你拥有公共和私有的属性和方法，以此来封装你的代码。下面是一个非常简单的示例。更多细节请参阅文章 <a href=\"http://www.elijahmanor.com/2013/03/angry-birds-of-javascript-red-bird.html\">Red Bird</a>。</p>\n\n<p>  <script src=\"https://gist.github.com/elijahmanor/5328936.js?file=encapsulating.js\">\n  </script></p>\n\n<!-- ### Finite State Machine -->\n\n\n<h3>有限状态机</h3>\n\n<!-- One of my favorite pattern is the Finite State Machine. My friend Jim Cowart ([@ifandelse](http://twitter.com/ifandelse)) created the [Machina.js Library](https://github.com/ifandelse/machina.js) to implement this pattern in JavaScript. The following is an example of using states to describe the game of Angry Birds. For more information check out his [blog post](http://freshbrewedcode.com/jimcowart/2012/03/12/machina-js-finite-state-machines-in-javascript/) and [GitHub repository](https://github.com/ifandelse/machina.js). -->\n\n\n<p>有限状态机是我最喜欢的模式之一。我的朋友 Jim Cowart（<a href=\"http://twitter.com/ifandelse\">@ifandelse</a>）创建了 <a href=\"https://github.com/ifandelse/machina.js\">Machina.js 库</a>，用来在 JavaScript 中实现这一模式。下面的示例使用状态来描述愤怒的小鸟游戏。更多信息请参阅它的<a href=\"http://freshbrewedcode.com/jimcowart/2012/03/12/machin\">博客文章</a>和 <a href=\"https://github.com/ifandelse/machina.js\">GitHub 库</a>。</p>\n\n<p>  <script src=\"https://gist.github.com/elijahmanor/5328936.js?file=finite-state-machine.js\">\n  </script></p>\n\n<!-- ## Recommendations -->\n\n\n<h2>建议</h2>\n\n<!-- In addition to learning these patterns I would recommend that you pick one of your favorite libraries and start to source dive into their repository. There is a wealth of information you can learn there. At first it could be semi-overwhelming, but over time you can glean a lot from developers who really know some of these patterns. You might try just looking at one particular method and start picking it apart. If you aren't sure exactly where to look for a particular method why don't you pick jQuery and use James Padolsey's ([@padosley](http://twitter.com/padosley)) [jQuery Source Viewer](http://james.padolsey.com/jquery) to help find it for you? -->\n\n\n<p>除了学习这些模式之外，我建议你挑一个喜欢的库，并钻研它们的源代码。在其中你可以学到丰富的知识。起初你可能觉得云山雾罩，但过一段时间你可以从真正理解这些模式的开发者身上收集到大量的模式。你也可以试着只着眼于一个特别的方法并剖析它。如果你不知道到底要去哪里寻找这么一个特别的方法，那么为什么不选择 jQuery 并使用 James Padolsey（<a href=\"http://twitter.com/padosley\">@padosley</a>）的 <a href=\"http://james.padolsey.com/jquery\">jQuery 源码查看器</a>来帮助你寻找呢？</p>\n\n<!-- ## Additional Resources -->\n\n\n<h2>其他资源</h2>\n\n<!-- There are far too many patterns for me to list here. Many have blogged about these before me and will continue to. If I have missed any good ones please let me know. -->\n\n\n<p>已经有太多的模式以至我无法在这里一一列出。在我之前，已经有许多人撰写了关于这些模式的博客，并且以后还会有。如果我错过了什么好模式，请告诉我。</p>\n\n<ul>\n<li><a href=\"http://www.joezimjs.com/javascript/javascript-design-patterns-singleton/\">JavaScript Design Patterns</a> by Joe Zim (<a href=\"http://twitter.com/JoeZimJS\">@JoeZimJS</a>)</li>\n<li><a href=\"http://www.joezimjs.com/javascript/javascript-design-patterns-singleton/\">JavaScript Design Patterns</a> by Joe Zim (<a href=\"http://twitter.com/JoeZimJS\">@JoeZimJS</a>)</li>\n<li><a href=\"http://net.tutsplus.com/tutorials/javascript-ajax/digging-into-design-patterns-in-javascript/\">Understanding Design Patterns in JavaScript</a> by Tilo Mitra (<a href=\"http://twitter.com/tilomitra\">@tilomitra</a>)</li>\n<li><a href=\"http://addyosmani.com/resources/essentialjsdesignpatterns/book/\">Learning JavaScript Design Patterns</a> by Addy Osmani (<a href=\"http://twitter.com/addyosmani\">@addyosmani</a>)</li>\n<li><a href=\"http://shichuan.github.io/javascript-patterns/\">JS Patterns</a> by Shi Chuan (<a href=\"http://twitter.com/shichuan\">@shichuan</a>)</li>\n<li><a href=\"http://shop.oreilly.com/product/9780596806767.do\">JavaScript Patterns</a> by Stoyan Stefanov (<a href=\"http://twitter.com/xyz\">@xyz</a>)</li>\n<li><a href=\"http://shop.oreilly.com/product/9780596517748.do\">JavaScript: The Good Parts</a> by Douglas Crockford</li>\n</ul>\n\n\n<!-- ## Attack! -->\n\n\n<h2>攻击！</h2>\n\n<p>下面是一个用 <a href=\"http://incompl.github.com/boxbox/\">boxbox</a> 构建的简版 Angry Birds，boxbox 是一个用于 <a href=\"https://code.google.com/p/box2dweb/\">box2dweb</a> 的框架，由 <a href=\"http://bocoup.com\">Bocoup</a> 的 <a href=\"http://twitter.com/_gsmith\">Greg Smith</a> 编写。</p>\n\n<!-- > Press the `space bar` to launch the Big Brother Bird and you can also use the arrow keys. -->\n\n\n<blockquote><p>按下<code>空格键</code>来发射大鸟哥，你也可以使用方向键。</p></blockquote>\n\n<p><a href=\"http://jsfiddle.net/k6VCt/show\"><img src=\"http://1.bp.blogspot.com/-HjiGrN3B7jg/UWDO-fHTJgI/AAAAAAAAZ2Q/-sshCm882k4/s1600/big-brother-bird-game.png\" alt=\"\" /></a></p>\n\n<!-- ## Conclusion -->\n\n\n<h2>结论</h2>\n\n<!-- The good news is you don't have to know all the answers to be successful in front-end web development, but what does help is knowing some of the common patterns that come up again and again during development. Once you get accustomed to these patterns it will become easier talking about these architectural solutions and figure out solutions should come quicker. Take some time and look through the recommended resources above and start mulling over some of them for yourself.  -->\n\n\n<p>好消息是，你不必知道所有的答案也顺利完成 Web 前端开发，但多少了解一些开发中反复遇到的通用模式确实很有帮助。一旦你习惯了这些模式，谈论架构方案将变得更容易，也可以更快的找出解决方案。花一些时间浏览前面推荐的资源，然后仔细考虑那些适合你的模式。</p>\n\n<!-- There is one more front-end architecture technique that has been stolen by the pigs. Tune in next time as the next Angry Bird takes its revenge! Dun, dun, daaaaaaa! -->\n\n\n<p>还有更多的前端架构技术被猪偷走了。在下篇文章中，另一只愤怒的小鸟将继续复仇！Dun, dun, daaaaaaa!</p>\n\n<blockquote><p><a href=\"http://nuysoft.com/2013/04/21/angry-birds-of-javascript-orange-bird-templating/#comment-881925473\">@sunnylost</a> 补充：Dun, dun, daaaaaaaaaa! 应该是在模拟背景音乐，类似于这种 <a href=\"http://missingno.ocremix.org/musicpages/game_on.html\">http://missingno.ocremix.org/musicpages/game_on.html</a></p></blockquote>\n"
            ],
            "link": [
              "http://nuysoft.github.com/2013/04/16/angry-birds-of-javascript-big-brother-bird-patterns"
            ],
            "guid": [
              "http://nuysoft.github.com/2013/04/16/angry-birds-of-javascript-big-brother-bird-patterns"
            ],
            "pubDate": [
              "2013-04-16T00:00:00-07:00"
            ]
          },
          {
            "title": [
              "立即调用的函数表达式"
            ],
            "description": [
              "<blockquote><p>原文：<a href=\"http://www.elijahmanor.com/2013/03/angry-birds-of-javascript-red-bird.html\">Angry Birds of JavaScript: Red Bird - IIFE</a></p></blockquote>\n\n<!-- ## Introduction -->\n\n\n<h2>简介</h2>\n\n<p><img src=\"http://3.bp.blogspot.com/-gdPxI78dJRM/UUPoi2KHFkI/AAAAAAAAX94/M6gVKm4DN64/s1600/Loading_screen.png\" alt=\"\" /></p>\n\n<!-- ![](http://3.bp.blogspot.com/-gdPxI78dJRM/UUPoi2KHFkI/AAAAAAAAX94/M6gVKm4DN64/s320/Loading_screen.png) -->\n\n\n\n\n<!-- A diabolical herd of pigs stole all of the front-end architecture from an innocent flock of birds and now they want it back! A team of special agent hero birds will attack those despicable pigs until they recover what is rightfully theirs, front-end JavaScript architecture! -->\n\n\n<p>一群无法无天的猪从无辜的小鸟那里偷走了所有的前端架构，现在小鸟们要把它们夺回来！一队特殊的小鸟英雄将攻击这些卑鄙的猪，直到夺回原本属于它们的前端 JavaScript 架构！</p>\n\n<!-- In this post we will take a look at the Red Bird who attacks with the force of their trusty IIFE, the basic block of all privacy. -->\n\n\n<p>在这篇文章中，我们将看看红色小鸟，它使用可靠的 IIFE 作为攻击武器，而 IIFE 是一切秘密的基础。</p>\n\n<blockquote><p>IIFE Immediately-invoked Function Expression</p></blockquote>\n\n<!-- ## What Was Stolen by the Pigs? -->\n\n\n<h2>猪偷走了什么？</h2>\n\n<p><img src=\"http://4.bp.blogspot.com/-JMM-_2Tl7Es/UUOFH81EAUI/AAAAAAAAX8k/GxsgENgc4kY/s1600/red-bird.png\" alt=\"\" />\n<img src=\"http://4.bp.blogspot.com/-JMM-_2Tl7Es/UUOFH81EAUI/AAAAAAAAX8k/GxsgENgc4kY/s200/red-bird.png\" alt=\"\" /></p>\n\n<!-- For ages the birds used to litter the global namespace (the window object) with their custom objects and functions. Over time the birds slowly learned techniques to protect their objects from the global namespace, however, since the recent pig invasion all of their anti-global secrets have been stolen! Thankfully the birds are fortunate that a one foul exists with the knowledge of this secret and plans to attack the pigs to unleash what is rightfully theirs. -->\n\n\n<p>很长时间以来，小鸟们习惯了向全局命名空间（window 对象）乱丢它们的自定义对象和函数。随着时间的慢慢退役，小鸟们慢慢学会了利用全局命名空间保护它们的对象的技术，然而由于近期猪群的入侵，反全局的秘密都被偷走了！侥幸的是这项秘密技术仍然存在缺陷，小鸟们计划攻击猪群，解放原本属于它们的技术。</p>\n\n<!-- ## How Objects Become Global? -->\n\n\n<h2>对象是如何变为全局对象的？</h2>\n\n<!-- There are several ways that an object can become global. Part of the battle is just knowing the various ways. -->\n\n\n<p>一个对象变为全局对象有好几种方式。了解各种方式正是战争的一部分。</p>\n\n<!-- 1. **Declaring an Object in the Window Scope** -->\n\n\n<p>1. <b>在 Window 作用域中声明对象</b></p>\n\n\n\n\n<!-- TODO: Is this called the Window Scope? Top Level Scope? -->\n\n\n<!-- In the following example there two variables declared, `type` and `attack`. These variables were declared in the top level scope and therefore are accessible off of the `window` object. -->\n\n\n<p>在下面的例子有两个变量声明，<code>type</code> 和 <code>attack</code>。变量在顶级作用域中声明，因此 <code>window</code> 对象可以访问它们。</p>\n\n<p>  <script src=\"https://gist.github.com/elijahmanor/4991287.js?file=global-variables.js\">\n  </script></p>\n\n<!-- 2. **Not Declaring an Object in Any Scope** -->\n\n\n<p>2. <b>任何作用域中未声明的对象</b></p>\n\n\n\n\n<!-- One of the most dangerous and easiest things to do in JavaScript is to accidentally declare a global variable when you didn't mean to. If you forget to declare a variable then JavaScript declares it for you as a global! This is usually not what you meant to do and could expose parts of your application that you didn't intend. -->\n\n\n<p>在 JavaScript 中，意外的声明一个全局变量是最危险也是最容易发生的事情是，而这并不是你的初衷。如果你忘记声明一个变量，JavaScript 将把它声明为一个全局变量！这通常不是你的初衷，却在无意中暴漏了应用程序的某些部分。</p>\n\n<p>  <script src=\"https://gist.github.com/elijahmanor/4991287.js?file=not-declaring-variable.js\">\n  </script></p>\n\n<!-- 3. **Specifically Adding an Object to the Window** -->\n\n\n<p>3. <b>明确向 Window 添加对象</b></p>\n\n\n\n\n<!-- You also have the opportunity to expose variables to the global namespace intentionally. You can easily do this by accessing the `window` object and adding a property or method manually. It isn't a good idea to use this technique deep inside your code, but it is worth nothing that you can. -->\n\n\n<p>你也有机会故意向全局命名空间暴漏变量。通过访问 <code>window</code> 对象并手动添加一个属性或方法，你可以很容易的做到这一点。在你的代码深处使用这项技术并不是一个好主意，你可以这么做，但是没什么价值。</p>\n\n<p>  <script src=\"https://gist.github.com/elijahmanor/4991287.js?file=explicit-global.js\">\n  </script></p>\n\n<!-- ## Why Are Global Objects a Problem? -->\n\n\n<h2>为什么全局对象是一个问题？</h2>\n\n<!-- * **Conflicts within Your Code**     -->\n\n\n<ul>\n<li><strong>与你的代码冲突</strong></li>\n</ul>\n\n\n<!-- There is a risk that developers within your own company may define the same function, method, or property that already exists in your application. If you have no mechanism to reduce the number of items in the global namespace your risk of accidentally reassigning a variable grows as your application gets larger and more complex. -->\n\n\n<p>和你同属一个公司的开发人员，可能会定义在你的程序中已存在的同名函数、方法或属性，这是有风险的。如果你没有一套机制来减少全局命名空间中的条目，随着你的程序变得更大和更复杂，意外重新分配变量的风险随之增加。</p>\n\n<p>You may dismiss this reason because you have rigid code reviews and all your developers know your codebase inside out. If that describes you, then check out the next reason ;)\n你可能会反驳这个原因，因为你拥有严格的代码审核，并且所有的开发人员都透彻了解你的代码库。如果你觉得这说的是你，那么看看下一个原因 ;)</p>\n\n<!-- * **Conflicts with Your Code and Third-Party Libraries** -->\n\n\n<ul>\n<li><strong>与你的代码和第三方库冲突</strong></li>\n</ul>\n\n\n<!-- Another danger of having multiple global objects is that your code could conflict with third-party libraries that you are using. There are a lot of libraries, plugins, and frameworks out there and not all of them are as aware and conscious about keeping their global variables to a minimum. Your code and the libraries you include could clash and override each-other's behavior which can cause unexpected results. -->\n\n\n<p>拥有多个全局对象的另一个风险是，你的代码可能与你所使用的第三方库冲突。存在大量的库、插件和框架，并不是所有这些第三方库都了解和意识到要保持全局变量到最小集。你的代码和这些库可能会发生冲突，并覆盖彼此的行为，这可能导致意想不到的结果。</p>\n\n<!-- You may dismiss this reason because you deeply scrutinize all third-party libraries that your team uses and are fully aware of what global variables are exposed by these libraries. If that describes you, then check out the next reason :) -->\n\n\n<p>你可能会反驳这个原因，因为你深入的审视你的团队所使用的所有第三方库，并且充分了解这些库暴露的全局变量。如果你觉得这说的是你，那么看看下一个原因 :)</p>\n\n<!-- * **Conflicts with Your Code and Browser Add-ons/Extensions/Plugins** -->\n\n\n<ul>\n<li><strong>与你的代码和浏览器附加元件/扩展/插件冲突</strong></li>\n</ul>\n\n\n<!-- The final danger of having multiple global objects is that your code could conflict with the browser itself. What!?! Lets take Google Chrome for an example. Chrome's add-ons are JavaScript based and all of your installed add-ons run on your web page when it is loaded. You never know what add-ons your users have installed and as a result there is a risk that those add-ons will expose global variables that conflict with your code-base. -->\n\n\n<p>拥有多个全局对象的最后一个风险是，你的代码可能与浏览器本身冲突。什么！？！那以谷歌浏览器 Chrome 为例。Chrome 的插件基于 JavaScript，并且当你的网页加载后，你安装的所有插件会在你的网页上运行。你永远不会知道用户安装了什么插件，这就导致一个风险，这些附加元件会暴露全局变量并和你的代码库发生冲突。</p>\n\n<!-- Does this seem far-fetched? Well, it can at first, but I've actually seen a high profile website (not going to mention which one) run into this very problem. I was trying to use the website and it was broken. I knew the developer so I reached out to him. After some back and forth it turned out I had an add-on installed that broke the website. I contacted the add-on author and they updated their code and now all is fine. -->\n\n\n<p>这似乎有些牵强？好吧，它仅仅一种可能，但是我确实看到过一个高调的网站（不想提是哪个）遇到了这个特殊问题。我试着使用这个网站，但是它崩溃了。我认识这个开发人员，然后我联系到了他。经过一番反复，结果是我曾经安装的一个插件导致了网站崩溃。我联系到插件作者，然后他们更新了代码，现在一切运行正常。</p>\n\n<!-- ## Various Ways to Protect Yourself -->\n\n\n<h2>保护自己的多种方式</h2>\n\n<!-- Although the above code snippets were very small and simple, they all exposed way too many variables to the global namespace. So, how do we protect ourselves? -->\n\n\n<p>虽然上面的代码片段非常简短和简单，但是它们向全局命名空间暴露了太多的变量。那么，我们该如何保护自己呢？</p>\n\n<!-- * **Object Literal** -->\n\n\n<ul>\n<li><strong>对象字面量</strong></li>\n</ul>\n\n\n<!-- The easiest way to help prevent global variable proliferation is to protect yourself with an object literal that limits gathers all objects that would have been global and attaches them to once central object. -->\n\n\n<p>防止全局变量扩展的最简单的方法是，使用一个对象字面量来收集所有全局对象，把它们附加到一个中间对象。</p>\n\n<p>  <script src=\"https://gist.github.com/elijahmanor/4991287.js?file=object-literal.js\">\n  </script></p>\n\n<!-- * **Immediately Invoked Function Expression** -->\n\n\n<ul>\n<li><strong>立即调用的函数表达式</strong></li>\n</ul>\n\n\n<!-- The Immediately Invoked Function Expression (IIFE) is another technique to get around the global issue. This technique is more complicated than the Object Literal, but provides much more power as well. This technique allows the developer to expose public and private properties and methods to the consumer. -->\n\n\n<p>解决全局问题的另一项技术是立即调用的函数表达式（IIFE）。这项技术比对象字面量更复杂，但是也更强大。这项继续允许开发人员向消费者公开公共和私有的属性和方法。</p>\n\n<!-- Before we get into what this looks like, lets work through some of their weird syntax that we are about to see. The scoping of variables in JavaScript is determined via the function scope and not block scope. So, if you have a variable declared inside an `if` statement for example it would be available everywhere inside its containing function. This might seem a little jarring to some developers that are used to C, C++, C#, Java, or similar languages. -->\n\n\n<p>在我们进入正题之前，先解释一些怪异的语法，稍后会看到。在 JavaScript 中，变量的作用域由函数作用域决定，而不是块级作用域。因为，假设如果在一条 'if' 语句中决定了一个变量，这个变量在包含它的函数的所有地方都是可见的。对于曾经使用 C、C++、C#、Java 或类似语言的开发人员来说，这个看起来有点不和谐。</p>\n\n<!-- So, we are going to use this functional scope idea to create an anonymous function (function with no name) and immediately invoke it. -->\n\n\n<p>下面，我们将利用函数作用域这一特性来创建一个匿名函数（没有名字的函数），并立即调用它。</p>\n\n<p>  <script src=\"https://gist.github.com/elijahmanor/4991287.js?file=unwrapped-iife.js\">\n  </script></p>\n\n<!-- Unfortunately, the above snippet doesn't work in JavaScript because it can't parse it correctly. The idea is solid, but the implementation is off just a little bit. Thankfully, there is an easy way to let JavaScript know that we know what we are doing and that is to surround the expression with an extra set of parenthesis. -->\n\n\n<p>不幸的是，上面的代码片段在 JavaScript 中不能工作，因为不能正确的解析他。思路是对的，但是实现有一点点偏差。值得庆幸的，有一种简单的方式让 JavaScript 知道我们在做什么，就是用一组额外的括号包裹这个表达式。</p>\n\n<p>  <script src=\"https://gist.github.com/elijahmanor/4991287.js?file=empty-iife.js\">\n  </script></p>\n\n<!-- The following pattern is known as the Revealing Module Pattern. You should notice the use of the IIFE to create the special functional scope and the note-worthy part is the end where you `return` the parts of the scope that you want to be public to object and anything not returned will be private. -->\n\n\n<p>下面的模式被称为 Revealing Module Pattern。你应该注意到，IIFE 被用于创建特殊的函数作用域，而且在末尾返回了作用域的一部分，它们是你想公开给对象的，而任何没有返回的部分将是私有的。</p>\n\n<p>  <script src=\"https://gist.github.com/elijahmanor/4991287.js?file=revealing-module.js\">\n  </script></p>\n\n<!-- You may also run across this alternate syntax that is popular in many libraries and frameworks. The pattern uses the IIFE, but this one passes in the global variable to use as a namespace. The `window.bird = window.bird || {}` code snippet is a fancy way to check if the `bird` object already exists and if it doesn't then to create a new one. Whatever gets added to the object from within the IIFE becomes public and whatever memory isn't attached to the object stays private. The nice thing about this pattern is that it can be repeated and build up a library with various components. -->\n\n\n<p>你可能也遇到过下面这种替代语法，它在很多库和框架中很流行（很受欢迎）。这种模式使用了 IIFE，但是传入了一个全局变量作为命名空间。代码片段 <code>window.bird = window.bird || {}</code> 以一种奇特的方式来检查 <code>bird</code> 对象是否存在，如果不存在就创建一个新对象。在 IIFE 中，添加到 <code>bird</code> 对象的都变为公开的，而其他的则都变为私有的。可以重复这种模式，用各种组件来构建一个库。</p>\n\n<p>  <script src=\"https://gist.github.com/elijahmanor/4991287.js?file=parameter-iife.js\">\n  </script></p>\n\n<!-- ## Attack! -->\n\n\n<h2>进攻！</h2>\n\n<p>下面是一个用 <a href=\"http://incompl.github.com/boxbox/\">boxbox</a> 构建的简版 Angry Birds，boxbox 是一个用于 <a href=\"https://code.google.com/p/box2dweb/\">box2dweb</a> 的框架，由 <a href=\"http://bocoup.com\">Bocoup</a> 的 <a href=\"http://twitter.com/_gsmith\">Greg Smith</a> 编写。</p>\n\n<!-- > Press the `space bar` to launch the Red Bird and you can also use the arrow keys. -->\n\n\n<blockquote><p>按下<code>空格键</code>来发射红色小鸟，你也可以使用方向键。</p></blockquote>\n\n<p><a href=\"http://jsfiddle.net/hzz3U/1/show\"><img src=\"http://1.bp.blogspot.com/-uVcHLO0YlUo/UUPqxGUmyrI/AAAAAAAAX-I/Xjqh5Qn_rEw/s640/angry-birds-jsfiddle-shadow.png\" alt=\"\" /></a></p>\n\n<!-- ## Conclusion -->\n\n\n<h2>结论</h2>\n\n<!-- These techniques are vital for a front-end application so that it can protect itself from other code and it also gives the opportunity to structure your code in a way that is encapsulated from its surroundings.  -->\n\n\n<p>这些技术对一个前端应用程序是至关重要的，因为它可以保护自己免受其他代码的干扰，并且可以通过封装的方式组织你的代码。</p>\n\n<!-- There are many other frotn-end architecture techniques that have been stolen by the pigs. Tune in next time as the next Angry Bird takes its revenge! Dun, dun, daaaaaaa! -->\n\n\n<p>还有很多其他的前端架构技术被猪偷走了。在下篇文章中，另一只愤怒的小鸟将继续复仇！Dun, dun, daaaaaaa!</p>\n\n<blockquote><p><a href=\"http://nuysoft.com/2013/04/21/angry-birds-of-javascript-orange-bird-templating/#comment-881925473\">@sunnylost</a> 补充：Dun, dun, daaaaaaaaaa! 应该是在模拟背景音乐，类似于这种 <a href=\"http://missingno.ocremix.org/musicpages/game_on.html\">http://missingno.ocremix.org/musicpages/game_on.html</a></p></blockquote>\n"
            ],
            "link": [
              "http://nuysoft.github.com/2013/04/15/angry-birds-of-javascript-red-bird-iife"
            ],
            "guid": [
              "http://nuysoft.github.com/2013/04/15/angry-birds-of-javascript-red-bird-iife"
            ],
            "pubDate": [
              "2013-04-15T00:00:00-07:00"
            ]
          },
          {
            "title": [
              "模拟请求 & 模拟数据"
            ],
            "description": [
              "<blockquote><p>原文：<a href=\"http://www.elijahmanor.com/2013/04/angry-birds-of-javascript-green-bird.html\">Angry Birds of JavaScript: Green Bird - Mocking</a></p>\n\n<p>私货：<a href=\"https://github.com/nuysoft/Mock\">nuysoft/Mock</a></p></blockquote>\n\n<!-- ## Introduction -->\n\n\n<h2>简介</h2>\n\n<p><img src=\"http://4.bp.blogspot.com/-5PVLpWoGRVc/UV4ySyeL9vI/AAAAAAAAZxk/IlyY8pkqXF0/s1600/Angry_birds_wallpaper_3.png\" alt=\"\" /></p>\n\n<!-- ![](http://4.bp.blogspot.com/-5PVLpWoGRVc/UV4ySyeL9vI/AAAAAAAAZxk/IlyY8pkqXF0/s400/Angry_birds_wallpaper_3.png) -->\n\n\n\n\n<!-- A diabolical herd of pigs stole all of the front-end architecture from an innocent flock of birds and now they want it back! A team of special agent hero birds will attack those despicable pigs until they recover what is rightfully theirs, front-end JavaScript architecture! -->\n\n\n<p>一群无法无天的猪从无辜的小鸟那里偷走了所有的前端架构，现在小鸟们要把它们夺回来！一队特殊的小鸟英雄将攻击这些卑鄙的猪，直到夺回原本属于它们的前端 JavaScript 架构！</p>\n\n<!-- Will the birds be successful in the end? Will they defeat their bacon flavored foe? Let's find out together in another nail biting episode of Angry Birds of JavaScript! -->\n\n\n<p>小鸟们最终会成功吗？它们会打败那些培根味儿的敌人吗？让我们一起揭示 JavaScript 之愤怒的小鸟系列的另一个扣人心弦的章节！</p>\n\n<blockquote><p>译注：翻译“bacon flavored foe”时，想起来了《少林足球》里的“做人如果没有梦想，那跟咸鱼有什么区别？”，就翻译成了“咸猪敌人”，<a href=\"http://nuysoft.com/2013/04/21/angry-birds-of-javascript-orange-bird-templating/#comment-881925473\">@sunnylost</a> 建议翻译为“培根味儿的敌人”，应该更准确和有趣些。</p></blockquote>\n\n<!-- > Check out the [**series introduction post**](http://www.elijahmanor.com/2013/03/angry-birds-of-javascript-series.html) for a list of all the birds and their attack powers. -->\n\n\n<blockquote><p>阅读<strong><a href=\"http://www.elijahmanor.com/2013/03/angry-birds-of-javascript-series.html\">系列介绍文章</a></strong>，查看所有小鸟以及它们的攻击力。</p></blockquote>\n\n<!-- ### Previous Attacks -->\n\n\n<h3>战报</h3>\n\n<ul>\n<li><a href=\"http://www.elijahmanor.com/2013/03/angry-birds-of-javascript-red-bird.html\">Red Bird - IIFE</a></li>\n<li><a href=\"http://www.elijahmanor.com/2013/03/angry-birds-of-javascript-blue-bird.html\">Blue Bird - Events</a></li>\n<li><a href=\"http://www.elijahmanor.com/2013/04/angry-birds-of-javascript-yellow-bird.html\">Yellow Bird - RequireJS</a></li>\n<li><a href=\"http://www.elijahmanor.com/2013/04/angry-birds-of-javascript-black-bird.html\">Black Bird - Backbone</a></li>\n<li><a href=\"http://www.elijahmanor.com/2013/04/angry-birds-of-javascript-white-bird.html\">White Bird - Linting</a></li>\n</ul>\n\n\n<!-- ### Green Bird Attacks -->\n\n\n<h3>绿鸟的攻击</h3>\n\n<p><a href=\"http://1.bp.blogspot.com/-8IQeI6F5-d8/UV4ybFGUw7I/AAAAAAAAZxs/jnudV9GSHpM/s1600/green-bird.png\"><img src=\"http://1.bp.blogspot.com/-8IQeI6F5-d8/UV4ybFGUw7I/AAAAAAAAZxs/jnudV9GSHpM/s1600/green-bird.png\" alt=\"\" /></a></p>\n\n<!-- In this post we will take a look at the Green Bird that can penetrate all of those hard to reach places and will mock and spy those stealing swine right where it hurts!. Slowly, one by one, the birds will take back what it theirs to keep! -->\n\n\n<p>在这篇文章中，我们将看看绿鸟，它可以穿越所有那些难以到达的地方，并且伪装和监视那些猪贼！渐渐的，小鸟们将一个接一个地夺回属于它们的东西！</p>\n\n<!-- ## What Was Stolen by the Pigs? -->\n\n\n<h2>猪偷走了什么？</h2>\n\n<!-- For the most part the birds are all front-end web developers only and don't focus on the back-end much at all. As a result the birds have a symbiotic relationship with the Water Buffalo. The Buffalo write the back-end of the application and the birds develop the front-end. The problem with this arrangement is that while the back-end is being developed the birds are left twiddling their feathers until the Buffalo are finished. However, once the back-end is done the pressure is on the birds to deliver while the Buffalo sit idle by the watering hole in the shade. Thankfully, a while back, a Green Bird proposed the idea of mocking the back-end services so they could make progress on the front-end while they waited for the Buffalo to finish their work! The Green Bird introduced a couple of handy libraries to make mocking a much easier process.  -->\n\n\n<p>大多数小鸟是纯粹的 Web 前端开发人员，压根儿就不关注后端。然后小鸟们和水牛（Water Buffalo）就形成了一种共生关系。水牛编写应用的后端，小鸟们则开发前端。这种分工导致的问题是，当后端被开发时，小鸟们只能留下来摆弄自己的羽毛，一直到水牛完工。可是一旦后端完工，交付的压力就落在了小鸟们的身上，而水牛则闲坐在水坑边的树荫下无所事事。幸运的是，一段时间后一只绿鸟提出了模拟后端服务的想法，这样在原本需要等待水牛完工的阶段，小鸟们就可以同步进行开发！这只绿鸟还引入了一些便捷库，使得模拟更加容易。</p>\n\n<!-- However, during a recent invasion the pigs stole the birds' mocking libraries! As a result, one of the Green Birds has been tasked to reclaim what has been stolen. He will use his overwhelming power of trickery to help destroy the pigs in order to take back what is theirs. -->\n\n\n<p>然而在最近的一次入侵中，猪群偷走了小鸟们的模拟库！现在，一只绿鸟被派去找回被盗的模拟库。它将用压倒一切诡计的力量摧毁族群，夺回属于它们的东西。</p>\n\n<!-- ## The Twitter Application -->\n\n\n<h2>Twitter 应用</h2>\n\n<p><img src=\"http://1.bp.blogspot.com/-ZbrUacc6Jn8/UV8-TkAbAaI/AAAAAAAAZz4/HiqK67BDc14/s320/373892_3410142_lz.jpg\" alt=\"\" /></p>\n\n<!-- We are going to take a look at a simple Twitter application that gets the tweets from a specific username. Why Twitter? Well, the Angry Birds have a special relationship with Twitter, especially the Blue Bird ;) -->\n\n\n<p>我们来看一个简单的 Twiter 应用，这个应用将返回一个特定用户的消息。为什么是 Twitter？好吧，因为愤怒的小鸟们和 Twitter 的关系非同寻常，尤其是蓝色的小鸟 ;)</p>\n\n<!-- The following application grabs data from Twitter using JSONP. I thought about using Backbone.js to write the little application, but thought that might be overkill to introduce the mocking concept. You will also notice I am not using a templating engine and that is on purpose. Another Angry Bird will be introducing that concept ;) -->\n\n\n<p>下面的应用通过 JSONP 从 Twitter 抓取数据。我曾经考虑过用 Backbone.js 来编写这个小应用，但是又考虑到这种做法对于介绍模拟概念会是过渡设计。你也会注意到我并没有使用模板引擎，恩，我是故意这么做的。另一只愤怒的小鸟会介绍模板概念 ;)</p>\n\n<p>  <script src=\"https://gist.github.com/elijahmanor/5321634.js?file=twitter.js\">\n  </script></p>\n\n<!-- The above code snippet is running in the below embedded jsFiddle. Feel free to run the code and launch the editor to play around with it. -->\n\n\n<p>上面的代码运行在下面的内嵌 jsFiddle 中。请随意的运行这些代码，然后打开编辑器玩一下。</p>\n\n<!-- ## Twitter Application using api.twitter.com -->\n\n\n<h2>使用 api.twitter.com</h2>\n\n<p>  <iframe allowfullscreen=\"allowfullscreen\" frameborder=\"0\" height=\"300\" src=\"http://jsfiddle.net/KXr8U/1/embedded/result,html\" width=\"100%\">\n  </iframe></p>\n\n<!-- The data that comes back from Twitter looks something like the following screenshot... -->\n\n\n<p>从 Twitter 返回的数据看起来就像下面的截图...</p>\n\n<p><img src=\"http://2.bp.blogspot.com/-7pLXYbHr5Lc/UV9FEJXJVPI/AAAAAAAAZ0A/81W9-kKIt94/s1600/twitter-raw.png\" alt=\"\" /></p>\n\n<!-- ## Mocking Static Data -->\n\n\n<h2>模拟静态数据</h2>\n\n<!-- What if Twitter goes down, is unstable, or you just want to test your application without having internet access? This is where being able to mock the back-end service can be really helpful. Thankfully we can use a jQuery library called Mockjax. All you need to do is call <code>$.mockjax</code> and provide a URL that you want to listen for and a response that you want to be returned. The following is an example of mocking the call to api.twitter.com and passing back some static data. -->\n\n\n<p>假使 Twitter 宕机或者不稳定，或者你只是想在没有互联网接入的情况下测试你的应用，会怎么样？这正是适合模拟后端服务大战拳脚的场景。而且庆幸的是我们可以使用一个称为 Mockjax 的 jQuery 库。你要做的所有事情是调用 <code>$.mockjax</code>，提供一个要监听的 url 和一个期望的响应。下面是一个模拟请求 api.twitter.com 的示例，将返回一些静态数据。</p>\n\n<p>  <script src=\"https://gist.github.com/elijahmanor/5321634.js?file=requests-mocked-static.js\">\n  </script></p>\n\n<p>  <style type=\"text/css\"></p>\n\n<pre><code>.gist .gist-file .gist-data .line-numbers {\n    line-height: 20px;\n}\n</code></pre>\n\n<p>  </style></p>\n\n<!-- Not only is this pretty cool and can be helpful for developing the front-end independent from the back-end, but it also very handy when writing Unit Tests that use Ajax. -->\n\n\n<p>这不仅很酷，还可以帮助前端开发从后端独立出来，而且编写 Ajax 单元测试也非常方便。</p>\n\n<!-- The above code snippet is running in the below embedded jsFiddle. Feel free to run the code and launch the editor to play around with it. -->\n\n\n<p>上面的代码运行在下面的内嵌 jsFiddle 中。请随意的运行这些代码，然后打开编辑器玩一下。</p>\n\n<!-- ### Twitter Application using Mockjax -->\n\n\n<h3>使用 Mockjax</h3>\n\n<p>  <iframe allowfullscreen=\"allowfullscreen\" frameborder=\"0\" height=\"300\" src=\"http://jsfiddle.net/ufqPC/1/embedded/result,html\" width=\"100%\">\n  </iframe></p>\n\n<!-- The data that comes back from Mockjax looks something like the following screenshot... -->\n\n\n<p>Mockjax 返回的数据看起来就像下面的截图...</p>\n\n<p><img src=\"http://4.bp.blogspot.com/-rgQyF9j9VbA/UV9FPdMawYI/AAAAAAAAZ0I/-ESPFAkZwoY/s1600/twitter-mock-static.png\" alt=\"\" /></p>\n\n<!-- ## Mocking Dynamic Semi-Random Data -->\n\n\n<h2>动态模拟半随机数据</h2>\n\n<!-- One of the downsides of this technique is that generally I am pretty unimaginative and lazy when making static data examples. I typically end up have the same object and just increment some of the values by 1 or something. That is fine and all, but it is a nuisance, it takes time, and it doesn't really give you an idea of what the UI could look like. Thankfully there is another nice library for that called mockJSON. You provide a template of what you want your data to look like and then you give it some metadata about what types of fields you want, how many, etc... The following is how I rewrote the previous example, but will randomly generate anywhere from 5 to 10 twitter objects to be displayed. -->\n\n\n<p>这项技术的缺点之一在于，制造静态数据很是乏味无趣。通常我会先构造一些同样的对象，然后仅仅是把某些值加 1 或加一些其他的东西。这么做不错，但是很讨厌很花时间，而且不能让你了解真正的 UI 是什么样子。幸运的是还有一个非常棒的、称为 mockJSON 的库。你需要提供一个表示真实数据的模板，指定某些字段的期望类型，等等，还有很多... 下面演示的是我如何重写之前的例子，而且会随机生成 5 到 10 个要显示的消息对象。</p>\n\n<p>  <script src=\"https://gist.github.com/elijahmanor/5321634.js?file=requests-mocked-dynamic.js\">\n  </script></p>\n\n<!-- The above code snippet is running in the below embedded jsFiddle. Feel free to run the code and launch the editor to play around with it. -->\n\n\n<p>上面的代码运行在下面的内嵌 jsFiddle 中。请随意的运行这些代码，然后打开编辑器玩一下。</p>\n\n<!-- Twitter Application using Mockjax & mockJSON -->\n\n\n<h3>使用 Mockjax 和 mockJSON</h3>\n\n<p>  <iframe allowfullscreen=\"allowfullscreen\" frameborder=\"0\" height=\"300\" src=\"http://jsfiddle.net/cHS9q/1/embedded/result,html\" width=\"100%\">\n  </iframe></p>\n\n<!-- The data that comes back from Mockjax with mockJSON looks something like the following screenshot... -->\n\n\n<p>Mockjax 和 mockJSON 返回的数据看起来就像下面的截图...</p>\n\n<p><img src=\"http://4.bp.blogspot.com/-mvenxQzawwU/UV9FW2MqpUI/AAAAAAAAZ0Q/6TA0UmXP-9w/s1600/twitter-mock-dynamic.png\" alt=\"\" /></p>\n\n<!-- ## Attack! -->\n\n\n<h2>攻击！</h2>\n\n<p>下面是一个用 <a href=\"http://incompl.github.com/boxbox/\">boxbox</a> 构建的简版 Angry Birds，boxbox 是一个用于 <a href=\"https://code.google.com/p/box2dweb/\">box2dweb</a> 的框架，由 <a href=\"http://bocoup.com\">Bocoup</a> 的 <a href=\"http://twitter.com/_gsmith\">Greg Smith</a> 编写。</p>\n\n<!-- > Press the `space bar` to launch the Green Bird and you can also use the arrow keys. -->\n\n\n<blockquote><p>按下<code>空格键</code>来发射绿鸟，你也可以使用方向键。</p></blockquote>\n\n<p><a href=\"http://jsfiddle.net/4QG5Q/27/show\"><img src=\"http://3.bp.blogspot.com/-eLUAASpDUy0/UV0NIExF6RI/AAAAAAAAZwA/uCKAm54p5W4/s640/Screenshot+on+4.4.2013+at+12.14.59+AM.png\" alt=\"\" /></a></p>\n\n<!-- ## Conclusion -->\n\n\n<h2>结论</h2>\n\n<!-- It can be difficult to develop both the front-end and back-end independently. Thankfully there are some techniques and libraries today that can enable the front-end to develop and prototype separate from the back-end progress. The mocking techniqiue with static data can also be helpful when Unit Testing your code as well. -->\n\n\n<p>独立开发前端和后端可能有些困难。然而庆幸的是，现在前端开发人员可以借助一些技术和库，从而独立于后端的进度进行开发和构建原型。模拟静态数据这一技术还可以帮助构建单元测试。</p>\n\n<!-- There are many other front-end architecture techniques that have been stolen by the pigs. Tune in next time as the next Angry Bird takes its revenge! Dun, dun, daaaaaaa! -->\n\n\n<p>还有很多其他的前端架构技术被猪偷走了。在下篇文章中，另一只愤怒的小鸟将继续复仇！Dun, dun, daaaaaaa!</p>\n\n<blockquote><p><a href=\"http://nuysoft.com/2013/04/21/angry-birds-of-javascript-orange-bird-templating/#comment-881925473\">@sunnylost</a> 补充：Dun, dun, daaaaaaaaaa! 应该是在模拟背景音乐，类似于这种 <a href=\"http://missingno.ocremix.org/musicpages/game_on.html\">http://missingno.ocremix.org/musicpages/game_on.html</a></p></blockquote>\n"
            ],
            "link": [
              "http://nuysoft.github.com/2013/04/15/angry-birds-of-javascript-green-bird-mocking"
            ],
            "guid": [
              "http://nuysoft.github.com/2013/04/15/angry-birds-of-javascript-green-bird-mocking"
            ],
            "pubDate": [
              "2013-04-15T00:00:00-07:00"
            ]
          },
          {
            "title": [
              "前端 JavaScript 架构"
            ],
            "description": [
              "\n\n<ul>\n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n      \n        <li>\n            <a href=\"/2013/04/21/angry-birds-of-javascript-yellow-bird-requirejs\">模块化 &amp; 依赖管理 &amp; 性能优化</a>\n            <br>\n            <span>RequireJS。Web 前端应用可以快速变得相当复杂。理想的做法是提供某种结构和依赖关系管理，以及用一种简单的方式优化最终结果。</span>\n        </li>\n      \n    \n  \n    \n      \n        <li>\n            <a href=\"/2013/04/21/angry-birds-of-javascript-orange-bird-templating\">模板 - 分离展现和逻辑</a>\n            <br>\n            <span>Templating。在代码中混入标记会导致一些让人讨厌的代码，这样的代码繁琐、单调，并且难以维护。像 Underscore 和 Handlebars 这样的库提供了一种清晰的方式，将展现描述从逻辑中分离出来。你可以自由选择使用什么库，但是我鼓励你多进行一些比较，找到最适合你的库。</span>\n        </li>\n      \n    \n  \n    \n      \n        <li>\n            <a href=\"/2013/04/21/angry-birds-of-javascript-black-bird-backbone\">应用分层 &amp; 解耦合</a>\n            <br>\n            <span>Model &amp; Collection &amp; View。Web 前端应用可以快速变得相当复杂。在你知道这点之前，如果你不小心就会导致关系混乱。值得庆幸的是，Backbone.js 提供了组件来帮助你把应用分割为可用的小模块，并且每个小模块各司其职。</span>\n        </li>\n      \n    \n  \n    \n      \n        <li>\n            <a href=\"/2013/04/20/angry-birds-of-javascript-blue-bird-events\">事件 &amp; 消息</a>\n            <br>\n            <span>Events &amp; Messaging。在 Web 应用中可以使用事件和消息实现组件通信。事件允许一个组件同自身通信，消息则允许一个组件以非硬编码的方式监听其他组件。</span>\n        </li>\n      \n    \n  \n    \n      \n        <li>\n            <a href=\"/2013/04/19/angry-birds-of-javascript-mighty-eagle-automation\">自动化</a>\n            <br>\n            <span>Automation。拥抱 Grunt、Bower 和 Yeoman 可以帮助自动化开发、测试、部署过程中的各个环节。</span>\n        </li>\n      \n    \n  \n    \n      \n        <li>\n            <a href=\"/2013/04/18/angry-birds-of-javascript-white-bird-linting\">代码质量</a>\n            <br>\n            <span>Coding Standard, Linting, Analysis。前端 Web 应用可以很快变得相当复杂。如果开发人员不能达成共识，事情可能马上土崩瓦解，特别是在一个大型项目中。形成统一的代码标准和使用一些工具来避免问题，才能真正有助于项目成功。</span>\n        </li>\n      \n    \n  \n    \n      \n        <li>\n            <a href=\"/2013/04/16/angry-birds-of-javascript-big-brother-bird-patterns\">模式</a>\n            <br>\n            <span>Patterns。成熟的设计模式和有限状态机。</span>\n        </li>\n      \n    \n  \n    \n      \n        <li>\n            <a href=\"/2013/04/15/angry-birds-of-javascript-red-bird-iife\">立即调用的函数表达式</a>\n            <br>\n            <span>Immediately-invoked Function Expression。保护代码免受其他代码的干扰，并且通过封装的方式组织你的代码。</span>\n        </li>\n      \n    \n  \n    \n      \n        <li>\n            <a href=\"/2013/04/15/angry-birds-of-javascript-green-bird-mocking\">模拟请求 &amp; 模拟数据</a>\n            <br>\n            <span>Mockjax &amp; mockJSON。前端开发人员可以借助一些技术和库，从而独立于后端的进度进行开发和构建原型。模拟静态数据还可以帮助构建单元测试。</span>\n        </li>\n      \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n</ul>\n\n"
            ],
            "link": [
              "http://nuysoft.github.com/2013/04/15/angry-birds-of-javascript"
            ],
            "guid": [
              "http://nuysoft.github.com/2013/04/15/angry-birds-of-javascript"
            ],
            "pubDate": [
              "2013-04-15T00:00:00-07:00"
            ]
          },
          {
            "title": [
              "客户端模板"
            ],
            "description": [
              "<blockquote><p>原文：<a href=\"http://coding.smashingmagazine.com/2012/12/05/client-side-templating/\">Client-Side Templating</a>, From The Server To The Client, 2012.12.5</p></blockquote>\n\n<!-- Using templates in the browser is becoming more and more widespread. Moving application logic from the server to the client, and the increasing usage of MVC-like patterns (model–view–controller) inspired templates to embrace the browser. This used to be a server-side only affair, but templates are actually very powerful and expressive in client-side development as well. -->\n\n\n<p>在浏览器中使用模板正变得越来越广泛。随着应用程序的逻辑从服务端转移到客户端，以及类似 MVC（模型-视图-控制）的模式的广泛使用，促使模板开始拥抱浏览器。这曾经仅仅是服务端的事务，但其实模板在客户端同样非常强大并且极富表现力。</p>\n\n<!-- ![](http://media.smashingmagazine.com/wp-content/uploads/2012/12/client-side-template.jpg)\nImage Credit: Viktor Hertz -->\n\n\n\n\n<!-- ## Why Would You Use It? -->\n\n\n<h2>为什么要使用模板？</h2>\n\n<!-- In general, leveraging templates is a great way to separate markup and logic in views, and to maximize code reusability and maintainability. With a syntax close to the desired output (i.e. HTML), you have a clear and fast way to get things done. Although templates can be used to output any kind of text, in this article we provide examples using HTML, since that is what we want in client-side development. -->\n\n\n<p>通常，在视图中利用模板分离标记和逻辑是非常棒的做法，并且最大限度的提高了代码的可重用性和可维护性。使用近似于最终输出（即 HTML）的语法，你可以快速和清晰的把事情做好。虽然模板适用于任意类型的文本输出，不过在这篇文章中，我们使用 HTML 作为示例，因为这正是我们在客户端开发中想要的。</p>\n\n<!-- In today’s dynamic applications, the client frequently needs to update the user interface (UI). This might be done by fetching an HTML fragment from the server that can be readily inserted into the document. Yet this requires the server to support delivering such fragments (as opposed to complete pages). Moreover, as a client-side developer who is responsible for the markup, **you want to have full control over your templates**. No need to know anything about Smarty, Velocity, ASP, some other obscure server-side syntax or even worse: dealing with spaghetti code such as HTML containing those infamous `< ?` or `< %` tags all over the place. -->\n\n\n<p>在如今的动态应用程序中，客户端经常需要更新用户界面。这个需求可以通过从服务端获取一个易于插入文档的 HTML 片段实现。然而，这就要求服务端支持提供这样的片段（而不是完整的页面）。此外，作为负责这些标记的客户端开发人员，又<strong>想对模板有完全的控制权</strong>。客户端开发人员也没有必要知道关于 Smarty、Velocity、ASP 以及其他晦涩的服务端语法，甚至更糟糕的：处理意大利面条式的代码，例如 HTML 中到处充斥着臭名昭著的 <code>&lt;?</code> 或 <code>&lt;%</code> 标签。</p>\n\n<!-- So let’s take a fresh look at a viable alternative: client-side templating. -->\n\n\n<p>因此，让我们重新审视一个可行的替代方案：客户端模板。</p>\n\n<!-- ## First Impressions -->\n\n\n<h2>第一印象</h2>\n\n<!-- For starters, I’d like to give a definition of the term “template”. Here is a [good definition](http://foldoc.org/template) from foldoc: -->\n\n\n<p>对于初学者，<a href=\"http://foldoc.org/\">在线计算机词典</a>对术语“模板”给出了<a href=\"http://foldoc.org/template\">很好的定义</a>：</p>\n\n<!-- >“A document that contains parameters, identified by some special syntax, that are replaced by actual arguments by the template processing system.” -->\n\n\n<blockquote><p>“一个文档，包含了由特殊语法定义的参数，参数被模板处理系统替换为实际的参数值。”</p></blockquote>\n\n<!-- Let’s observe an example, and see what a basic template might look like: -->\n\n\n<p>让我们看一个例子，一个基本的模板可能看起来像是这样：</p>\n\n<pre><code>&lt;h1&gt;{{title}}&lt;/h1&gt;\n&lt;ul&gt;\n    {{#names}}\n        &lt;li&gt;{{name}}&lt;/li&gt;\n    {{/names}}\n&lt;/ul&gt;\n</code></pre>\n\n<!-- This probably looks pretty familiar if you know HTML. It contains HTML tags with some placeholders. We will replace them with some actual data. For instance with this simple object: -->\n\n\n<p>这可能看起来很熟悉，如果你了解 HTML 的话。上面的例子包含了带有一些占位符的 HTML 标签。我们将用一些真实数据替换这些占位符。例如用下面的简单对象：</p>\n\n<pre><code>var data = {\n    \"title\": \"Story\",\n    \"names\": [\n        {\"name\": \"Tarzan\"},\n        {\"name\": \"Jane\"}\n    ]\n}\n</code></pre>\n\n<!-- Combining the template and data should result in the following HTML: -->\n\n\n<p>结合模板和数据将生成下面的 HTML：</p>\n\n<pre><code>&lt;h1&gt;Story&lt;/h1&gt;\n&lt;ul&gt;\n    &lt;li&gt;Tarzan&lt;/li&gt;\n    &lt;li&gt;Jane&lt;/ul&gt;\n&lt;/ul&gt;\n</code></pre>\n\n<!-- With the template and data separated, it becomes easy to maintain the HTML. For example, changing tags or adding classes will only need changes in the template. Additionally, adding an attribute to repeating elements such as the `<li>` element only needs to be done once. -->\n\n\n<p>因为模板和数据的分离，HTML 变得易于维护。例如，想要改变标签或添加样式，只需要在模板中修改即可。再例如，想要给重复元素添加一个属性，例如 <code>&lt;li&gt;</code> 元素，也只需要修改一次。</p>\n\n<!-- ## Template Engine -->\n\n\n<h2>模板引擎</h2>\n\n<!-- The syntax of the template (i.e. the format of the placeholders such as ``) depends on the template engine you want to use. This engine takes care of parsing the templates, and replacing the placeholders (variables, functions, loops, etc.) with the actual data it is provided. -->\n\n\n<p>模板的语法（即占位符的格式，例如 <code>{{title}}</code>）取决于你想要使用的模板引擎。模板引擎负责解析模板，并且用提供的真实数据替换替换占位符（变量、函数、循环等）。</p>\n\n<!-- Some template engines are `logic-less`. This doesn’t mean you can only have simple placeholders in a template, but the features are pretty limited to some intelligent tags (i.e. array iteration, conditional rendering, etc.). Other engines are more feature-rich and extensible. Without going into details here, a question to ask yourself is whether and how much logic you allow in your templates. -->\n\n\n<p>某些模板引擎是<code>弱逻辑</code>的。虽然这并不意味着模板中只能有简单的占位符，但是某些智能标签（即数组迭代、条件渲染）的功能确实相当有限。其他模板引擎则有更丰富的功能，并且可扩展。在这里暂不纠结细节，你需要要考虑的问题是，在你的模板中是否允许出现逻辑，以及允许出现多少逻辑。</p>\n\n<!-- Although each template engine has its own API, usually you will find methods such as `render()` and `compile()`. The **render** process is the creation of the end result by putting the actual data in the template. In other words, the placeholders are replaced with the actual data. And if there is any templating logic, it is executed. To **compile** a template means to parse it, and translate it into a JavaScript function. Any templating logic is translated into plain JavaScript, and data can be fed to the function, which concatenates all the bits and pieces together in an optimized way. -->\n\n\n<p>虽然每个模板引擎有自己的 API，但是通常你会找到诸如  <code>render()</code> 和 <code>compile()</code> 这样的方法。<strong>渲染</strong>过程是指，将真实数据放入模板从而创造最终结果的过程。换句话说，占位符被替换为真实数据的过程。并且，如果含有任何模板逻辑，也将被执行。<strong>编译</strong>一个模板，意味着解析模板，并把模板翻译为一个 JavaScript 函数。任何模板逻辑都会被翻译为普通的 JavaScript 代码，并且可以将数据传入翻译后的函数，函数则将所有的点点滴滴以一种优化的方法串联在一起。</p>\n\n<!-- ## A Mustache Example -->\n\n\n<h2>Mustache 示例</h2>\n\n<!-- The production of the example above can be performed by using a template engine, e.g. `mustache.js`. This uses the popular **Mustache** templating syntax. More about them, and alternatives, later. Let’s take a look at a little JavaScript to produce some results: -->\n\n\n<p>可以使用一个模板引擎生成上面例子中的结果，例如 <code>mustache.js</code>。上面的例子使用了时下流行的 <strong>Mustache</strong> 模板语法。稍后会讲到关于模板语法和替代品的更多内容，暂且按下不表。让我们先来看看如何用 JavaScript 生成同样的结果：</p>\n\n<pre><code>var template = '&lt;h1&gt;{{title}}&lt;/h1&gt;&lt;ul&gt;{{#names}}&lt;li&gt;{{name}}&lt;/li&gt;{{/names}}&lt;/ul&gt;';\nvar data = {\"title\": \"Story\", \"names\": [{\"name\": \"Tarzan\"}, {\"name\": \"Jane\"}]};\n\nvar result = Mustache.render(template, data);\n</code></pre>\n\n<!-- Now we want to show this in the page. In plain JavaScript this could be done like this: -->\n\n\n<p>现在，我们想要把结果显示到页面中。在普通的 JavaScript 中，可以这样实现：</p>\n\n<pre><code>document.body.innerHTML = result;\n</code></pre>\n\n<!-- That’s all! You can try the above in your browser by placing the Mustache script before your own code: -->\n\n\n<p>这就是全部了！你可以把 Mustache 脚本放到你自己的代码之前，然后在本地尝试上面的例子：</p>\n\n<pre><code>&lt;script src=\"https://raw.github.com/janl/mustache.js/master/mustache.js\"&gt;&lt;/script&gt;\n</code></pre>\n\n<!-- Or, you can try this example at [jsFiddle](http://jsfiddle.net/webpro/huuDd/). -->\n\n\n<p>或者，你可以试试 <a href=\"http://jsfiddle.net/webpro/huuDd/\">jsFiddle</a> 上的例子。</p>\n\n<!-- ## Organizing Templates -->\n\n\n<h2>组织模板</h2>\n\n<!-- If you’re like me, you probably don’t like to have the HTML in one long string. This is hard to read, and hard to maintain. Ideally, we can put our templates in separate files so we still have all the benefits of syntax highlighting, and the ability to properly indent the lines of HTML for readability. -->\n\n\n<p>你可能不希望持有一个长字符串的 HTML，就像我一样。这样很难读，也很难维护。理想的情况是，我们可以把模板放到单独的文件中，这样仍然有语法高亮，并且能正确的缩进 HTML，以保持代码的可行性。</p>\n\n<!-- But this leads to another issue. If our project contains a lot of templates, we don’t want to load all of those files separately, since this issues a lot of (Ajax) requests. This would be bad for performance. -->\n\n\n<p>但是这会导致另一个问题。如果我们的项目包含了很多模板，而我们又不希望单独加载所有这些文件，因为这会导致很多（Ajax）请求。这对性能不利。</p>\n\n<!-- ### SCENARIO 1: SCRIPT TAGS -->\n\n\n<h3>方案1：SCRIPT 标签</h3>\n\n<!-- An often seen solution is to put all the templates within `<script>` tags with an alternative `type` attribute, e.g. `type=\"text/template\"` (which is ignored for rendering or parsing by the browser): -->\n\n\n<p>经常看到的解决方案是把所有模板放入 <code>&lt;script&gt;</code> 标签，并为属性 <code>type</code> 设置一个另类的值，例如 <code>type=\"text/template\"</code>（浏览器将忽略该标签，不渲染也不解析）：</p>\n\n<pre><code>&lt;script id=\"myTemplate\" type=\"text/x-handlebars-template\"&gt;\n    &lt;h1&gt;{{title}}&lt;/h1&gt;\n    &lt;ul&gt;\n        {{#names}}\n            &lt;li&gt;{{name}}&lt;/li&gt;\n        {{/names}}\n    &lt;/ul&gt;\n&lt;/script&gt;\n</code></pre>\n\n<!-- This way, you can put all of your templates in the HTML document and prevent all the extra Ajax requests to those templates. -->\n\n\n<p>通过这种方式，你可以把所有模板放在 HTML 文档中，并防止了对这些模板额外的 Ajax 请求。</p>\n\n<!-- The content of such a script tag can then be used later in your JavaScript as a template. The following code example, this time using the Handlebars templating engine and a bit of jQuery, uses the previous `<script>` tag: -->\n\n\n<p>在你的 JavaScript 中，类似这样一个 script 标签的内容可以稍后作为模板使用。下面的代码示例使用了前面的 <code>&lt;script&gt;</code> 标签，注意这次我们使用了 Handlebars 模板引擎和一点点 jQuery：</p>\n\n<pre><code>var template = $('#myTemplate').html();\nvar compiledTemplate = Handlebars.compile(template);\nvar result = compiledTemplate(data);\n</code></pre>\n\n<!-- You can try this example as well at [jsFiddle](http://jsfiddle.net/webpro/9xwum/). -->\n\n\n<p>你也可以在 <a href=\"http://jsfiddle.net/webpro/9xwum/\">jsFiddle</a> 上试试这个例子。</p>\n\n<!-- The result here is the same as in our Mustache example. Handlebars can use Mustache templates as well, so we use the same template here. There is one (important) difference though, which is that Handlebars is using an intermediate step to get the HTML result. It first compiles the template into a JavaScript function (we named it `compiledTemplate` here). This function is then executed using the data as its only argument, returning the final output. -->\n\n\n<p>生成的结果与 Mustache 示例相同。Handlebars 也可以使用 Mustache 模板，因为我们在这里使用了相同的模板。不过有一个重要的区别，Handlebars 使用一个中间步骤来得到 HTML 结果。它首先把模板编译为一个 JavaScript 函数（我们把它命名为 <code>compiledTemplate</code>）。然后该函数被执行，数据作为其唯一的参数，最后返回最终的输出。</p>\n\n<!-- ### SCENARIO 2: PRECOMPILED TEMPLATES -->\n\n\n<h3>方案2：预编译模板</h3>\n\n<!-- While only one function to perform the template rendering may seem convenient, there are significant advantages to splitting up the compilation and rendering process. Most importantly, this allows for the compilation part to happen on the server-side. We can execute JavaScript on the server (e.g. using Node), and some of the templating engines support this precompilation of templates. -->\n\n\n<p>虽然只用一个函数执行模板渲染可能看起来很方便，但是分离编译和渲染过程有很大的优势。最重要的是允许编译部分发生在服务端。我们可以在服务端执行 JavaScript（例如使用 Node），并且一些模板引擎支持模板预编译。</p>\n\n<!-- Putting it all together, we can organize and serve a single JavaScript file (say, `compiled.js`) that contains multiple, precompiled templates. This could roughly look like this: -->\n\n\n<p>我们可以组织和提供单一的 JavaScript 文件（假设是 <code>compiled.js</code>），其中包含了多个预编译过的模板。大致看起来会是这样：</p>\n\n<pre><code>var myTemplates = {\n    templateA: function() { ….},\n    templateB: function() { ….};\n    templateC: function() { ….};\n};\n</code></pre>\n\n<!-- Then, in the application code we only need to populate the precompiled template with data: -->\n\n\n<p>然后，我们只需要在应用代码中用数据来填充预编译模板：</p>\n\n<pre><code>var result = myTemplates.templateB(data);\n</code></pre>\n\n<!-- This is generally a far better-performing approach than putting templates within `<script>` tags as discussed before, since the client can skip the compilation part. Depending on your application stack, this approach is not necessarily harder to accomplish, as we’ll see next. -->\n\n\n<p>较之前面讨论过的把模板放入 <code>&lt;script&gt;</code> 标签，通常这是一个性能更好的办法，因为客户端可以跳过编译部分。根据你的应用程序架构，这个方案很有必要并且不是难以完成，接下我们会看到如何实现。</p>\n\n<!-- **Node.js example** -->\n\n\n<p><strong>Node.js 示例</strong></p>\n\n<!-- Any template precompilation script should at least do the following: -->\n\n\n<p>任何模板预编译脚本至少应该做到以下几点：</p>\n\n<!-- * read the template files,\n* compile the templates,\n* combine the resulting JavaScript functions in one or more files. -->\n\n\n<ul>\n<li>读取模板文件，</li>\n<li>编译模板，</li>\n<li>把编译后的 JavaScript 函数合并到一个或多个文件。</li>\n</ul>\n\n\n<!-- The next basic Node.js script does all that (using the Hogan.js templating engine): -->\n\n\n<p>下面的 Node.js 脚本实现了上述所有步骤（使用 Hogan.js 模板引擎）：</p>\n\n<pre><code>var fs = require('fs'),\n    hogan = require('hogan.js');\n\nvar templateDir = './templates/',\n    template,\n    templateKey,\n    result = 'var myTemplates = {};';\n\nfs.readdirSync(templateDir).forEach(function(templateFile) {\n\n    template = fs.readFileSync(templateDir + templateFile, 'utf8');\n    templateKey = templateFile.substr(0, templateFile.lastIndexOf('.'));\n\n    result += 'myTemplates[\"'+templateKey+'\"] = ';\n    result += 'new Hogan.Template(' + hogan.compile(template, {asString: true}) + ');'\n\n});\n\nfs.writeFile('compiled.js', result, 'utf8');\n</code></pre>\n\n<!-- This reads all files in the **templates/** folder, compiles the templates and writes them to **compiled.js**. -->\n\n\n<p>上面的 Node.js 示例读取目录 <strong>templates/</strong> 中的所有文件，编译模板，并把它们写入 <strong>compiled.js</strong>。</p>\n\n<!-- Note that this is highly unoptimized code, and does not include any error handling. Still, it does the job, and shows that it doesn’t require a lot of code to precompile templates. -->\n\n\n<p>注意，这是高度未优化的代码，并且不包含任何任何错误处理。不过，它确实完成了任务，并且表明了预编译模板不需要大量代码。</p>\n\n<!-- ### SCENARIO 3: AMD & REQUIREJS -->\n\n\n<h3>方案3：AMD 与 REQUIREJS</h3>\n\n<!-- The Asynchronous Module Definition (AMD) is gaining more and more traction. Decoupled modules are often a great way to organize an application. One of the most popular module loaders is RequireJS. In a module definition, dependencies can be specified, which will be resolved and made available to the actual module (factory). -->\n\n\n<p>异步模板定义（AMD）正在焕发越来越多的活力。解耦模块往往是组织应用程序的一种很好的方式。RequireJS 是最流行的模块加载器之一。在一个模块的定义中，可以指定依赖关系，依赖的模块将被解析并且在当前模块（工厂）中可用。</p>\n\n<!-- In the context of templates, RequireJS has a “text” plugin that allows you to specify text-based dependencies. AMD dependencies are treated as JavaScript by default, but templates are just text (e.g. HTML), so we use the plugin for that. For example: -->\n\n\n<p>RequireJS 的“text”插件允许你指定基于文本的依赖。AMD 依赖默认被当作 JavaScript 处理，但是模板只是文本（例如 HTML），所有我们使用“text”插件来指定模板依赖。例如：</p>\n\n<pre><code>define(['handlebars', 'text!templates/myTemplate.html'], function(Handlebars, template) {\n\n    var myModule = {\n\n        render: function() {\n\n            var data = {\"title\": \"Story\", \"names\": [{\"name\": \"Tarzan\"}, {\"name\": \"Jane\"}]};\n            var compiledTemplate = Handlebars.compile(template);\n            return compiledTemplate(data);\n\n        }\n    };\n\n    return myModule;\n});\n</code></pre>\n\n<!-- This way, the advantage lies (only) in the ability to organize the templates in separate files. This is nice, but it needs an extra Ajax request to get the template, and it still needs to compile the template client-side. However, the extra request can be removed by using the `r.js` optimizer that comes with RequireJS. This resolves dependencies, and will “inline” the templates (or any dependency) into this module definition, vastly reducing the number of requests. -->\n\n\n<p>这种方式的优势仅仅在于组织不同文件中的模板。这很不错，但是仍然需要一个额外的 Ajax 请求来获取模板，仍然需要在客户端编译模板。然而，额外的请求可以通过使用 RequireJS 的 <code>r.js</code> 优化器来避免。<code>r.js</code> 解析依赖关系，并且将模板（或任何依赖）内联在当前模块定义中，从而极大地降低请求数。</p>\n\n<!-- The absence of a precompilation step can be solved in a couple of ways. It may come to mind to have the optimizer also precompile the templates (e.g. we could write a plugin for `r.js`). But that would require a change in the module definition as well, since we would be using a template string before optimization, and a template function afterwards. Yet this would not be terribly hard to deal with, either by checking for this variable type, or by abstracting away this logic (in either the plugin or the application). -->\n\n\n<p>预编译步骤的缺乏可以通过多种方式解决。你可以会考虑让优化器同时预编译模板（例如，我们可以为 <code>r.js</code> 编写一个插件）。但是，这同时需要改变模块的定义，因为在优先前我们使用的是模板字符串，优化之后使用又是模板函数。不过这不是非常难处理的问题，可以通过检查变量类型或者抽象这部分逻辑（或者在插件中，或者在应用程序中）解决。</p>\n\n<!-- ### WATCHING TEMPLATES -->\n\n\n<h3>监听模板</h3>\n\n<!-- In both scenarios #2 and #3, we can do even better by treating our templates as uncompiled source files. Just like CoffeeScript, or Less or SCSS files. We can have our template files watched for changes during development, and recompile them automatically when a file is changed, i.e. just like you would compile CoffeeScript into JavaScript. This way, we’re always dealing with precompiled templates in our code, and the optimizer effortlessly inlines the precompiled templates in the build process. -->\n\n\n<p>在方案2和方案3中，通过把模板当作未编译的源文件，我们可以做的更好。就像 CoffeeScript、Less、SCSS 文件。我们可以在开发过程中监听模板的变化，当然文件改变时自动重编译它们，就像你会把 CoffeeScript 编译为 JavaScript 一样。这样一来，我们在代码中始终处理的是预编译后的模板，并且在构建过程中优化器可以毫不费力的内联预编译后的模板。</p>\n\n<pre><code>define(['templates/myTemplate.js'], function(compiledTemplate) {\n\n    var myModule = {\n\n        render: function() {\n\n            var data = {\"title\": \"Story\", \"names\": [{\"name\": \"Tarzan\"}, {\"name\": \"Jane\"}]};\n            return compiledTemplate(data);\n\n        };\n    };                \n\n    return myModule;\n}\n</code></pre>\n\n<!-- ## Performance Considerations -->\n\n\n<h2>性能注意事项</h2>\n\n<!-- Rendering *UI* updates by using client-side templates is often the way to go. Still, the best performance for the initial *full page* load is achieved by serving that page as a whole. This allows the browser to render the HTML as is without requiring any JavaScript parsing or extra requests for data. This might be a challenge, especially for pages that are both dynamic and require the best initial loading times possible. Then, ideally, templates are being developed and reused on the client and the server to both support the best performance and still be maintainable. -->\n\n\n<p>使用客户端模板更新 <em>UI</em> 往往是不可避免的事情。尽管如此，最佳性能仍然是作为一个整体由服务端提供<em>完整的初始化页面</em>。这样浏览器渲染 HTML 时不需要任何 JavaScript 解析或额外的数据请求。这可能是一个挑战，尤其当页面是动态的，同时又要求最佳的初始化时间。然后，理想情况下，模板可以在客户端和服务端之间开发和重用，提供最佳性能的同时仍然易于维护。</p>\n\n<!-- Two questions to consider here are: -->\n\n\n<p>这里需要考虑两个问题：</p>\n\n<!-- * What part of my application is mostly dynamic, and what part requires the best possible initial loading times?\n* Do you want to move the processing to the client, or should the server do the heavy lifting? -->\n\n\n<ul>\n<li>应用程序的哪部分是动态的，哪部分要求最佳初始化加载时间？</li>\n<li>是把处理过程转移到客户端，还是由服务端做繁重的工作？</li>\n</ul>\n\n\n<!-- The answer can only be given by actually measuring different approaches. Yet by using precompiled templates, the client usually doesn’t have a very hard time rendering them on the fly. And in case you want to reuse templates on the client and server, you will find a logic-less template syntax to be the most versatile. -->\n\n\n<p>答案只能通过测试不同的方法给出。然后通过使用预编译模板，客户端渲染模板时通常不会花费很多时间。另外，如果你想要在客户端和服务端之间重用模板，你会发现弱逻辑模板语法会是最合适的。</p>\n\n<!-- ## Conclusion -->\n\n\n<h2>结论</h2>\n\n<!-- We have seen many strengths of client-side templating, including: -->\n\n\n<p>我们已经看到了客户端模板的许多优势，包括：</p>\n\n<!-- \n* Application servers and APIs are best at serving just the data (i.e. JSON); client-side templates fit in perfectly.\n* HTML and JavaScript naturally match the skills of client-side developers.\n* Using templates enforces a good practice of separating presentation and logic.\n* The templates can be fully precompiled and cached, this leaves only the actual data to be refreshed from server.\n* Moving the rendering phase from server to client may positively affect performance. \n-->\n\n\n\n\n<ul>\n<li>应用程序服务端和 API 最擅长仅仅提供数据（例如 JSON）；而客户端模板实现了完美融合。</li>\n<li>HTML 和 JavaScript 天然地匹配前端开发人员的技能。</li>\n<li>使用模板强化了分离展现和逻辑这一最佳实践。</li>\n<li>模板完全可以预编译和缓存，只剩下从服务端获取和更新实际的数据。</li>\n<li>把渲染环节从服务端转移到客户端可以提升性能。</li>\n</ul>\n\n\n\n\n<!-- We have been looking at quite some aspects of (client-side) templating. Hopefully by now you have a better understanding of the concept, and why you would use it. -->\n\n\n<p>我们一直在考虑（客户端）模板的各个方面。希望你现在对模板的概念以及为什么要使用模板有了一个更好的理解。</p>\n\n<h2>作者 Lars Kappert</h2>\n\n<p><img src=\"http://0.gravatar.com/avatar/24f5c266f0241825b12bed1a43120022?s=78&amp;d=http%3A%2F%2F0.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D78&amp;r=G\" alt=\"\" /></p>\n\n<p>Lars Kappert is a freelance front-end developer at WebPro based in The Netherlands working as an architect, performance tuner, and developer.</p>\n"
            ],
            "link": [
              "http://nuysoft.github.com/2013/04/08/client-side-templating"
            ],
            "guid": [
              "http://nuysoft.github.com/2013/04/08/client-side-templating"
            ],
            "pubDate": [
              "2013-04-08T00:00:00-07:00"
            ]
          },
          {
            "title": [
              "ECMAScript 6 and Spread Operator"
            ],
            "description": [
              "<blockquote><p>原文：<a href=\"http://ariya.ofilabs.com/2013/03/es6-and-spread-operator.html\">ECMAScript 6 and Array Comprehension</a></p></blockquote>\n\n<!-- We have seen how a [rest parameter](http://ariya.ofilabs.com/2013/03/es6-and-rest-parameter.html) can help the handling of a variable number of function arguments. What about the other way around? Can we turn an array into a series of function arguments? Apparently, ECMAScript 6 defines a new type of operator called the **spread operator** which does exactly that. -->\n\n\n<p>我们已经看到了<a href=\"http://ariya.ofilabs.com/2013/03/es6-and-rest-parameter.html\">可变参数</a>可以帮助处理可变数目的函数参数。其他方式怎么样呢？我们可以把一个数组转换成连续的函数参数吗？显然地，ECMAScript 6 定义了一个称为<strong>展开操作符</strong>的新操作符，用于处理这个操作。</p>\n\n<!-- Let us review again our [previous example](http://ariya.ofilabs.com/2013/03/es6-and-rest-parameter.html) with a supplier truck and a grocery store. Assuming the API of the store accepts a variable number of items for a particular category : -->\n\n\n<p>让我们再次回顾<a href=\"http://ariya.ofilabs.com/2013/03/es6-and-rest-parameter.html\">前面的例子</a>，其中有一辆供货卡车和一间杂货铺。假设杂货铺的 API 接受一个特定类目和可变数目的货物。</p>\n\n<pre><code>store.add('fruit', 'apple');\nstore.add('dairy', 'milk', 'cheese', 'yoghurt');\nstore.add('pastries', 'donuts', 'croissants');\n</code></pre>\n\n<!-- We assume that these delicious items are stored in some boxes, each box happens to be an array: -->\n\n\n<p>我们假设这些美味的货物存储在一个箱子里，每个箱子恰好是一个数组：</p>\n\n<pre><code>var dairyBox = ['milk', 'cheese', 'yoghurt'];\n</code></pre>\n\n<!-- A possible solution (out of many others) to invoke store’s add function with the items in the above array is by using [Function.prototype.apply](https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Function/apply). Since we need to pass the food category as the first argument, a little bit dancing with [Array.concat](https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/concat) is necessary: -->\n\n\n<p>用上面的数组调用杂货铺的 add 函数，一个可能的解决方案是使用 <a href=\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Function/apply\">Function.prototype.apply</a>。由于需要把食品类目作为第一个参数传入，<a href=\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/concat\">Array.concat</a> 是必需的。</p>\n\n<pre><code>store.add.apply(store, ['dairy'].concat(dairyBox));\n</code></pre>\n\n<!-- For the untrained eyes, it looks like one of those magical JavaScript incantations. -->\n\n\n<p>对于未经过训练的眼睛，上面的代码看起来就像是神奇的 JavaScript 咒语。</p>\n\n<!-- With ECMAScript 6, this can be simplified by using `...` prefix in a spread expression (section [11.2.5](http://teramako.github.com/ECMAScript/ecma6th_syntax.html#11.2), ES6 draft [Rev 14](http://wiki.ecmascript.org/doku.php?id=harmony:specification_drafts)). -->\n\n\n<p>在 ECMAScript 6 中，上面的代码可以通过使用展开表达式（<a href=\"http://teramako.github.com/ECMAScript/ecma6th_syntax.html#11.2\">11.2.5</a> 节, ES6 草稿 <a href=\"http://wiki.ecmascript.org/doku.php?id=harmony:specification_drafts\">Rev 14</a>）的前缀 <code>...</code> 简化。</p>\n\n<pre><code>store.add('dairy', ...dairyBox);\n</code></pre>\n\n<!-- That dairyBox array is simply spread to fill the [remaining argument list](http://www.2ality.com/2011/08/spreading.html). -->\n\n\n<p>数组 dairyBox 被简单的展开，以填充<a href=\"http://www.2ality.com/2011/08/spreading.html\">其余参数列表</a>。</p>\n\n<p><img src=\"http://ariya.ofilabs.com/wp-content/uploads/2013/03/spreadexpression.png\" alt=\"\" /></p>\n\n<!-- Obviously, one possibly common place where spreading is always useful is when dealing with arrays. We know that `push` accepts multiple number of arguments. The implementation of `add` function originally looks like: -->\n\n\n<p>显然，在可能处理数组的地方，展开操作总是有用的。我们知道 <code>push</code> 可以接受多个参数。函数 <code>add</code> 最初的实现看起来就像这样：</p>\n\n<pre><code>store.add = function(category, ...items) {\n  items.forEach(function (item) {\n    store.aisle[category].push(item);\n  });\n};\n</code></pre>\n\n<!-- which can be further shortened to become something like the following fragment. Nifty, isn’t it? -->\n\n\n<p>可以进一步缩短为类似下面的代码片段。很俏，不是吗？</p>\n\n<pre><code>store.add = function(category, ...items) {\n  store.aisle[category].push(...items);\n};\n</code></pre>\n\n<!-- (This is of course unnecessary if you choose to change the API to simply accept a single array for the items, instead of a rest parameter combined with spreading). -->\n\n\n<p>（当然，如果你改变 API 以简单的接受一个货物数组，而不是使用了展开操作符的可变参数，上面的做法是不必要的。）</p>\n\n<!-- The use of a spread operator can lead to a different way of combining arrays: -->\n\n\n<p>展开操作符的使用可以延伸出一种合并数组的不同方式：</p>\n\n<pre><code>var x = [1, 2];\nvar y = [3, 4];\nx.push(...y);  // x is [1, 2, 3, 4]\n</code></pre>\n\n<!-- What other tricks do you have in mind once you have the spread operator ready to abuse? -->\n\n\n<p>一旦滥用展开操作符，你头脑中会有什么其他的技巧？</p>\n"
            ],
            "link": [
              "http://nuysoft.github.com/2013/04/03/es6-and-spread-operator"
            ],
            "guid": [
              "http://nuysoft.github.com/2013/04/03/es6-and-spread-operator"
            ],
            "pubDate": [
              "2013-04-03T00:00:00-07:00"
            ]
          },
          {
            "title": [
              "ECMAScript 6 and Rest Parameter"
            ],
            "description": [
              "<blockquote><p>原文：<a href=\"http://ariya.ofilabs.com/2013/03/es6-and-rest-parameter.html\">ECMAScript 6 and Rest Parameter</a></p></blockquote>\n\n<!-- Handling a function with a variable number of arguments is always tricky in JavaScript. At least, we still have this `arguments` object which can be used to retrieve all arguments used to invoke a function. With the upcoming ECMAScript 6, no such hack is necessary anymore since we can start using its **rest parameter** feature. -->\n\n\n<p>在 JavaScript 中处理一个带有可变数目的参数的函数始终是棘手的。至少，我们还有 <code>arguments</code> 对象可以用于获取所有调用函数时的所有参数。随着即将到来的 ECMAScript 6，不再需要这样的技巧，因为我们可以使用它的<strong>可变参数</strong>功能。</p>\n\n<!-- To see how a rest parameter works, consider the following scenario. You drive a truck which delivers some supplies to a grocery store. As you unload the supplies, you add them to the store: -->\n\n\n<p>要看清可变参数是如何工作的，请考虑以下情况。你开一辆卡车给杂货店送货。当卸货后，你再把它们入库：</p>\n\n<pre><code>store.add('fruit', 'apple');\nstore.add('dairy', 'milk', 'cheese', 'yoghurt');\nstore.add('pastries', 'donuts', 'croissants');\n</code></pre>\n\n<!-- whereby `add` is implemented as something like: -->\n\n\n<p>其中 <code>add</code> 是这样实现的：</p>\n\n<pre><code>store.add = function(category) {\n  var items = [].slice.call(arguments, 1);\n  items.forEach(function (item) {\n    store.aisle[category].push(item);\n  });\n};\n</code></pre>\n\n<!-- Note how [arguments object](http://docs.webplatform.org/wiki/concepts/programming/javascript/functions#Using_the_arguments_object) can't be treated as a normal array, although it behaves [almost](https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Functions_and_function_scope/arguments) like an array. A well-known trick with [Array.prototype.slice](http://es5.github.com/#x15.4.4.10) and [Function.prototype.call](http://es5.github.com/#x15.3.4.4) is the workaround, giving us the list of all arguments which comes after the first one (category). -->\n\n\n<p>请注意，<a href=\"http://docs.webplatform.org/wiki/concepts/programming/javascript/functions#Using_the_arguments_object\">arguments 对象</a>不能被视为一个正常的数组，虽然它的行为总是像一个数组。一个众所周知的伎俩是用 <a href=\"http://es5.github.com/#x15.4.4.10\">Array.prototype.slice</a> 和 <a href=\"http://es5.github.com/#x15.3.4.4\">Function.prototype.call</a> 作为解决方法，返回第一个参数之后的所有参数列表。</p>\n\n<!-- With a rest parameter ([Section 13.1](http://teramako.github.com/ECMAScript/ecma6th_syntax.html#13.1), ES 6 draft [Rev 13](http://wiki.ecmascript.org/doku.php?id=harmony:specification_drafts)), the implementation is much simpler. It is even self-explanatory. -->\n\n\n<p>有了可变参数（<a href=\"http://teramako.github.com/ECMAScript/ecma6th_syntax.html#13.1\">Section 13.1</a>, ES 6 draft <a href=\"http://wiki.ecmascript.org/doku.php?id=harmony:specification_drafts\">Rev 13</a>），实现要简单的多。它甚至是自解释的。</p>\n\n<pre><code>store.add = function(category, ...items) {\n  items.forEach(function (item) {\n    store.aisle[category].push(item);\n  });\n};\n</code></pre>\n\n<!-- Another typical use-case where a rest parameter could be useful is a pubsub-like pattern. If you write a Backbone.js-based application, triggering an event via [Backbone.Event.trigger](http://backbonejs.org/#Events-trigger) is a common practice. Because an event may require one or more parameters, the implementation of the trigger function itself looks like: -->\n\n\n<p>可变参数有用的另一个典型的用例是类发布-订阅模式。如果编写基于 Backbone.js 的应用程序，通过 <a href=\"http://backbonejs.org/#Events-trigger\">Backbone.Event.trigger</a> 触发事件是一种常见做法。由于一个事件可能需要一个或多个参数，trigger 函数的实现看起来像这样：</p>\n\n<pre><code>trigger: function(name) {\n    if (!this._events) return this;\n    var args = slice.call(arguments, 1);\n    /// ... do something with args ...\n    return this;\n},\n</code></pre>\n\n<!-- for which I'm sure you can come up with a slightly different look if you have the rest parameter feature as your disposal! -->\n\n\n<p>我敢肯定，如果有可变参数功能，你能拿出一个稍有不同的实现。</p>\n\n<!-- Obviously we don't need a rest parameter if we switch the API to accept an array as the second argument. However, in some cases, it would feel less natural. For example, a string formatter implementation is expected to follow the de-facto [printf format string](http://en.wikipedia.org/wiki/Printf_format_string) rather than grouping every parameters in a simple array. -->\n\n\n<p>很显然，如果我们修改 API 以接受一个数组作为第二个参数，就不需要可变参数了。然而在某些情况下，这么做会觉得不太自然。例如，一个字符串格式化程序的实现被期待遵循事实上的 <a href=\"http://en.wikipedia.org/wiki/Printf_format_string\">printf format string</a>，而不是把每个参数分组一个简单的数组中。</p>\n\n<!-- Just like other syntactic sugar in ECMAScript 6, a rest parameter does not radically change you write your JavaScript code. It does however make the code more [tool-friendly](http://ariya.ofilabs.com/2012/11/language-tools-for-reducing-mistakes.html), shifting the semantic interpretation of the code from the run-time behavior into something at the **syntax level**. Once editors and IDEs understand the construct, a simple code hint which reveals the function signature is more than enough to indicate that the said function accepts a variable number of arguments. -->\n\n\n<p>就像 ECMAScript 6 中的其他语法糖一样，可变参数并没有从根本上改变你编写 JavaScript 代码的方式。但是确实使代码更<a href=\"http://ariya.ofilabs.com/2012/11/language-tools-for-reducing-mistakes.html\">工具友好</a>，将代码语义解释从运行时行为转移到<strong>语法级</strong>。一旦编辑器和集成开发环境理解该结构，一个简单的代码提示显示的函数签名足以表名该函数接受一个可变书目的参数。</p>\n\n<!-- Isn't it exciting? -->\n\n\n<p>这太令人兴奋了，不是吗？</p>\n"
            ],
            "link": [
              "http://nuysoft.github.com/2013/04/03/es6-and-rest-parameter"
            ],
            "guid": [
              "http://nuysoft.github.com/2013/04/03/es6-and-rest-parameter"
            ],
            "pubDate": [
              "2013-04-03T00:00:00-07:00"
            ]
          },
          {
            "title": [
              "ECMAScript 6 and Object Literal Property Value Shorthand"
            ],
            "description": [
              "<blockquote><p>原文：<a href=\"http://ariya.ofilabs.com/2013/02/es6-and-object-literal-property-value-shorthand.html\">ECMAScript 6 and Object Literal Property Value Shorthand</a></p></blockquote>\n\n<!-- Constructing an object using the literal syntax is something that is very familiar to every JavaScript developer, quite likely because this reminds everyone of [JSON](http://json.org/). While every object property needs to be either a key-value pair or getter/setter, this may change in the near future. Another syntactic sugar in the upcoming ECMAScript 6 is the **object literal property value shorthand**. -->\n\n\n<p>对于每个 JavaScript 开发人员，使用字面量语法构造一个对象是非常熟悉的做法，这很可能是因为这种做法让人想起 <a href=\"http://json.org/\">JSON</a>。而每个对象属性必须是一对 key-value 或 getter/setter，这可能会在不久的将来改变。即将到来的 ECMAScript 6 的另一个语法糖是<strong>对象字面属性值简写</strong>。</p>\n\n<!-- Consider the following ECMAScript 5 fragment: -->\n\n\n<p>考虑下面的 ECMAScript 5 代码片段：</p>\n\n<pre><code>function createMonster(name, power) {\n  return { type: 'Monster', name: name, power: power };\n}\nfunction createWitch(name) {\n  return { type: 'Witch', name: name };\n}\n</code></pre>\n\n<!-- With the new shorthand form, this can be rewritten as the following code: -->\n\n\n<p>使用新的简写形式后，这段代码可以被改写为下面的代码：</p>\n\n<pre><code>function createMonster(name, power) {\n  return { type: 'Monster', name, power };\n}\nfunction createWitch(name) {\n  return { type: 'Witch', name };\n}\n</code></pre>\n\n<!-- As you can see, this works because the property value has the same name as the property identifier. This a new addition to the syntax of *Object Initialiser* ([section 11.1.5](http://teramako.github.com/ECMAScript/ecma6th_syntax.html#11.1.5)) in the latest [ECMAScript 6 draft Rev 13](http://wiki.ecmascript.org/doku.php?id=harmony:specification_drafts). Of course, just like the limitations set from ECMAScript 3, you can't use a reserved word as your property name. -->\n\n\n<p>正如你看到的，这段代码可以工作是因为属性值与属性标识符同名。这是最新的 <a href=\"http://wiki.ecmascript.org/doku.php?id=harmony:specification_drafts\">ECMAScript 6 草案 Rev 13</a> 对<em>对象初始化</em>语法（<a href=\"http://teramako.github.com/ECMAScript/ecma6th_syntax.html#11.1.5\">11.1.5 节</a>）新的补充。当然，就像 ECMAScript 3 的限制集合，你不能使用保留字作为属性名。</p>\n\n<!-- What about real-world code which can use the shorthand notation? Somewhere in [Backbone.js](http://backbonejs.org/), we should be able to use the following form instead of its longer one: -->\n\n\n<p>在现在世界的代码中使用这种简写符号会怎么样？在 <a href=\"http://backbonejs.org/\">Backbone.js</a> 的某个地方，我们可以使用下面的形式，代替它更长（旧）的形式：</p>\n\n<pre><code>route: function(route, callback) {\n  this.handlers.unshift({route, callback});\n},\n</code></pre>\n\n<!-- For improved readibility, many times we use temporary variables before constructing an object out of the properties. As another example, a piece of code [QUnit](http://qunitjs.com/) may have the following simplified syntax: -->\n\n\n<p>为了提高可读性，很多时候，我们在用属性构造对象之前会使用临时变量。再举一个例子，<a href=\"http://qunitjs.com/\">QUnit</a> 的某块代码可以使用下面的简化语法：</p>\n\n<pre><code>test = new Test({nameHtml, testName, expected, async,\n  callback,module: config.currentModule,\n  moduleTestEnvironment: config.currentModuleTestEnvironment,\n  stack: sourceFromStacktrace(2)\n});\n</code></pre>\n\n<!-- Such a shorthand won't dramatically change your code, it only makes everything a little bit sweeter! -->\n\n\n<p>这种简写不会显著的改变你的代码，它仅仅是让事情变得有点“甜蜜”（sweeter）。</p>\n\n<!-- **Addendum**. While the literal shorthand is useful on its own, in many cases it would be more frequently encountered as it is combined with *object pattern* (see my previous post on [ECMAScript 6 destructuring](http://ariya.ofilabs.com/2013/02/es6-and-destructuring-assignment.html)). Thus, the following code fragment: -->\n\n\n<p><strong>附录</strong></p>\n\n<p>虽然字面量简写本身就是有用的，但在许多情况下，更频繁遇到的是它与<em>对象模式</em>（见我以前关于 <a href=\"http://ariya.ofilabs.com/2013/02/es6-and-destructuring-assignment.html\">ECMAScript 6 解构</a> 的帖子）结合使用。因此，下面的的代码片段：</p>\n\n<pre><code>books.forEach(function ({title: title, author: author}) {\n  console.log(title, 'is written by', author);\n});\n</code></pre>\n\n<!-- turns into something like this one: -->\n\n\n<p>变成这样：</p>\n\n<pre><code>books.forEach(function ({title, author}) {\n  console.log(title, 'is written by', author);\n});\n</code></pre>\n\n<!-- As you can see, such a symmetry is well suited for this case. -->\n\n\n<p>正如你看到的，这样的对称性（属性值与属性标识符同名）非常适合这种情况。</p>\n"
            ],
            "link": [
              "http://nuysoft.github.com/2013/04/03/es6-and-object-literal-property-value-shorthand"
            ],
            "guid": [
              "http://nuysoft.github.com/2013/04/03/es6-and-object-literal-property-value-shorthand"
            ],
            "pubDate": [
              "2013-04-03T00:00:00-07:00"
            ]
          },
          {
            "title": [
              "ECMAScript 6 and Method Definitions"
            ],
            "description": [
              "<blockquote><p>原文：<a href=\"http://ariya.ofilabs.com/2013/03/es6-and-method-definitions.html\">ECMAScript 6 and Method Definitions</a></p></blockquote>\n\n<!-- Using an object literal populated with some member functions is a common practice in any serious JavaScript applications. This is also useful for all kind of frameworks, in particular to setup object prototypes. The upcoming ECMAScript 6 introduces **method definition**, a nice shorthand which eliminates the need to use `function` when using that pattern. -->\n\n\n<p>在任何严肃的 JavaScript 应用程序中，使用含有一些成员函数的对象字面量是一种常见的做法。这种做法对所有类型的框架也是非常有用的，特别是建立对象原型。即将到来的 ECMAScript 6 引入了<strong>方法定义</strong>，一种非常好的简写方式，使用这种模式可以消除对 <code>function</code> 的需要。</p>\n\n<!-- Before we see method definition in action, let us have a quick refresh on property setter and getter. This is part of the current ECMAScript 5.1, see [Section 11.1.5](http://es5.github.com/#x11.1.5) on Object Initialiser. The idea is to use `set` and `get` to bind an object property to a function which will be invoked when that property is set and looked up, respectively. The following code fragment demonstrates its usage: -->\n\n\n<p>在查看方法定义之前，我们先快速回顾一下属性 setter 和 getter。这是当前 ECMAScript 5.1 的一部分，请参见 <a href=\"http://es5.github.com/#x11.1.5\">11.1.5 节</a> 的对象初始化。总的思想是使用 <code>set</code> 和 <code>get</code> 将一个对象属性绑定到一个函数，当时属性被设置或读取时函数被调用。下面的代码片段演示了这种用法：</p>\n\n<pre><code>var BigLoco = {\n  locoName: 'Gordon',\n  get name() { return this.locoName; },\n  set name(n) { this.locoName = n }\n};\n\nconsole.log(BigLoco.name); // 'Gordon'\n</code></pre>\n\n<!-- Practically, we have a way to define a function without using the `function` keyword. With ECMAScript 6, this is extended further so that the syntax applies not only to property getter and setter, but also to [plain functions](http://www.2ality.com/2012/04/arrow-functions.html). This is called *Method Definitions*, see [Section 13.3](http://teramako.github.com/ECMAScript/ecma6th_syntax.html#13.3) in the latest [ES6 draft](http://wiki.ecmascript.org/doku.php?id=harmony:specification_drafts). -->\n\n\n<p>实际上，我们有办法定义一个函数而不使用关键字 <code>function</code> 。在 ECMAScript 6 中，这种语法被进一步扩展，不只适用于属性的 getter 和 setter，也适用于<a href=\"http://www.2ality.com/2012/04/arrow-functions.html\">普通函数</a>。这种语法被称为<em>方法定义</em>，请参见最新的 <a href=\"http://wiki.ecmascript.org/doku.php?id=harmony:specification_drafts\">ES6 草案</a> 的 <a href=\"http://teramako.github.com/ECMAScript/ecma6th_syntax.html#13.3\">13.3 节</a>。</p>\n\n<!-- Take a look at an example ECMAScript 6 code here, in particular to the `start` and `stop` functions. -->\n\n\n<p>看一看这里的 ECMAScript 6 代码示例，特别是 <code>start</code> 和 <code>stop</code> 函数。</p>\n\n<pre><code>var SteamEngine = {\n  color: 'blue',\n  get name() { return 'Thomas' },\n  start() { console.log('Hurry up!'); },\n  stop() { console.log('Screech...! That was close.'); }\n};\n\nconsole.log('My name is', SteamEngine.name);\nSteamEngine.start();\nSteamEngine.stop();\n</code></pre>\n\n<!-- If we were about to transpile the code to ES5, the construct will look like: -->\n\n\n<p>如果我们想要把这段代码转换为 ES5，结构会看起来像这样：</p>\n\n<pre><code>var SteamEngine = {\n  color: 'blue',\n  get name() { return 'Thomas' },\n  start: function() { console.log('Hurry up!'); },\n  stop: function() { console.log('Screech...! That was close.'); }\n};\n</code></pre>\n\n<!-- The ECMAScript 6 version shows a nice symmetry thanks to this syntactic sugar. Every property on that literal looks the same and it's not really difficult to spot the functions due to the necessary parentheses. Sweet! -->\n\n\n<p>ECMAScript 6 对于这一语法糖显示出了良好的对称性。对象字面量中的每个属性看起来一样，并且由于必要的括号不难识别出其中的函数。</p>\n"
            ],
            "link": [
              "http://nuysoft.github.com/2013/04/03/es6-and-method-definitions"
            ],
            "guid": [
              "http://nuysoft.github.com/2013/04/03/es6-and-method-definitions"
            ],
            "pubDate": [
              "2013-04-03T00:00:00-07:00"
            ]
          },
          {
            "title": [
              "ECMAScript 6 and Destructuring Assignment"
            ],
            "description": [
              "<blockquote><p>原文：<a href=\"http://ariya.ofilabs.com/2013/02/es6-and-destructuring-assignment.html\">ECMAScript 6 and and Destructuring Assignment</a></p></blockquote>\n\n<!-- In a programming language, destructuring assignment denotes the use of **patterns** to extract **parts** of an object. If we refer to [Common LISP](http://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node252.html), destructuring assignment binds a set of variables to a corresponding set of values, where normally bind a value to a single variable. For the next-generation ECMAScript 6, [destructuring feature](http://wiki.ecmascript.org/doku.php?id=harmony:destructuring) is slated to be an important addition to the assignment expression. -->\n\n\n<p>在编程语言中，解构赋值表示使用<strong>模式</strong>提取对象的<strong>部分</strong>。如果我们参考 <a href=\"http://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node252.html\">Common LISP</a>，解构赋值绑定一组变量到一组对应的值，通常是绑定一个值到一个唯一变量。对于下一代 ECMAScript 6，<a href=\"http://wiki.ecmascript.org/doku.php?id=harmony:destructuring\">解构功能</a> 被定位为赋值表达的重要补充。</p>\n\n<!-- Python developers might be already familiar with the concept of [sequence unpacking](http://docs.python.org/2/tutorial/datastructures.html#tuples-and-sequences). CoffeeScript also already has the syntax for [destructuring](http://coffeescript.org/#destructuring). SpiderMonkey, the JavaScript engine in Firefox, has been [supporting](https://developer.mozilla.org/en-US/docs/JavaScript/New_in_JavaScript/1.7) destructuring assignment for a while. The latest ECMAScript 6 defines the grammar for destructuring assignment in [Section 11.13.1](http://teramako.github.com/ECMAScript/ecma6th_syntax.html#11.13.1). There are two different forms: array pattern and object pattern. -->\n\n\n<p>Python 开发人员可能已经熟悉<a href=\"http://docs.python.org/2/tutorial/datastructures.html#tuples-and-sequences\">序列拆封</a>的概念。CoffeeScript 也有<a href=\"http://coffeescript.org/#destructuring\">解构</a>语法。火狐的 JavaScript 引擎 SpiderMonkey 已经<a href=\"https://developer.mozilla.org/en-US/docs/JavaScript/New_in_JavaScript/1.7\">支持</a>解构赋值有一段时间了。最新的 ECMAScript 6 在 <a href=\"http://teramako.github.com/ECMAScript/ecma6th_syntax.html#11.13.1\">11.13.1 节</a>定义了解构赋值。有两种不同的形式：数组模式和对象模式。</p>\n\n<!-- ## Array Pattern -->\n\n\n<h2>数组模式</h2>\n\n<!-- Variables can be initialized in one go. The following two lines have the same effect, the first one is employing an array pattern. -->\n\n\n<p>变量的初始化可以一气呵成。下面的两行代码具有相同的效果，其中第一行使用了数组模式。</p>\n\n<pre><code>var [m, d, y] = [3, 14, 1977];\nvar m = 3, d = 14, y = 1977;\n</code></pre>\n\n<!-- Swapping two variables is rather trivial, this one works just as expected. Internally, it does the sequence as if there is a temporary variable temp and the usual value exchange. -->\n\n\n<p>交换两个变量相当琐碎，不过这一次正如预期的那样工作。在内部，就像有一个临时变量以及一般的值交换一样，来处理数组。</p>\n\n<pre><code>x = 3; y = 4; [x, y] = [y, x]\ntemp = [y, x]; x = temp[0]; y = temp[1];\n</code></pre>\n\n<!-- Another typical use of array restructuring is for a function which has multiple return values. We don't need to wrap it in an object anymore. Also, there is no need to accept all elements in the array. -->\n\n\n<p>另一种使用数组重组的典型场景是有个返回值的函数。我们不再需要把返回值包装到一个对象中。另外，也不需要接受数组中的所有元素。</p>\n\n<pre><code>function now() { return [2, 6, 2013, 8, 0]; }\nvar [m, d] = now(); // m = 2, d = 6\nvar [,,year] = now(); // year = 2013\n</code></pre>\n\n<!-- With the [syntax visualization](http://esprima.googlecode.com/git-history/harmony/demo/parse.html) feature of Esprima, it is rather easy to illustrate the syntax tree of an array pattern. The following figure shows an example thereof. Compared to a vanilla assignment or variable declarator, the obvious different here is that we have an array pattern instead of a plain identifier. -->\n\n\n<p>利用 Esprima 的<a href=\"http://esprima.googlecode.com/git-history/harmony/demo/parse.html\">可视化语法</a>功能，说明数组模式的语法树相当容易。下图显示了一个例子。相比普通赋值或变量声明明显不同是，使用了一个数组模式，而不是一个普通的标识符。</p>\n\n<p><img src=\"http://ariya.ofilabs.com/wp-content/uploads/2013/02/destructuring.png\" alt=\"\" /></p>\n\n<!-- ## Object Pattern -->\n\n\n<h2>对象模式</h2>\n\n<!-- This pattern is very similar, except it works by matching object properties instead of array indices. Thus, we can easily pick the ones we are interested in while ignoring the rest. A similar example as before, e.g. when processing the return value of a function: -->\n\n\n<p>对象模式与数据模式非常相似，除了工作原理是匹配对象，而不是匹配数组索引。因此，我们很容易的挑选哪些我们感兴趣的而忽略其余的。与前面的例子类似，下面是处理一个函数的返回值的例子：</p>\n\n<pre><code>function today() { return { d: 6, m: 2, y: 2013 }; }\nvar { m: month, y: year } = today(); // month = 2, year = 2013\n</code></pre>\n\n<!-- Of course, instead of a pattern, nothing stops you from assigning a holder object before accessing each property. However, the lack of such extra object makes the code looks cleaner (or sweeter, since destructuring is supposed to be a syntactic sugar), in particular when it is part of a loop. -->\n\n\n<p>当前，在访问每个属性之前，没有什么可以阻止你指定一个持有（特定属性和值的）对象，而不是一个（持有所有属性和值的）对象模式。无论如何，由于没有这种额外的对象，代码看起来更干净（或者更甜，因为解构应该是一个语法糖），特别当它是循环的一部分时。</p>\n\n<pre><code>books.forEach(function ({ title: title, author: author }) { console.log(title, author) }; )\n</code></pre>\n\n<!-- In the above construct, every element in that books array may contain a lengthy information about that particular book. Since we just want some properties, it is possible to extract them directly via the object pattern. -->\n\n\n<p>在上面的结构中，数组 books 中的每个元素可能含有关于特定 book 的冗长的信息。而我们只需要部分属性，可以通过对象模式直接提取这些信息。</p>\n\n<!-- It gets even more interesting once we combine with [array comprehension](http://ariya.ofilabs.com/2013/01/es6-and-array-comprehension.html). For example, the following line is exactly the same as the above snippet: -->\n\n\n<p>一旦结合使用<a href=\"http://ariya.ofilabs.com/2013/01/es6-and-array-comprehension.html\">数组推导式</a>，情况会变得更加有趣。例如下面的这行代码与上面的代码片段完全等价：</p>\n\n<pre><code>[console.log(t,a) for ({title: t, author: a} of books)];\n</code></pre>\n\n<!-- How do you plan to (ab)use array and object pattern? -->\n\n\n<p>你计划如何使用数组模式和对象模式呢？</p>\n"
            ],
            "link": [
              "http://nuysoft.github.com/2013/04/03/es6-and-destructuring-assignment"
            ],
            "guid": [
              "http://nuysoft.github.com/2013/04/03/es6-and-destructuring-assignment"
            ],
            "pubDate": [
              "2013-04-03T00:00:00-07:00"
            ]
          },
          {
            "title": [
              "ECMAScript 6 and Default Argument"
            ],
            "description": [
              "<blockquote><p>原文：<a href=\"http://ariya.ofilabs.com/2013/02/es6-and-default-argument.html\">ECMAScript 6 and Default Argument</a></p></blockquote>\n\n<!-- Many programming languages support the concept of a [default argument](http://en.wikipedia.org/wiki/Default_argument) for a function parameter so that the caller does not always need to specify the argument value. Unfortunately, JavaScript does not have a default argument support in its syntax. This may soon change with the upcoming ECMAScript 6. -->\n\n\n<p>许多编程语言都支持将某个函数参数声明为<a href=\"http://en.wikipedia.org/wiki/Default_argument\">默认参数</a>这一概念，这样调用者不需要总是指定该参数的值。不幸的是，JavaScript 的语法不支持默认参数。随着即将到来的 ECMAScript 6，这种情况可能很快会改变。</p>\n\n<!-- A few JavaScript programmers employ various different **run-time tricks** to achieve the effect of an argument with a default value. The common approach is by leveraging the fact that if an argument is not given a value, then it`s simply `undefined`. -->\n\n\n<p>一些 JavaScript 程序员使用各种不同的<strong>运行时技巧</strong>实现某个参数的默认值效果。常用方法利用了这一事实：如果某个参数没有给定值，那么就是简单 <code>undefined</code>。</p>\n\n<pre><code>function foobar(a) { return typeof a; }\nfoobar(); // \"undefined\"\n</code></pre>\n\n<!-- This can lead to some code like: -->\n\n\n<p>这可能会导致一些像这样的代码：</p>\n\n<pre><code>function runApp(appName) { console.log('Running', appName || 'AUTOEXEC.BAT'); }\n</code></pre>\n\n<!-- That function will print Running AUTOEXEC.BAT if invoked as `runApp()` only (without any argument). The use of **logical expression OR** (operator ||, see section 11.11 on [Binary Logical Operators](http://es5.github.com/#x11.11)) means that if the left side (appName) is true (see section 9.2 on [ToBoolean](http://es5.github.com/#x9.2)), then the short-circuiting kicks in, otherwise we will get the right side (AUTOEXEC.BAT). Note how the result is the same if you execute that function with other value such as `null`, `0`, `![]`, or even `~~{}`. -->\n\n\n<p>如果只调用 <code>runApp()</code>（不带任何参数），该函数将打印 Running AUTOEXEC.BAT。使用的<strong>逻辑或表达式</strong>（操作符 ||，查看<a href=\"http://es5.github.com/#x11.11\">二进制逻辑运算符</a> 上的 11.11 节）表示，如果左侧（appName）是 true（查看 <a href=\"http://es5.github.com/#x9.2\">ToBoolean</a> 上的 9.2 节），则短路生效，否则返回右边（AUTOEXEC.BAT）。注意，如果执行该函数时使用诸如 <code>null</code>、<code>0</code>、<code>![]</code>、甚至 <code>~~{}</code> 这样的参数值，结果是一样的。</p>\n\n<!-- Another variant which are often encountered is really **checking the type** of the parameter. Now we can distinguish between `undefined` and others. Therefore, a suitable value substitution can be carried out. -->\n\n\n<p>经常遇到的另一种变体是真正的<strong>检测参数类型</strong>。现在我们可以区分 <code>undefined</code> 和其他类型。因此，可以使用一个合适的替换值。</p>\n\n<pre><code>function runApp(appName) {\n  if (typeof appName === 'undefined') appName = 'AUTOEXEC.BAT';\n  console.log('Running', appName);\n}\n</code></pre>\n\n<!-- In other cases, we *really* really need to know whether the function is invoked with a certain number of argument or not. For this purpose, the `arguments` object comes to the rescue. -->\n\n\n<p>在其他情况下，我们<strong>事实上</strong>真的需要知道该函数是否用一定数量的参数被调用。为了这个目的，<code>arguments</code> 对象就派上用场了。</p>\n\n<pre><code>function runApp(appName) {\n  if (arguments.length === 0) appName = 'AUTOEXEC.BAT';\n  console.log('Running', appName);\n}\n</code></pre>\n\n<!-- All this fancy dance is not necessarily anymore once the syntax itself supports a default argument. In the [section 13](http://teramako.github.com/ECMAScript/ecma6th_syntax.html#13) of the [latest ECMAScript 6 draft](http://wiki.ecmascript.org/doku.php?id=harmony:specification_drafts), it is mentioned that the formal parameter (for a function) is not a simple list of identifiers anymore (as in ECMAScript 5) as it is generalized to allow *BindingElement*. While this new construct is there to permit the object and array pattern (see my previous blog post on [destructuring assignment](http://ariya.ofilabs.com/2013/02/es6-and-destructuring-assignment.html)), it is important to realize that BindingElement supports an optional initialization, pretty much like in a variable declaration. -->\n\n\n<p>一旦语法本身支持默认参数，所有这一切花哨的技巧不再是必要的。在<a href=\"http://wiki.ecmascript.org/doku.php?id=harmony:specification_drafts\">最新的 ECMAScript 6 草稿</a>的 <a href=\"http://teramako.github.com/ECMAScript/ecma6th_syntax.html#13\">13 节</a>，提到（函数）的正式参数不再是一个简单的标识符列表（正如 ECMAScript 5 中定义的），因为参数被泛化为允许 <em>BindingElement</em>。虽然这种新结构允许对象或数组模式（参见我之前关于 <a href=\"http://ariya.ofilabs.com/2013/02/es6-and-destructuring-assignment.html\">destructuring assignment</a> 的博客文章），重要的是要认识到 BindingElement 支持一个可选的初始化，就像在一个变量声明。</p>\n\n<!-- In plain English, this means that a function declaration can specify a default value for every parameter. The previous `runApp` function will turn into something as simple as: -->\n\n\n<p>说得明白点，这意味着一个函数声明可以为每个参数指定一个默认值。之前的 <code>runApp</code> 函数会变得如此简单：</p>\n\n<pre><code>function runApp(appName = 'AUTOEXEC.BAT') {\n  console.log('Running', appName);\n}\n</code></pre>\n\n<!-- While waiting for browsers and JavaScript engines to implement this feature, such a construct can be used already these days with help of [Traceur](https://code.google.com/p/traceur-compiler/) or [TypeScript](http://www.typescriptlang.org/). It is interesting to note the different desugaring, Traceur will use the `arguments` object while TypeScript performs the `undefined` type check. -->\n\n\n<p>在等待浏览器和 JavaScript 引擎实现该功能期间，目前可以在 <a href=\"https://code.google.com/p/traceur-compiler/\">Traceur</a> 或 <a href=\"http://www.typescriptlang.org/\">TypeScript</a> 的帮助下使用这样的结构。有趣的是脱糖（降级）方式的不同，Traceur 将使用 <code>arguments</code> 对象，而 TypeScript 执行 <code>undefined</code> 类型检测。</p>\n\n<!-- Having a built-in syntax support for default argument is fantastic. A JavaScript editors could give a better [content assist](http://ariya.ofilabs.com/2013/02/javascript-editing-with-vmware-scripted.html) (autocomplete). A code analyzer will be able to track function invocation which omits parameters that do not have default values. I can't wait until a linter complains to me: -->\n\n\n<p>内置语法支持默认参数实在是太棒了。一个 JavaScript 编辑器可以提供更好的<a href=\"http://ariya.ofilabs.com/2013/02/javascript-editing-with-vmware-scripted.html\">帮助内容</a>（自动补全）。一个代码分析器将能够跟踪省略了无默认值参数的函数调用。我不能等到一个 linter 向我抱怨：</p>\n\n<pre><code>guide.js:42 Specify the non-optional parameter 'stop' to function 'createSeries'\n为函数 'createSeries' 指定必选参数 'stop'\n</code></pre>\n\n<!-- Better [language tools](http://ariya.ofilabs.com/2012/12/quality-code-via-multiple-layers-of-defense.html) will no doubt reduce any [coding mistake](http://ariya.ofilabs.com/2012/11/language-tools-for-reducing-mistakes.html) as best as it can. -->\n\n\n<p>更好的<a href=\"http://ariya.ofilabs.com/2012/12/quality-code-via-multiple-layers-of-defense.html\">语言工具</a>无疑将尽可能的减少任何<a href=\"http://ariya.ofilabs.com/2012/11/language-tools-for-reducing-mistakes.html\">代码错误</a>。</p>\n"
            ],
            "link": [
              "http://nuysoft.github.com/2013/04/03/es6-and-default-argument"
            ],
            "guid": [
              "http://nuysoft.github.com/2013/04/03/es6-and-default-argument"
            ],
            "pubDate": [
              "2013-04-03T00:00:00-07:00"
            ]
          },
          {
            "title": [
              "ECMAScript 6 and Arrow Function"
            ],
            "description": [
              "<blockquote><p>原文：<a href=\"http://ariya.ofilabs.com/2013/02/es6-and-arrow-function.html\">ECMAScript 6 and Arrow Function</a></p></blockquote>\n\n<!-- Experienced JavaScript programmers take advantage of function expressions, they are used a lot in callbacks, either for DOM access or any other related setup. Another syntax addition to the upcoming ECMAScript 6 is the **arrow function expression** to let us write a shorter function expression. -->\n\n\n<p>有经验的 JavaScript 程序员会在回调函数中大量使用函数表达式，或者用于 DOM 访问，或者用于任何其他相关的设置。即将到来的 ECMAScript 6 增加了另外一种语法，称为<strong>箭头函数</strong>，允许我们编写更短的函数表达式。</p>\n\n<!-- A simple way to look at this arrow function notation (section [13.2](http://teramako.github.com/ECMAScript/ecma6th_syntax.html#13.2) in the latest ES6 draft) is as a shorthand form of a normal function expression. This is best illustrated with an example. Say you want to produce the list containing the salary of every employees. By using [Array map](http://ariya.ofilabs.com/2013/01/es6-and-array-comprehension.html), it will look like the following snippet: -->\n\n\n<p>箭头函数（最新的 ES6 草稿 <a href=\"http://teramako.github.com/ECMAScript/ecma6th_syntax.html#13.2\">13.2</a> 节）可以简单的理解为普通函数表达式的简写形式。最好是用一个例子来说明。假设你想要生成一个包含了每个员工工资的列表。可以通过使用 <a href=\"http://ariya.ofilabs.com/2013/01/es6-and-array-comprehension.html\">Array map</a> 实现，就像下面的代码片段：</p>\n\n<pre><code>salaryList = employeeList.map(function (e) { return e.salary; });\n</code></pre>\n\n<!-- Note the function expression as the callback for map() is rather verbose. With an arrow function expression, that construct can be shortened to: -->\n\n\n<p>可以看到，函数表达式作为 map() 的回调函数相当冗长。而使用箭头函数表达式，该结构可以缩短为：</p>\n\n<pre><code>salaryList = employeeList.map(e =&gt; e.salary);\n</code></pre>\n\n<!-- No need for function and return. In fact, if you are about to implement the same task with other languages (such as Scala, CoffeeScript, C#), you would end up with a very similar syntax. -->\n\n\n<p>不需要函数和返回值。事实上，如果使用其他语言（比如 Scala、CoffeeScript、C#）实现同样的任务，最后会有一个非常相似的语法。</p>\n\n<!-- How does a syntax tree look like when there is an arrow function? Rather straightforward, no surprise there. -->\n\n\n<p>箭头函数的<a href=\"http://esprima.googlecode.com/git-history/harmony/demo/parse.html\">语法树</a>看起来会是什么样子？相当简单，没有任何惊喜。</p>\n\n<p><img src=\"http://ariya.ofilabs.com/wp-content/uploads/2013/02/arrow_function.png\" alt=\"arrow_function\" /></p>\n\n<!-- An arrow function expression is designed primary for the case where you need to return a value. However, it still works if you don’t care about returning anything and just want to execute some statements. Take a look at this example: -->\n\n\n<p>箭头函数表达式主要为了需要返回一个值的情况而设计。然而，如果你不关心返回值、只是想执行一些语句，它仍然是有效的。看看这个例子：</p>\n\n<pre><code>employeeList.forEach(e =&gt; { console.log(e.name); });\n</code></pre>\n\n<!-- Another fun thing with such a shorthand is when you start cascading more functions. For example, if now we are interested in the average salary, this can be computed by: -->\n\n\n<p>当你使用这种简写方式级联更多的函数时，事情变得有趣起来。例如，如果现在我们感兴趣的是平均工资，可以这样计算：</p>\n\n<pre><code>var total = employeeList.map(e =&gt; e.salary).reduce((p, q) =&gt; p + q));\nvar averageSalary = total / employeeList.length;\n</code></pre>\n\n<!-- That’s just way shorter and less crowded compare to function expressions everywhere. It is important to notice that if you have more than one parameter, you need to enclose the parameters with brackets. -->\n\n\n<p>相较于无处不在的函数表达式，这种方式要更短、更简洁。重要的是要注意到，如果有一个以上的参数，需要用括号把参数包起来。</p>\n\n<!-- Since an arrow function expression is just another form of an assignment expression, we can keep it as a normal object (either for further reuse or just to make it easy to follow), as illustrated in the following fragment (neat, isn’t it?): -->\n\n\n<p>因为箭头函数表达式仅仅是另一种形式的赋值表达式，我们可以将它保存为一个普通对象（或者为了将来复用，或者仅仅是为了易于跟踪），就像下面的代码片段所示（很优雅是不是？）：</p>\n\n<pre><code>var adder = (p, q) =&gt; p + q;\nvar avg = employeeList.map(e =&gt; e.salary).reduce(adder) / employeeList.length;\n</code></pre>\n\n<!-- Combine it with [array comprehension](http://ariya.ofilabs.com/2013/01/es6-and-array-comprehension.html) and magically it does not look to JavaScript-y anymore! -->\n\n\n<p>如果把箭头函数表达式与<a href=\"http://ariya.ofilabs.com/2013/01/es6-and-array-comprehension.html\">数组推导式</a> 结合使用，箭头函数魔法般地不再像是由 JavaScript 构成的。</p>\n\n<!-- I believe the use of arrow function expression strikes a good balance between readability and expressiveness. What do you think? -->\n\n\n<p>我相信箭头函数表达式的使用可以在可读性和表达丰富性之间取得一个良好的平衡。你怎么看？</p>\n"
            ],
            "link": [
              "http://nuysoft.github.com/2013/04/03/es6-and-arrow-function"
            ],
            "guid": [
              "http://nuysoft.github.com/2013/04/03/es6-and-arrow-function"
            ],
            "pubDate": [
              "2013-04-03T00:00:00-07:00"
            ]
          },
          {
            "title": [
              "ECMAScript 6 and Array Comprehension"
            ],
            "description": [
              "<blockquote><p>原文：<a href=\"http://ariya.ofilabs.com/2013/01/es6-and-array-comprehension.html\">ECMAScript 6 and Array Comprehension</a></p></blockquote>\n\n<!-- Many modern programming languages support [list comprehension](http://en.wikipedia.org/wiki/List_comprehension), a concise way to create a list based another list where each entry is the result of some operations. If comprehension is used properly, it eliminates the need for the traditional and error-prone manual iteration. Next-generation JavaScript will have the similar feature via **array comprehension**. -->\n\n\n<p>很多现代编程语言支持<a href=\"http://en.wikipedia.org/wiki/List_comprehension\">列表推导式</a>，一种基于另一个列表创建列表的简洁方式，另一个列表中的每个条目是某些操作的结果。如果适当的使用推导式，将消除传统的、容易出错的手动迭代的需求。下一代 JavaScript 通过<strong>数组推导式</strong>提供类似的功能。</p>\n\n<!-- First of all, let’s do a quick refresh on Array’s `map` and `filter` functions. -->\n\n\n<p>首先，让我们快速回顾一下 Array 的 <code>map</code> 和 <code>filter</code> 方法。</p>\n\n<h2>Array.prototype.map</h2>\n\n<!-- [Section 15.4.4.19](http://es5.github.com/#x15.4.4.19) of the official [ECMAScript 5.1 specification](http://www.ecma-international.org/publications/standards/Ecma-262.htm) defines the official behavior of Array.prototype.map. This function returns a new array resulting from applying the given callback function to each entry. -->\n\n\n<p>官网的 <a href=\"http://www.ecma-international.org/publications/standards/Ecma-262.htm\">ECMAScript 5.1 规范</a>的 <a href=\"http://es5.github.com/#x15.4.4.19\">15.4.4.19</a> 节定义了 Array.prototype.map 的官方行为。这个函数返回一个新数组，针对每个条件应用给定的回调函数，新数组由回调函数的返回值组成。</p>\n\n<!-- Two quick examples: -->\n\n\n<p>两个简单的例子：</p>\n\n<pre><code>[1, 2, 3].map(function (i) { return i * i }); // [1, 4, 9]\n[650,123,4567].map(String).join('-'); // \"650-123-4567\"\n</code></pre>\n\n<!-- This facilitates a one-liner to build a sequence of numbers: -->\n\n\n<p>用单行代码创建一组数字序列：</p>\n\n<pre><code>Array.apply(0, Array(3)).map(function(x, y) { return y }); // [0, 1, 2]\n</code></pre>\n\n<!-- or even English alphabets ‘ABCDEFGHIJKLMNOPQRSTUVWXYZ’: -->\n\n\n<p>甚至是英文字母表“ABCDEFGHIJKLMNOPQRSTUVWXYZ”：</p>\n\n<pre><code>Array.apply(0, Array(26)).map(function(x,y) {\n    return String.fromCharCode(y + 65);\n}).join('');\n</code></pre>\n\n<!-- For other variants, see also Brandon Benvie's usage of [apply-map](https://mail.mozilla.org/pipermail/es-discuss/2012-April/022273.html) and Ben Alman's [Object.keys](https://gist.github.com/4477847) technique. -->\n\n\n<p>对于其他的变种，查看 Brandon Benvie 的 <a href=\"https://mail.mozilla.org/pipermail/es-discuss/2012-April/022273.html\">apply-map</a> 用法和 Ben Alman 的 <a href=\"https://gist.github.com/4477847\">Object.keys</a> 技术。</p>\n\n<h2>Array.prototype.filter</h2>\n\n<!-- [Section 15.4.4.20](http://es5.github.com/#x15.4.4.20) of the official ECMAScript 5.1 defines the official behavior of Array.prototype.filter. As the name says, this function lets you include or exclude some entries of the array based on some certain criteria. Take a look at the following example: -->\n\n\n<p>官方的 ECMAScript 5.1 的 <a href=\"http://es5.github.com/#x15.4.4.20\">15.4.4.20</a> 节定义了 Array.prototype.filter 的官方行为。正如名字所示，这个函数使你可以按照一定的条件包括或排除数组中某些条目。来看看下面的例子：</p>\n\n<pre><code>[1,4,2,3,-8].filter(function(i) { return i &lt; 3 }); // [1, 2, -8]\n</code></pre>\n\n<!-- Let's extend the previous sequence number generation, say to have only odd number: -->\n\n\n<p>让我们扩展之前的数字序列生成过程，只含有奇数：</p>\n\n<pre><code>Array.apply(0, Array(6)).map(function(x,y) { return y }).\nfilter(function(x,y) { return y &amp; 1 }); // [1, 3, 5]\n</code></pre>\n\n<!-- We can also do a complicated dance to print all consonants by excluding the vowels: -->\n\n\n<p>我们也可以做一个复杂的处理来打印除了元音之外的所有辅音：</p>\n\n<pre><code>Array.apply(0, Array(26)).map(function(x,y) { return String.fromCharCode(y + 65) }).\nfilter(function(s) { return 'AEUIO'.indexOf(s) &lt; 0 }).join('');\n</code></pre>\n\n<!-- Real-world applications are likely more practical than the above snippets. It could be something like: -->\n\n\n<p>真实世界的应用程序可能比上面的代码片段更实用。它可能是这样的：</p>\n\n<!-- Give me the list of house prices in a certain ZIP code\nWhat is the total expense of our Engineering department?\nFind the best paid professions of Gen X -->\n\n\n<ul>\n<li>给出某个邮政编码地区的房价列表</li>\n<li>工程部门的总开支是多少？</li>\n<li>找出 X 一代薪酬最高的职业</li>\n</ul>\n\n\n<blockquote><p>译注：Generation X n. 无名一代；X一代；被遗忘的一代（出生于1970年代的美国人）</p></blockquote>\n\n<!-- ##  Array Comprehension -->\n\n\n<h2>数组推导式</h2>\n\n<!-- [Array comprehension](https://developer.mozilla.org/en-US/docs/JavaScript/Guide/Predefined_Core_Objects#Array_comprehensions) is a syntax feature which has been available in Firefox for a while. It is however not part of the 5th edition of ECMAScript and hence no other browser supports it. The good news is that array comprehension is being incorporated into the next [ECMAScript 6](http://wiki.ecmascript.org/doku.php?id=harmony:specification_drafts). The latest 2012/12/21 draft includes the grammar of array comprehension in [section 11.1.4.2](http://teramako.github.com/ECMAScript/ecma6th_syntax.html#11.1.4.2). -->\n\n\n<p>数组推导式是一个语法特性，Firefox 支持它已经有一段时间了。然而它不是 ECMAScript 5 的一部分，因此没有其他的浏览器支持它。好消息是，数组推导式被并入下一个 <a href=\"http://wiki.ecmascript.org/doku.php?id=harmony:specification_drafts\">ECMAScript 6</a>。最新的 2012/12/21 草稿的 <a href=\"http://teramako.github.com/ECMAScript/ecma6th_syntax.html#11.1.4.2\">11.1.4.2 节</a> 包含了数组推导式。</p>\n\n<!-- An easy way to understand how array comprehension works is by comparing it with map and filter. See the following two lines, they give the same exact result. The second line is something you have seen in the previous map example. -->\n\n\n<p>理解数组推导式是如何工作的一个简单方法是，把它与 map 和 filter 比较。参阅下面的两个代码，它们给出完全相同的结果。其中第二行在前面的 map 示例中已经看到过。</p>\n\n<pre><code>[i * i for i of [1, 2, 3]]; // [1, 4, 9]\n[1, 2, 3].map(function (i) { return i * i }); // [1, 4, 9]\n</code></pre>\n\n<!-- The fun part is when you use two `for` clauses or more. The following line creates a list which contains the references to all 64 possible squares in a chess board, from 'a1' to 'h8'. -->\n\n\n<p>当你使用两个或更多个 <code>foo</code> 之句时，事情变得有趣起来。下面这行代码创建一个列表，包含了棋盘从“A1”到“H8”的所有 64 个可能的方块。</p>\n\n<pre><code>[(x+y) for x of 'abcdefgh'.split('') for y of '12345678'.split('')];\n</code></pre>\n\n<!-- If this still looks confusing, I highly recommend understanding the syntax tree, for example by using Esprima's [syntax visualization](http://esprima.googlecode.com/git-history/harmony/demo/parse.html). -->\n\n\n<p>如果看起来仍然很混乱，我非常推荐理解它的语法树，例如通过使用 Esprima 的<a href=\"http://esprima.googlecode.com/git-history/harmony/demo/parse.html\">可视化语法</a>。</p>\n\n<p><img src=\"http://ariya.ofilabs.com/wp-content/uploads/2013/01/es6comprehension.png\" alt=\"es6comprehension\" /></p>\n\n<!-- **Note:** A minor syntax difference between ES6 and Firefox is that ES6 does not use brackets for the for clause. Firefox's array comprehension also support for-in form (I am not sure whether this will make it into ES6). It can simplify some construct, generating a sequence of numbers can be rewritten as `[j for (j in Array.apply(0, Array(3)))]`. -->\n\n\n<p><strong>注：</strong> ES6 和 Firefox 之间有微小语法差异，就是 ES6 中的 for 子句不使用括号。Firefox 的数组推导式还支持 for-in 形式（我不知道是否会进入 ES6）。它可以简化某些构造过程，例如要产生一组数字序列，可以改写为 <code>[j for (j in Array.apply(0, Array(3)))]</code>。</p>\n\n<!-- Filtering using array comprehension is straightforward. Again, compare the two different forms here: -->\n\n\n<p>使用数组推导式执行过滤是简单的。在这里再次比较两种不同的形式：</p>\n\n<pre><code>[i for i of [1,4,2,3,-8] if (i &lt; 3)]; \n[1,4,2,3,-8].filter(function(i) { return i &lt; 3 }); // [1, 2, -8]\n</code></pre>\n\n<!-- And the simplification of printing the sequence of all alphabets: -->\n\n\n<p>以及简化字母表序列的打印：</p>\n\n<pre><code>[String.fromCharCode(65 + i) for i of  Array.apply(0, Array(26)).\nmap(function(x, y) { return y; })].join('');\n</code></pre>\n\n<!-- and just the consonants: -->\n\n\n<p>以及只包含辅音：</p>\n\n<pre><code>[j for j of [String.fromCharCode(65 + i)\nfor i of Array.apply(0, Array(26)).map(function(x, y) { return y; })]\nif ('AEUIO'.indexOf(j) &lt; 0)].join('');\n</code></pre>\n\n<!-- As an exercise, analyze the following expression. What it does is producing the list of all prime numbers less than 100. You can see that there is no need for a manual loop at all. Note that since we are talking about next-generation JavaScript, we also use the arrow function ([Section 13.2](http://teramako.github.com/ECMAScript/ecma6th_syntax.html#13.2)) to shorten the incantation. -->\n\n\n<p>分析下面的表达式作为一个练习。它的作用是产生小于 100 的素数列表。可以看到没有必要手动的循环遍历所有数字。请注意，由于我们是在谈论下一代 JavaScript，我们还可以使用 Arrow Function（<a href=\"http://teramako.github.com/ECMAScript/ecma6th_syntax.html#13.2\">13.2 节</a>）来缩短代码。</p>\n\n<blockquote><p>译注：incantation n. 咒语</p></blockquote>\n\n<pre><code>[x\n  for x of Array.apply(0, Array(99)).map((x, y) =&gt; y + 2)\n  if [(x % i)\n     for i of Array.apply(0, Array(1 + Math.round(Math.sqrt(x)))).map((x, y) =&gt; y)\n     if ((i &gt; 1) &amp;&amp; ((x % i) === 0))\n  ].length === 0\n];\n</code></pre>\n\n<p>With the support for array comprehension, JavaScript is getting more and more functional. If you come from Python, Haskell, Scala, or another modern language, you won't feel so powerless anymore!</p>\n\n<p>随着对数组推导式的支持，JavaScript 具备越来越多的功能。如果你来自 Python、Hashhell、Scala 或其他现代语言，你就不会干到那么无能为力了！</p>\n"
            ],
            "link": [
              "http://nuysoft.github.com/2013/04/03/es6-and-array-comprehension"
            ],
            "guid": [
              "http://nuysoft.github.com/2013/04/03/es6-and-array-comprehension"
            ],
            "pubDate": [
              "2013-04-03T00:00:00-07:00"
            ]
          },
          {
            "title": [
              "ECMAScript 6"
            ],
            "description": [
              "\n\n<ul>\n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n      \n        <li>\n            <a href=\"/2013/08/11/es6-and-proxy\">ECMAScript 6 and Proxy </a>\n            <br>\n            <span>代理。拦截对象的操作。</span>\n        </li>\n      \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n      \n        <li>\n            <a href=\"/2013/04/03/es6-and-spread-operator\">ECMAScript 6 and Spread Operator</a>\n            <br>\n            <span>展开操作符。把数组转换成连续的参数。</span>\n        </li>\n      \n    \n  \n    \n      \n        <li>\n            <a href=\"/2013/04/03/es6-and-rest-parameter\">ECMAScript 6 and Rest Parameter</a>\n            <br>\n            <span>可变参数。处理可变数目的函数参数。</span>\n        </li>\n      \n    \n  \n    \n      \n        <li>\n            <a href=\"/2013/04/03/es6-and-object-literal-property-value-shorthand\">ECMAScript 6 and Object Literal Property Value Shorthand</a>\n            <br>\n            <span>对象字面属性值简写。属性值与属性标识符同名。</span>\n        </li>\n      \n    \n  \n    \n      \n        <li>\n            <a href=\"/2013/04/03/es6-and-method-definitions\">ECMAScript 6 and Method Definitions</a>\n            <br>\n            <span>方法定义。定义一个属性方法，而不使用关键字 function。</span>\n        </li>\n      \n    \n  \n    \n      \n        <li>\n            <a href=\"/2013/04/03/es6-and-destructuring-assignment\">ECMAScript 6 and Destructuring Assignment</a>\n            <br>\n            <span>解构赋值。使用模式提取对象的部分。</span>\n        </li>\n      \n    \n  \n    \n      \n        <li>\n            <a href=\"/2013/04/03/es6-and-default-argument\">ECMAScript 6 and Default Argument</a>\n            <br>\n            <span>默认参数。一个函数声明可以为每个参数指定一个默认值。</span>\n        </li>\n      \n    \n  \n    \n      \n        <li>\n            <a href=\"/2013/04/03/es6-and-arrow-function\">ECMAScript 6 and Arrow Function</a>\n            <br>\n            <span>箭头函数。函数表达式的简写形式。</span>\n        </li>\n      \n    \n  \n    \n      \n        <li>\n            <a href=\"/2013/04/03/es6-and-array-comprehension\">ECMAScript 6 and Array Comprehension</a>\n            <br>\n            <span>数组推导式。基于另一个数组创建数组的简洁方式。</span>\n        </li>\n      \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n</ul>\n\n"
            ],
            "link": [
              "http://nuysoft.github.com/2013/04/03/es6"
            ],
            "guid": [
              "http://nuysoft.github.com/2013/04/03/es6"
            ],
            "pubDate": [
              "2013-04-03T00:00:00-07:00"
            ]
          },
          {
            "title": [
              "2013年又慢半拍"
            ],
            "description": [
              "<p>2012年末翻照片，着实忆不起什么季节哪个月份什么缘由，某日对着镜子，居然颇多白发，又是什么时候，开心的、不开心的，都模糊了，依稀只记得一些平淡的画面，窗外下起了大雪，近乎空白，选择性失忆又发作了，有那么几分钟的胸口发凉，幡然跳出2011年的另一个画面，在脑子里一直盘旋了好几个月，是慢热还是懦弱，想亲身亲口问句，2011年，你还好吗？</p>\n\n<p>2012年很累、很沉默、很放纵，在写作截稿之日，突然平静下来只想饱睡一觉，什么专业事业财务自由，通通平淡的很。一年，就干了一件事。</p>\n\n<p>春节前听母亲说奶奶病重，一阵心惊继而惘然。爷爷奶奶年轻时“漂泊”至庙塆村，皆是辛劳一生，爷爷早逝，奶奶晚年病恙不断。大年初一拜时尚能起坐说说话，不想初四拜村中长辈途中忽闻仙去，怅然而泣，初五与父亲向外地长辈告丧，在灵房躺了一下午，烟呛着凉致扁桃体发炎，高烧难受不能吞咽独站，之后便半日吊瓶半日守孝，身后之事自有父辈操劳打点，孙辈接应着前来祭奠的亲戚朋友，爷爷的坟头也迁了出来，期间种种凉凄不胜唏嘘，初九于村里出殡，初十天不亮合葬，拉棺、入墓、封口、填土、起坟、鞭炮响起，一生，就此掩住。</p>\n\n<p>上班之后，诸事不紊，又近清明，以此文疏忆2012年，以平不稳之心绪，以寄2013年之念相。</p>\n\n<p>2013年4月2日 杭州</p>\n"
            ],
            "link": [
              "http://nuysoft.github.com/2013/04/02/2013"
            ],
            "guid": [
              "http://nuysoft.github.com/2013/04/02/2013"
            ],
            "pubDate": [
              "2013-04-02T00:00:00-07:00"
            ]
          },
          {
            "title": [
              "Gruntfile 示例"
            ],
            "description": [
              "<blockquote><p>原文：<a href=\"https://github.com/gruntjs/grunt/wiki/Sample-Gruntfile\">https://github.com/gruntjs/grunt/wiki/Sample-Gruntfile</a></p></blockquote>\n\n<!-- Below we walk through a sample gruntfile which uses five grunt plugins: -->\n\n\n<p>下面我们介绍和分析一个 Gruntfile 示例，其中使用了 5 个 grunt 插件：</p>\n\n<ul>\n<li><a href=\"https://github.com/gruntjs/grunt-contrib-uglify\">grunt-contrib-uglify</a></li>\n<li><a href=\"https://github.com/gruntjs/grunt-contrib-qunit\">grunt-contrib-qunit</a></li>\n<li><a href=\"https://github.com/gruntjs/grunt-contrib-concat\">grunt-contrib-concat</a></li>\n<li><a href=\"https://github.com/gruntjs/grunt-contrib-jshint\">grunt-contrib-jshint</a></li>\n<li><a href=\"https://github.com/gruntjs/grunt-contrib-watch\">grunt-contrib-watch</a></li>\n</ul>\n\n\n<!-- The entire Gruntfile is at the bottom of this page, but if you keep reading we'll walk through it a step at a time. -->\n\n\n<p>完整的 Gruntfile 在页面底部，但是如果你继续读下去，我们会每次只处理一步。</p>\n\n<!-- The first part is the \"wrapper\" function, which encapsulates your Grunt configuration. -->\n\n\n<p>第一个部分是”包裹“函数，封装你的 Grunt 配置。</p>\n\n<pre><code>module.exports = function(grunt) {\n}\n</code></pre>\n\n<!-- Within there we can then initialize our configuration object: -->\n\n\n<p>在“包裹”函数中，我可以稍后初始化我们的配置对象：</p>\n\n<pre><code>grunt.initConfig({\n});\n</code></pre>\n\n<!-- Next we can read in the project settings from the `package.json` file into the `pkg` property. This allows us to refer to the values of properties within our `package.json` file, as we'll see shortly. -->\n\n\n<p>接下来，我们可以从文件 <code>package.json</code> 读取项目配置到属性 <code>pkg</code>。这使得我们可以引用文件 <code>package.json</code> 中的属性值，我很快就会看到这一点。</p>\n\n<pre><code>pkg: grunt.file.readJSON('package.json')\n</code></pre>\n\n<!-- This leaves us with this so far: -->\n\n\n<p>到目前为止的 Gruntfile：</p>\n\n<pre><code>module.exports = function(grunt) {\n  grunt.initConfig({\n    pkg: grunt.file.readJSON('package.json');\n  });\n};\n</code></pre>\n\n<!-- Now we can define configuration for each of the tasks we have. The configuration object for a task lives as a property on the configuration object, that's named the same as the task. So the \"concat\" task goes in our config object under the \"concat\" key. Below is my configuration object for the \"concat\" task. I -->\n\n\n<p>现在，我们可以为每个任务定义配置。一个任务的配置对象挂在整个配置对象的一个属性上，属性名与任务同名。因此，任务 “concat” 在配置对象中对应一个属性 “concat”。下面是任务“concat”的配置对象。</p>\n\n<pre><code>concat: {\n  options: {\n    // define a string to put between each file in the concatenated output\n    separator: ';'\n  },\n  dist: {\n    // the files to concatenate\n    src: ['src/**/*.js'],\n    // the location of the resulting JS file\n    dest: 'dist/&lt;%= pkg.name %&gt;.js'\n  }\n}\n</code></pre>\n\n<!-- Note how I refer to the `name` property that's in the JSON file. We access this using `pkg.name` as earlier we defined the `pkg` property to be the result of loading the `package.json` file, which is then parsed to a JavaScript object. Grunt has simple template engine to output the values of properties in the configuration object. Here I tell the concat task to concatenate all files that exist within `src/` and end in `.js`. -->\n\n\n<p>请注意我是如何在 JSON 文件中应用属性 <code>name</code> 的。我们通过使用 <code>pkg.name</code> 来访问，在前面我们定义了属性 <code>pkg</code> 为文件 <code>package.json</code> 的加载结果，它被解析为一个 JavaScript 对象。Grunt 拥有简单的模板引擎，来输出配置对象中的属性值。在这里，我告诉任务 concat 合并 <code>src/</code> 下以 <code>.js</code> 结尾的所有文件。</p>\n\n<!-- Now lets configure the uglify plugin, which minifies our JavaScript: -->\n\n\n<p>现在，让我们配置 uglify 插件，压缩我们的 JavaScript 代码：</p>\n\n<pre><code>uglify: {\n  options: {\n    // the banner is inserted at the top of the output\n    banner: '/*! &lt;%= pkg.name %&gt; &lt;%= grunt.template.today(\"dd-mm-yyyy\") %&gt; */\\n'\n  },\n  dist: {\n    files: {\n      'dist/&lt;%= pkg.name %&gt;.min.js': ['&lt;%= concat.dist.dest %&gt;']\n    }\n  }\n}\n</code></pre>\n\n<!-- This tells uglify to create a file within `dist/` that contains the result of minifying the JavaScript files. Here I use `<%= concat.dist.dest %>` so uglify will minify the file that the concat task produces. -->\n\n\n<p>上面的配置告诉任务 uglify 在 <code>dist/</code> 下创建一个包含了压缩后的 JavaScript 的文件。在这里，我使用了 <code>&lt;%= concat.dist.dest %&gt;</code>，因此 uglify 将压缩任务 concat 产生的文件。</p>\n\n<!-- The QUnit plugin is really simple to set up. You just need to give it the location of the test runner files, which are the HTML files QUnit runs on. -->\n\n\n<p>QUnit 插件非常易于设置。你只需要给定测试运行文件的位置，QUnit 在这些 HTML 文件上运行。</p>\n\n<pre><code>qunit: {\n  files: ['test/**/*.html']\n},\n</code></pre>\n\n<!-- The JSHint plugin is also very simple to configure: -->\n\n\n<p>JSHint 插件的配置也很简单：</p>\n\n<pre><code>jshint: {\n  // define the files to lint\n  files: ['gruntfile.js', 'src/**/*.js', 'test/**/*.js'],\n  // configure JSHint (documented at http://www.jshint.com/docs/)\n  options: {\n    // more options here if you want to override JSHint defaults\n    globals: {\n      jQuery: true,\n      console: true,\n      module: true\n    }\n  }\n}\n</code></pre>\n\n<!-- JSHint simply takes an array of files and then an object of options. These are all [documented on the JSHint site](http://www.jshint.com/docs/). If you're happy with the JSHint defaults, there's no need to redefine them in the Gruntfile. -->\n\n\n<p>JSHint 简单的接受一个文件数组和一个选项对象。<a href=\"http://www.jshint.com/docs/\">JSHint 网站上的文档</a>描述了所有的选项。如果用 JSHint 默认值用的很开心，就没有必要在 Gruntfile 中重新它们。</p>\n\n<!-- Finally we have the watch plugin: -->\n\n\n<p>最后，我们还有 watch 插件：</p>\n\n<pre><code>watch: {\n  files: ['&lt;%= jshint.files %&gt;'],\n  tasks: ['jshint', 'qunit']\n}\n</code></pre>\n\n<!-- This can be run on the command line with `grunt watch`. When it detects any of the files specified have changed (here, I just use the same files I told JSHint to check), it will run the tasks you specify, in the order they appear. -->\n\n\n<p>可以在命令行中通过 <code>grunt watch</code> 来运行它。当它检测到任何指定的文件发生变化时（在这里，我只是使用了与 JSHint 相同的文件），它将运行指定的任务，按照出现的顺序。</p>\n\n<!-- Finally, we have to load in the Grunt plugins we need. These should have all been installed through npm. -->\n\n\n<p>最后，我们必须加载所需的 Grunt 插件。它们应该已经通过 npm 安装了。</p>\n\n<pre><code>grunt.loadNpmTasks('grunt-contrib-uglify');\ngrunt.loadNpmTasks('grunt-contrib-jshint');\ngrunt.loadNpmTasks('grunt-contrib-qunit');\ngrunt.loadNpmTasks('grunt-contrib-watch');\ngrunt.loadNpmTasks('grunt-contrib-concat');\n</code></pre>\n\n<!-- And finally set up some tasks. Most important is the default task: -->\n\n\n<p>并且在最后我们设置了一些任务。其中最重要的是 default 任务：</p>\n\n<pre><code>// this would be run by typing \"grunt test\" on the command line\ngrunt.registerTask('test', ['jshint', 'qunit']);\n\n// the default task can be run just by typing \"grunt\" on the command line\ngrunt.registerTask('default', ['jshint', 'qunit', 'concat', 'uglify']);\n</code></pre>\n\n<!-- And here's the finished `Gruntfile.js`: -->\n\n\n<p>下面是完成后的 <code>Gruntfile.js</code>：</p>\n\n<pre><code>module.exports = function(grunt) {\n  //\n  grunt.initConfig({\n    pkg: grunt.file.readJSON('package.json'),\n    concat: {\n      options: {\n        separator: ';'\n      },\n      dist: {\n        src: ['src/**/*.js'],\n        dest: 'dist/&lt;%= pkg.name %&gt;.js'\n      }\n    },\n    uglify: {\n      options: {\n        banner: '/*! &lt;%= pkg.name %&gt; &lt;%= grunt.template.today(\"dd-mm-yyyy\") %&gt; */\\n'\n      },\n      dist: {\n        files: {\n          'dist/&lt;%= pkg.name %&gt;.min.js': ['&lt;%= concat.dist.dest %&gt;']\n        }\n      }\n    },\n    qunit: {\n      files: ['test/**/*.html']\n    },\n    jshint: {\n      files: ['gruntfile.js', 'src/**/*.js', 'test/**/*.js'],\n      options: {\n        // options here to override JSHint defaults\n        globals: {\n          jQuery: true,\n          console: true,\n          module: true,\n          document: true\n        }\n      }\n    },\n    watch: {\n      files: ['&lt;%= jshint.files %&gt;'],\n      tasks: ['jshint', 'qunit']\n    }\n  });\n  //\n  grunt.loadNpmTasks('grunt-contrib-uglify');\n  grunt.loadNpmTasks('grunt-contrib-jshint');\n  grunt.loadNpmTasks('grunt-contrib-qunit');\n  grunt.loadNpmTasks('grunt-contrib-watch');\n  grunt.loadNpmTasks('grunt-contrib-concat');\n  //\n  grunt.registerTask('test', ['jshint', 'qunit']);\n  //\n  grunt.registerTask('default', ['jshint', 'qunit', 'concat', 'uglify']);\n};\n</code></pre>\n"
            ],
            "link": [
              "http://nuysoft.github.com/2013/03/29/grunt-sample-gruntfile"
            ],
            "guid": [
              "http://nuysoft.github.com/2013/03/29/grunt-sample-gruntfile"
            ],
            "pubDate": [
              "2013-03-29T00:00:00-07:00"
            ]
          },
          {
            "title": [
              "项目脚手架"
            ],
            "description": [
              "<blockquote><p>原文：<a href=\"https://github.com/gruntjs/grunt/wiki/Project-Scaffolding\">https://github.com/gruntjs/grunt/wiki/Project-Scaffolding</a></p></blockquote>\n\n<h2>grunt-init</h2>\n\n<!-- Grunt-init is a scaffolding tool used to automate project creation. It will build an entire directory structure based on the current environment and the answers to a few questions. The exact files and contents created depend on the template chosen along with the answers to the questions asked. -->\n\n\n<p>grunt-init 是一个脚手架工具，用于自动创建项目。基于当前的环境和几个问题的答案创建一个完整的目录结构。确切的文件和内容取决于所选的模板，和模板提出的问题的答案。</p>\n\n<!-- _Note: This standalone utility used to be built-in to Grunt as the \"init\" task. See the Grunt [Upgrading from 0.3 to 0.4](https://github.com/gruntjs/grunt/wiki/Upgrading-from-0.3-to-0.4) guide for more information about this change._ -->\n\n\n<p><em>注：本独立程序曾经作为“init”任务内置于 Grunt。关于该变化的更多信息查看 Grunt <a href=\"https://github.com/gruntjs/grunt/wiki/Upgrading-from-0.3-to-0.4\">从 0.3 升级到 0.4</a> 指南。</em></p>\n\n<!-- ## Installation -->\n\n\n<h2>安装</h2>\n\n<!-- In order to use grunt-init, you'll want to install it globally. -->\n\n\n<p>为了使用 grunt-init，你需要全局安装它。</p>\n\n<p><code>shell\nnpm install -g grunt-init\n</code></p>\n\n<!-- This will put the `grunt-init` command in your system path, allowing it to be run from anywhere. -->\n\n\n<p>这将把将命令 <code>grunt-init</code> 放入系统路径中，从而可以从任意目录运行它。</p>\n\n<!-- _Notes: You may need to use sudo or run your command shell as Administrator to do this._ -->\n\n\n<p><em>注：你可能需要使用指令 sudo 或者以管理员身份运行命令解释程序来做到这一点。</em></p>\n\n<!-- ## Usage -->\n\n\n<h2>用法</h2>\n\n<!-- * Get program help and a listing of available templates with `grunt-init --help`\n* Create a project based around an available template with `grunt-init TEMPLATE`\n* Create a project based around a arbitrarily-located template with `grunt-init /path/to/TEMPLATE` -->\n\n\n<ul>\n<li>使用 <code>grunt-init --help</code> 获取程序帮助和可用的模板列表。</li>\n<li>使用 <code>grunt-init TEMPLATE</code> 基于一个可用的模板创建一个项目。</li>\n<li>使用 <code>grunt-init /path/to/TEMPLATE</code> 基于一个任意位置的模板创建一个项目。</li>\n</ul>\n\n\n<!-- Note that most templates generate their files in the current directory, so be sure to change to a new directory first if you don't want to overwrite existing files. -->\n\n\n<p>需要注意的是，大多数模板在当前目录中生成它们的文件，因此一定要先切换到一个新目录，如果不希望覆盖已有文件的话。</p>\n\n<!-- ## Installing templates -->\n\n\n<h2>安装模板</h2>\n\n<p>Once templates are installed into your <code>~/.grunt-init/</code> directory (<code>%USERPROFILE%\\.grunt-init\\</code> on Windows) they will be available for use via grunt-init. It's recommended that you use git to clone a template into that directory. For example, the <a href=\"https://github.com/gruntjs/grunt-init-jquery\">grunt-init-jquery</a> template can be installed like so:</p>\n\n<p>一旦模板被安装到 <code>~/.grunt-init/</code> 目录（在 Windows 上是 <code>%USERPROFILE%\\.grunt=init\\</code>），就可以通过 grunt-init 使用它们。使用你使用 git 拷贝一个模范到该目录中。例如，可以这样安装 <a href=\"https://github.com/gruntjs/grunt-init-jquery\">grunt-init-jquery</a> 模板：</p>\n\n<pre><code>git clone git@github.com:gruntjs/grunt-init-jquery.git ~/.grunt-init/jquery\n</code></pre>\n\n<!-- _Note: if you want to make the template available locally as \"foobarbaz\" you could specify `~/.grunt-init/foobarbaz` while cloning. Grunt-init will use the actual template directory name as it exists inside of the `~/.grunt-init/` directory._ -->\n\n\n<p><em>注：如果你想以“foobarbaz”在本地使用模板，你可以在拷贝时指定<code>~/.grunt-init/foobarbaz</code>。grunt-init 将使用模板在目录 <code>~/.grunt-init/</code> 中的实际目录名。</em></p>\n\n<p>A few grunt-init templates are maintained officially:</p>\n\n<p>一些 grunt-init 模板由官方维护：</p>\n\n<!-- * [grunt-init-commonjs](https://github.com/gruntjs/grunt-init-commonjs) - Create a commonjs module, including Nodeunit unit tests. ([sample \"generated\" repo](https://github.com/gruntjs/grunt-init-commonjs-sample/tree/generated) | [creation transcript](https://github.com/gruntjs/grunt-init-commonjs-sample#project-creation-transcript))\n* [grunt-init-gruntfile](https://github.com/gruntjs/grunt-init-gruntfile) - Create a basic Gruntfile. ([sample \"generated\" repo](https://github.com/gruntjs/grunt-init-gruntfile-sample/tree/generated) | [creation transcript](https://github.com/gruntjs/grunt-init-gruntfile-sample#project-creation-transcript))\n* [grunt-init-gruntplugin](https://github.com/gruntjs/grunt-init-gruntplugin) - Create a Grunt plugin, including Nodeunit unit tests. ([sample \"generated\" repo](https://github.com/gruntjs/grunt-init-gruntplugin-sample/tree/generated) | [creation transcript](https://github.com/gruntjs/grunt-init-gruntplugin-sample#project-creation-transcript))\n* [grunt-init-jquery](https://github.com/gruntjs/grunt-init-jquery) - Create a jQuery plugin, including QUnit unit tests. ([sample \"generated\" repo](https://github.com/gruntjs/grunt-init-jquery-sample/tree/generated) | [creation transcript](https://github.com/gruntjs/grunt-init-jquery-sample#project-creation-transcript))\n* [grunt-init-node](https://github.com/gruntjs/grunt-init-node) - Create a Node.js module, including Nodeunit unit tests. ([sample \"generated\" repo](https://github.com/gruntjs/grunt-init-node-sample/tree/generated) | [creation transcript](https://github.com/gruntjs/grunt-init-node-sample#project-creation-transcript)) -->\n\n\n<ul>\n<li><a href=\"https://github.com/gruntjs/grunt-init-commonjs\">grunt-init-commonjs</a> - 创建一个 commonjs 模块，包括 Nodeunit 单元测试。（<a href=\"https://github.com/gruntjs/grunt-init-commonjs-sample/tree/generated\">生成的样本库</a> | <a href=\"https://github.com/gruntjs/grunt-init-commonjs-sample#project-creation-transcript\">创建记录</a>）</li>\n<li><a href=\"https://github.com/gruntjs/grunt-init-gruntfile\">grunt-init-gruntfile</a> - 创建一个基本的 Gruntfile。（<a href=\"https://github.com/gruntjs/grunt-init-gruntfile-sample/tree/generated\">生成的样本库</a> | <a href=\"https://github.com/gruntjs/grunt-init-gruntfile-sample#project-creation-transcript\">创建记录</a>）</li>\n<li><a href=\"https://github.com/gruntjs/grunt-init-gruntplugin\">grunt-init-gruntplugin</a> -创建一个 Grunt 插件，包含 Nodeunit 单元测试。（<a href=\"https://github.com/gruntjs/grunt-init-gruntplugin-sample/tree/generated\">生成的样本库</a> | <a href=\"https://github.com/gruntjs/grunt-init-gruntplugin-sample#project-creation-transcript\">创建记录</a>）</li>\n<li><a href=\"https://github.com/gruntjs/grunt-init-jquery\">grunt-init-jquery</a> - 创建一个 jQuery 插件，包含 Nodeunit 单元测试。（<a href=\"https://github.com/gruntjs/grunt-init-jquery-sample/tree/generated\">生成的样本库</a> | <a href=\"https://github.com/gruntjs/grunt-init-jquery-sample#project-creation-transcript\">创建记录</a>）</li>\n<li><a href=\"https://github.com/gruntjs/grunt-init-node\">grunt-init-node</a> - 创建一个 Node.js 模块，包含 Nodeunit 单元测试。（<a href=\"https://github.com/gruntjs/grunt-init-node-sample/tree/generated\">生成的样本库</a> | <a href=\"https://github.com/gruntjs/grunt-init-node-sample#project-creation-transcript\">创建记录</a>）</li>\n</ul>\n\n\n<!-- ## Custom templates -->\n\n\n<h2>自定义模板</h2>\n\n<!-- You can create and use custom templates. Your template must follow the same structure as the aforementioned templates. -->\n\n\n<p>你可以创建和使用自定义模板。你的模板必须遵循与上述模板同样的结构。</p>\n\n<!-- A sample template named `my-template` would follow this general file structure: -->\n\n\n<p>一个命名为 <code>my-template</code> 的模板要遵循下面的通用文件结构：</p>\n\n<!-- * `my-template/template.js` - the main template file.\n* `my-template/rename.json` - template-specific rename rules, processed as templates.\n* `my-template/root/` - files to be copied into the target location. -->\n\n\n<ul>\n<li><code>my-template/template.js</code> - 主模板文件.</li>\n<li><code>my-template/rename.json</code> - 模板特定的命名规则，作为模板处理。</li>\n<li><code>my-template/root/</code> - 拷贝到目标位置的文件。</li>\n</ul>\n\n\n<!-- Assuming these files exist at `/path/to/my-template`, the command `grunt-init /path/to/my-template` would be used to process the template. Multiple uniquely-named templates may exist in the same directory, just like the [built-in templates][]. -->\n\n\n<p>假设这些文件已经在 <code>/path/to/my-template</code>，可以用命令 <code>grunt-init /path/to/my-template</code> 处理该模板。多个不重名的模板可以存在于同一个目录项，就像内置模板一样。</p>\n\n<blockquote><p>没有在内置模板中找到多个不重名模板，疑问中</p></blockquote>\n\n<!-- Additionally, if you place this custom template in your `~/.grunt-init/` directory (`%USERPROFILE%\\.grunt-init\\` on Windows) it will be automatically available to be used with just `grunt-init my-template`. -->\n\n\n<p>此外，如果将自定义模板放入 <code>~/.grunt-init/</code> 目录（Windows 上是 <code>%USERPROFILE%\\.grunt-init\\</code>），运行 <code>grunt-init my-template</code> 将自动被使用。</p>\n\n<!-- ### Copying files -->\n\n\n<h3>拷贝文件</h3>\n\n<!-- As long as a template uses the `init.filesToCopy` and `init.copyAndProcess` methods, any files in the `root/` subdirectory will be copied to the current directory when the init template is run. -->\n\n\n<p>当 init 模板运行时，只要一个模板使用方法 <code>init.filesToCopy</code> 和 <code>init.copyAndProcess</code>，目录 <code>root/</code> 中的所有文件将被复制到当前目录。</p>\n\n<!-- Note that all copied files will be processed as templates, with any `{ % % }` template being processed against the collected `props` data object, unless the `noProcess` option is set. See the [jquery template](https://github.com/gruntjs/grunt-init-jquery) for an example. -->\n\n\n<p>请注意，所以拷贝文件会被当作模板处理，模板 <code>{ % % }</code> 将在收集的 <code>props</code> 数据对象下处理，除非设置了选项 <code>noProcess</code>。看看 <a href=\"https://github.com/gruntjs/grunt-init-jquery\">jQuery 模板</a>例子。</p>\n\n<!-- ### Renaming or excluding template files -->\n\n\n<h3>重命名或不包括模板文件</h3>\n\n<!-- The `rename.json` describes `sourcepath` to `destpath` rename mappings. The `sourcepath` must be the path of the file-to-be-copied relative to the `root/` folder, but the `destpath` value can contain `{ % % }` templates, describing what the destination path will be. -->\n\n\n<p><code>rename.json</code> 描述 <code>sourcepath</code> 到 <code>destpath</code> 的重命名映射。<code>sourcepath</code> 必须是 <code>root/</code> 文件夹下将被拷贝文件的路径，而 <code>destpath</code> 值可以包含 <code>{ % % }</code> 模板，描述目标路径是什么。</p>\n\n<!-- If `false` is specified as a `destpath` the file will not be copied. Also, glob patterns are supported for `srcpath`. -->\n\n\n<p>如果指定 <code>destpath</code> 为 <code>false</code>，该文件不会被复制。此外，<code>srcpath</code> 支持通配符。</p>\n\n<!-- ## Specifying default prompt answers -->\n\n\n<h2>指定默认提示答案</h2>\n\n<!-- Each init prompt either has a default value hard-coded or it looks at the current environment to attempt to determine that default value. If you want to override a particular prompt's default value, you can do so in the optional OS X or Linux `~/.grunt-init/defaults.json` or Windows `%USERPROFILE%\\.grunt-init\\defaults.json` file. -->\n\n\n<p>没有初始化提示或者有一个硬编码的默认值，或者产看当前环境来尝试判断默认值。如果你想覆盖个别提示的默认值，你可以在选项文件 <code>~/.grunt-init/defaults.json</code>（OS X 或 Linux）或 <code>%USERPROFILE%\\.grunt-init\\defaults.json</code>（Window）中这么做。</p>\n\n<!-- For example, my `defaults.json` file looks like this, because I want to use a slightly different name than the default name, I want to exclude my email address, and I want to specify an author url automatically. -->\n\n\n<p>例如，我的 <code>defaults.json</code> 文件看起来就像这样，因为我想用一个稍微不同的名称而不是默认名称，想要排除我的电子邮件地址，想自动指定一个作者网址。</p>\n\n<pre><code>{\n  \"author_name\": \"\\\"Cowboy\\\" Ben Alman\",\n  \"author_email\": \"none\",\n  \"author_url\": \"http://benalman.com/\"\n}\n</code></pre>\n\n<!-- _Note: until all the built-in prompts have been documented, you can find their names and default values in the [source code](https://github.com/gruntjs/grunt-init/blob/master/tasks/init.js)._ -->\n\n\n<p><em>注：在所有内置提示被文档化之前，你可以在<a href=\"https://github.com/gruntjs/grunt-init/blob/master/tasks/init.js\">源代码</a>中找到它们的名称和默认值。</em></p>\n\n<!-- ## Defining an init template -->\n\n\n<h2>定义一个初始化模板</h2>\n\n<blockquote><p>对照 ~/.grunt-init/node/template.js 理解。</p></blockquote>\n\n<h3>exports.description</h3>\n\n<!-- This brief template description will be displayed along with the template name when the user runs `grunt init` or `grunt-init ` to display a list of all available init templates. -->\n\n\n<p>当用户运行 <code>grunt init</code> 或 <code>grunt-init</code> 来显示所有有效的初始化模板列表时，简短的模板描述随模板名称一起显示。</p>\n\n<pre><code>exports.description = descriptionString;\n</code></pre>\n\n<!-- ### exports.notes -->\n\n\n<h3>exports.notes</h3>\n\n<!-- If specified, this optional extended description will be displayed before any prompts are displayed. This is a good place to give the user a little help explaining naming conventions, which prompts may be required or optional, etc. -->\n\n\n<p>如果指定了，该可选的扩展描述将在所有提示之前显示。这是一个很好的向用户提供一点点帮助解释命名约定的地方，哪些提示是必须或可选的，等等。</p>\n\n<pre><code>exports.notes = notesString;\n</code></pre>\n\n<h3>exports.warnOn</h3>\n\n<!-- If this optional (but recommended) wildcard pattern or array of wildcard patterns is matched, Grunt will abort with a warning that the user can override with `--force`. This is very useful in cases where the init template could potentially override existing files. -->\n\n\n<p>如果该可选（但是推荐）的通配符或通配符数组被（已存在的文件或目录）匹配，Grunt 将中止，并导致一条警告信息，用户可以使用 <code>--force</code> 覆盖该行为。这些初试化模板可能潜在的覆盖已存在文件时非常有用。</p>\n\n<pre><code>exports.warnOn = wildcardPattern;\n</code></pre>\n\n<!-- While the most common value will be `'*'`, matching any file or directory, the [minimatch](https://github.com/isaacs/minimatch) wildcard pattern syntax used allows for a lot of flexibility. For example: -->\n\n\n<p>而最常见的值是 <code>'*'</code>，匹配所有文件或文件夹，使用的 <a href=\"https://github.com/isaacs/minimatch\">minimatch</a> 通配符语法允许很大的灵活性。例如：</p>\n\n<pre><code>exports.warnOn = 'Gruntfile.js';    // Warn on a Gruntfile.js file.\nexports.warnOn = '*.js';            // Warn on any .js file.\nexports.warnOn = '*';               // Warn on any non-dotfile or non-dotdir.\nexports.warnOn = '.*';              // Warn on any dotfile or dotdir.\nexports.warnOn = '{.*,*}';          // Warn on any file or dir (dot or non-dot).\nexports.warnOn = '!*/**';           // Warn on any file (ignoring dirs).\nexports.warnOn = '*.{png,gif,jpg}'; // Warn on any image file.\n// \n// This is another way of writing the last example.\nexports.warnOn = ['*.png', '*.gif', '*.jpg'];\n</code></pre>\n\n<h3>exports.template</h3>\n\n<!-- While the `exports` properties are defined outside this function, all the actual init code is specified inside. Three arguments are passed into this function. The `grunt` argument is a reference to grunt, containing all the [grunt methods and libs](api/grunt). The `init` argument is an object containing methods and properties specific to this init template. The `done` argument is a function that must be called when the init template is done executing. -->\n\n\n<p>虽然 <code>exports</code> 属性定义在该函数之外，但是所有实际的初始化代码在该函数内指定。三个参数被传给该函数。参数 <code>grunt</code> 指向 grunt，包含了所有的 <a href=\"http://gruntjs.com/api/grunt\">grunt 方法和库</a>。参数 <code>init</code> 是一个包含了特定于该初始化模板的方法和属性的对象。参数 <code>done</code> 是一个函数，当初始化模板执行完成时必须调用该函数。</p>\n\n<pre><code>exports.template = function(grunt, init, done) {\n  // See the \"Inside an init template\" section.\n};\n</code></pre>\n\n<!-- ## Inside an init template -->\n\n\n<h2>初始化模板内部</h2>\n\n<h3>init.addLicenseFiles</h3>\n\n<!-- Add properly-named license files to the files object. -->\n\n\n<p>添加适当命名的许可证文件到 files 对象。</p>\n\n<pre><code>var files = {};\nvar licenses = ['MIT'];\ninit.addLicenseFiles(files, licenses);\n// files === {'LICENSE-MIT': 'licenses/LICENSE-MIT'}\n</code></pre>\n\n<h3>init.availableLicenses</h3>\n\n<!-- Return an array of available licenses. -->\n\n\n<p>返回有效许可证数组。</p>\n\n<pre><code>var licenses = init.availableLicenses();\n// licenses === [ 'Apache-2.0', 'GPL-2.0', 'MIT', 'MPL-2.0' ]\n</code></pre>\n\n<h3>init.copy</h3>\n\n<!-- Given an absolute or relative source path, and an optional relative destination path, copy a file, optionally processing it through the passed callback. -->\n\n\n<p>复制一个文件，指定一个绝对或相对源路径和一个可选的相对目标路径，可以通过传入的回调函数处理复制的文件。</p>\n\n<pre><code>init.copy(srcpath[, destpath], options)\n</code></pre>\n\n<h3>init.copyAndProcess</h3>\n\n<!-- Iterate over all files in the passed object, copying the source file to the destination, processing the contents. -->\n\n\n<p>遍历传入的对象中的所有文件，拷贝源文件到目标地址，并处理文件内容。</p>\n\n<pre><code>init.copyAndProcess(files, props[, options])\n</code></pre>\n\n<h3>init.defaults</h3>\n\n<!-- User-specified default init values from `defaults.json`. -->\n\n\n<p><code>defaults.json</code> 中用户指定的默认初始值。</p>\n\n<pre><code>init.defaults\n</code></pre>\n\n<h3>init.destpath</h3>\n\n<!-- Absolute destination file path. -->\n\n\n<p>绝对目标文件路径。</p>\n\n<pre><code>init.destpath()\n</code></pre>\n\n<h3>init.expand</h3>\n\n<!-- Same as [grunt.file.expand](https://github.com/gruntjs/grunt/wiki/grunt.file#wiki-grunt-file-expand). -->\n\n\n<p>与 <a href=\"https://github.com/gruntjs/grunt/wiki/grunt.file#wiki-grunt-file-expand\">grunt.file.expand</a> 一致。</p>\n\n<!-- Return a unique array of all file or directory paths that match the given wildcard pattern(s). This method accepts either comma separated wildcard patterns or an array of wildcard patterns. Paths matching patterns that begin with ! will be excluded from the returned array. Patterns are processed in order, so inclusion and exclusion order is significant. -->\n\n\n<p>返回一个不重复数组，含有匹配通配符模式的所有文件和目录路径。该方法接收逗号分割的痛佩服模式，或者通配符模式数组。匹配以 ! 开头的模式的路径将从返回值中排除。模式被顺序处理，所以包含和排除的顺序是重要的。</p>\n\n<pre><code>init.expand([options, ] patterns)\n</code></pre>\n\n<h3>init.filesToCopy</h3>\n\n<!-- Return an object containing files to copy with their absolute source path and relative destination path, renamed (or omitted) according to rules in rename.json (if it exists). -->\n\n\n<p>返回一个包含了待复制文件的对象，包含绝对源路径和相对目标路径，按照 rename.json（如果存在的话）中的规则重命名（或忽略）。</p>\n\n<pre><code>var files = init.filesToCopy(props);\n/* files === { '.gitignore': 'template/root/.gitignore',\n  '.jshintrc': 'template/root/.jshintrc',\n  'Gruntfile.js': 'template/root/Gruntfile.js',\n  'README.md': 'template/root/README.md',\n  'test/test_test.js': 'template/root/test/name_test.js' } */\n</code></pre>\n\n<h3>init.getFile</h3>\n\n<!-- Get a single task file path. -->\n\n\n<p>返回单个任务文件路径。</p>\n\n<pre><code>init.getFile(filepath[, ...])\n</code></pre>\n\n<h3>init.getTemplates</h3>\n\n<!-- Returns an object of all the available templates. -->\n\n\n<p>返回含有所有有效模板的对象。</p>\n\n<pre><code>init.getTemplates()\n</code></pre>\n\n<h3>init.initSearchDirs</h3>\n\n<!-- Initialize the directories to search for init templates. `template` is the location of a template. Will also include `~/.grunt-init/` and the core init tasks within grunt-init. -->\n\n\n<p>初始化目录来搜索初始化模板。这里的<code>模板</code>是指模板路径。会包括 <code>~/.grunt-init/</code> 和 grunt-init 中的核心初始化任务。</p>\n\n<pre><code>init.initSearchDirs([filename])\n</code></pre>\n\n<h3>init.process</h3>\n\n<!-- Start up the process to begin prompting for input. -->\n\n\n<p>启动进程，开始提示输入。</p>\n\n<pre><code>init.process(options, prompts, done)\n\ninit.process({}, [\n  // Prompt for these values\n  init.prompt('name'),\n  init.prompt('description'),\n  init.prompt('version')\n], function(err, props) {\n  // All finished, do something with the properties\n});\n</code></pre>\n\n<h3>init.prompt</h3>\n\n<!-- Prompt a user for a value. -->\n\n\n<p>提示用户输入。</p>\n\n<p><code>js\ninit.prompt(name[, default])\n</code></p>\n\n<h3>init.prompts</h3>\n\n<!-- An object of all the prompts. -->\n\n\n<p>含有所有提示的对象。</p>\n\n<p><code>js\nvar prompts = init.prompts;\n</code></p>\n\n<h3>init.readDefaults</h3>\n\n<!-- Read JSON defaults from task files (if they exist), merging them into one data object. -->\n\n\n<p>从任务文件（如果存在的话）读取 JSON 默认值，并合并到一个数据对象中。</p>\n\n<pre><code>init.readDefaults(filepath[, ...])\n</code></pre>\n\n<h3>init.renames</h3>\n\n<!-- The rename rules for the template. -->\n\n\n<p>模板的重命名规则。</p>\n\n<pre><code>var renames = init.renames;\n// renames === { 'test/name_test.js': 'test/\\{\\%= name \\%\\}_test.js' }\n</code></pre>\n\n<h3>init.searchDirs</h3>\n\n<!-- An array of directories to search for templates in. -->\n\n\n<p>目录数组，用于在其中搜索模板。</p>\n\n<pre><code>var dirs = init.searchDirs;\n/* dirs === [ '/Users/shama/.grunt-init',\n  '/usr/local/lib/node_modules/grunt-init/templates' ] */\n</code></pre>\n\n<h3>init.srcpath</h3>\n\n<!-- Search init template paths for filename and return an absolute path. -->\n\n\n<p>通过文件名搜索初始化模板路径，并返回一个绝对路径。</p>\n\n<pre><code>init.srcpath(filepath[, ...])\n</code></pre>\n\n<h3>init.userDir</h3>\n\n<!-- Returns the absolute path to the user's template directory. -->\n\n\n<p>返回用户模板路径的绝对路径。</p>\n\n<pre><code>var dir = init.userDir();\n// dir === '/Users/shama/.grunt-init'\n</code></pre>\n\n<h3>init.writePackageJSON</h3>\n\n<!-- Save a package.json file in the destination directory. The callback can be used to post-process properties to add/remove/whatever. -->\n\n\n<p>保存一个 package.json 文件到目标目录。回调函数可以用来后置处理属性，或添加或移除或其他任何操作。</p>\n\n<pre><code>init.writePackageJSON(filename, props[, callback])\n</code></pre>\n\n<!-- ## Built-in prompts -->\n\n\n<h2>内置提示</h2>\n\n<h3>author_email</h3>\n\n<p>Author's email address to use in the <code>package.json</code>. Will attempt to find a default value from the user's git config.</p>\n\n<h3>author_name</h3>\n\n<p>Author's full name to use in the <code>package.json</code> and copyright notices. Will attempt to find a default value from the user's git config.</p>\n\n<h3>author_url</h3>\n\n<p>A public URL to the author's website to use in the <code>package.json</code>.</p>\n\n<h3>bin</h3>\n\n<p>A relative path from the project root for a cli script.</p>\n\n<h3>bugs</h3>\n\n<p>A public URL to the project's issues tracker. Will default to the github issue tracker if the project has a github repository.</p>\n\n<h3>description</h3>\n\n<p>A description of the project. Used in the <code>package.json</code> and README files.</p>\n\n<h3>grunt_version</h3>\n\n<p>A valid semantic version range descriptor of Grunt the project requires.</p>\n\n<h3>homepage</h3>\n\n<p>A public URL to the project's home page. Will default to the github url if a github repository.</p>\n\n<h3>jquery_version</h3>\n\n<p>If a jQuery project, the version of jQuery the project requires. Must be a valid semantic version range descriptor.</p>\n\n<h3>licenses</h3>\n\n<p>The license(s) for the project. Multiple licenses are separated by spaces. The licenses built-in are: <code>MIT</code>, <code>MPL-2.0</code>, <code>GPL-2.0</code>, and <code>Apache-2.0</code>. Defaults to <code>MIT</code>. Add custom licenses with <a href=\"#initaddlicensefiles\">init.addLicenseFiles</a>.</p>\n\n<h3>main</h3>\n\n<p>The primary entry point of the project. Defaults to the project name within the <code>lib</code> folder.</p>\n\n<h3>name</h3>\n\n<p>The name of the project. Will be used heavily throughout the project template. Defaults to the current working directory.</p>\n\n<h3>node_version</h3>\n\n<p>The version of Node.js the project requires. Must be a valid semantic version range descriptor.</p>\n\n<h3>npm_test</h3>\n\n<p>The command to run tests on your project. Defaults to <code>grunt</code>.</p>\n\n<h3>repository</h3>\n\n<p>Project's git repository. Defaults to a guess of a github url.</p>\n\n<h3>title</h3>\n\n<p>A human readable project name. Defaults to the actual project name altered to be more human readable.</p>\n\n<h3>version</h3>\n\n<p>The version of the project. Defaults to the first valid semantic version, <code>0.1.0</code>.</p>\n"
            ],
            "link": [
              "http://nuysoft.github.com/2013/03/29/grunt-project-scaffolding"
            ],
            "guid": [
              "http://nuysoft.github.com/2013/03/29/grunt-project-scaffolding"
            ],
            "pubDate": [
              "2013-03-29T00:00:00-07:00"
            ]
          },
          {
            "title": [
              "安装 Grunt"
            ],
            "description": [
              "<blockquote><p>原文：<a href=\"https://github.com/gruntjs/grunt/wiki/Installing-grunt\">https://github.com/gruntjs/grunt/wiki/Installing-grunt</a></p></blockquote>\n\n<!-- This document explains how to install specific versions of grunt and grunt plugins.  If you haven't read the [[Getting Started]] guide, you should check that out first. -->\n\n\n<p>本文介绍了如何安装特定版本的 grunt 和 grunt 插件。如果还没有读过<a href=\"http://gruntjs.com/getting-started\">入门</a>指南，你应该先读读它。</p>\n\n<!-- ## Overview -->\n\n\n<h2>概览</h2>\n\n<!-- Grunt and grunt plugins should be defined as [devDependencies](https://npmjs.org/doc/json.html#devDependencies) in your project's [package.json](https://npmjs.org/doc/json.html).  This will allow you to install all of your project's dependencies with a single command: `npm install`.  The current stable and development versions of grunt are always listed on the wiki's [home page](https://github.com/gruntjs/grunt/wiki/). -->\n\n\n<p>Grunt 和 Grunt 插件应该被定义在项目的 <a href=\"https://npmjs.org/doc/json.html\">package.json</a> 中的 <a href=\"https://npmjs.org/doc/json.html#devDependencies\">devDependencies</a> 上。</p>\n\n<!-- ## Installing a specific version -->\n\n\n<h2>安装特定版本</h2>\n\n<!-- If you need a specific version of grunt or a grunt plugin, run `npm install grunt@VERSION --save-dev` where `VERSION` is the version you need.  This will install the specified version, adding it to your package.json devDependencies. -->\n\n\n<p>如果你需要特定版本的 Grunt 或 Grunt 插件，运行 <code>npm install grunt@VERSION --save-dev</code>，其中 <code>VERSION</code> 是你所需的版本号。这将安装特定的版本，同时添加到 package.json 的 devDependencies 中。</p>\n\n<!-- Note that a [tilde version range] will be used in your `package.json` when you add the `--save-dev` flag to `npm install`. This is typically good, as new patch releases of the specified version will automatically be upgraded as development continues, per [semver]. -->\n\n\n<p>需要注意的是，如果运行 <code>npm install</code> 添加了标记 <code>--save-dev</code>，<a href=\"https://npmjs.org/doc/json.html#Tilde-Version-Ranges\">波浪号版本范围</a>将被用于你的 <code>package.json</code>。这么做非常好，因为随着开发继续，特定版本的新补丁发布会自动更新，按照 <a href=\"http://semver.org\">semver</a> 规范。</p>\n\n<!-- ## Installing a published development version -->\n\n\n<h2>安装发布的开发版本</h2>\n\n<!-- Periodically, as new functionality is being developed, grunt builds may be published to npm. These builds will _never_ be installable without explicitly specifying a version number, and will typically have a build number or alpha/beta/release candidate designation. -->\n\n\n<p>当开发新功能之后，Grunt 编译版本可能定期发布到 npm。如果不显示地指定一个版本号，这些版本<em>永远</em>不会被安装，并且通常会有一个编译版本号，或指定内侧/公测/发布候选版。</p>\n\n<blockquote><p>译注：<a href=\"http://baike.baidu.com/view/750252.htm\">Build 版</a>，<a href=\"http://baike.baidu.com/view/707808.htm#1\">命名风格和管理策略</a></p></blockquote>\n\n<!-- Like installing a specific version of grunt, run `npm install grunt@VERSION --save-dev` where `VERSION` is the version you need, and npm will install that version of grunt in your project folder, adding it to your `package.json` devDependencies. -->\n\n\n<p>就像安装特定版本的 Grunt 一样，运行 <code>npm install grunt@VERSION --save-dev</code>，其中 <code>VERSION</code> 所需的版本号，npm 将安装指定版本的 Grunt 到你的项目目录，同时添加到 <code>package.json</code> 的 devDependencies 中。</p>\n\n<!-- Note that regardless of the version you specify, a [tilde version range][] will be specified in `package.json`. **This is very bad**, as new, possibly incompatible, patch releases of the specified development version may be installed by npm, breaking your build.\n -->\n\n\n<p>请注意，不管你指定的版本，一个<a href=\"https://npmjs.org/doc/json.html#Tilde-Version-Ranges\">波浪号版本范围</a>将被指定到 <code>package.json</code>。<strong>这是非常糟糕的</strong>，因为指定的开发版本的新补丁发布能是不兼容的，通过 npm 安装后会破坏你的编译。</p>\n\n<!-- _In this case it is **very important** that you manually edit your `package.json` and remove the ~ (tilde) from the version number. This will lock in the exact development version that you have specified._ -->\n\n\n<p><em>在这种情况下，手动编辑你的 <code>package.json</code> 并从版本号中移除 ~（波浪号）<strong>非常重要</strong>。这将锁定在你所指定的精确的开发版本。</em></p>\n\n<!-- The same process may be used to install a published development version of a grunt plugin. -->\n\n\n<p>同样的过程可以用于安装 Grunt 插件发布的开发版本。</p>\n\n<!-- ## Installing directly from github -->\n\n\n<h2>直接从 github 安装</h2>\n\n<!-- If you want to install a bleeding-edge, unpublished version of grunt or grunt plugin, follow the instructions for specifying a [git URL as a dependency](https://npmjs.org/doc/json.html#Git-URLs-as-Dependencies) and be sure to specify an actual commit SHA (not a branch name) as the `commit-ish`. This will guarantee that your project always uses that exact version of grunt. -->\n\n\n<p>如果想安装 Grunt 或 Grunt 插件的最新但是未发布的版本，按照<a href=\"https://npmjs.org/doc/json.html#Git-URLs-as-Dependencies\">指定 git 地址作为依赖</a>的说明进行踩哦啊做，确保指定一个实际提交的 SHA（不是分支名）作为 <code>commit-ish</code>。这将保证你的项目总是使用精确版本的 Grunt。</p>\n\n<!-- The specified git URL may be that of the official grunt repo or a fork. -->\n\n\n<p>指定的 git 地址可能是官方 grunt 库或一个分支。</p>\n"
            ],
            "link": [
              "http://nuysoft.github.com/2013/03/29/grunt-installing-grunt"
            ],
            "guid": [
              "http://nuysoft.github.com/2013/03/29/grunt-installing-grunt"
            ],
            "pubDate": [
              "2013-03-29T00:00:00-07:00"
            ]
          },
          {
            "title": [
              "Grunt 入门"
            ],
            "description": [
              "<blockquote><p>原文：<a href=\"https://github.com/gruntjs/grunt/wiki/Getting-started\">https://github.com/gruntjs/grunt/wiki/Getting-started</a></p></blockquote>\n\n<!-- Grunt and gruntplugins are installed and managed via [npm](https://npmjs.org/), the [Node.js](http://nodejs.org/) package manager. -->\n\n\n<p>Grunt 和它的插件通过 <a href=\"http://nodejs.org/\">Node.js</a> 的包管理器 <a href=\"https://npmjs.org/\">npm</a> 安装和管理。</p>\n\n<!-- _These instructions are written for Grunt 0.4.x, but are still valid for Grunt 0.3.x. Just note that for 0.3.x, plugin names and task configuration options may be different than those shown in \"The Gruntfile\" section._ -->\n\n\n<p><em>这些说明为 Grunt 0.4.x 而写，但是对于 Grunt 0.3.x 仍然有效。只需要注意 0.3.x 的插件名称和任务配置选项可能与“The Gruntfile”一节所述不同。</em></p>\n\n<!-- _Grunt 0.4.x requires Node.js version `>= 0.8.0`._ -->\n\n\n<p><em>Grunt 0.4x 要求 Node.js 的版本 <code>&gt;= 0.8.0</code>。</em></p>\n\n<!-- ## Installing the CLI -->\n\n\n<h2>安装 CLI</h2>\n\n<!-- **If you have installed Grunt globally in the past, you will need to remove it first:** -->\n\n\n<p><strong>如果已经全局安装了 Grunt，需要先删除它：</strong></p>\n\n<pre><code>npm uninstall -g grunt\n</code></pre>\n\n<!-- In order to get started, you'll want to install Grunt's command line interface (CLI) globally.  You may need to use sudo (for OSX, *nix, BSD etc) or run your command shell as Administrator (for Windows) to do this. -->\n\n\n<p>为了开始使用 Grunt，需要全局安装 Grunt 的命令行接口。你可能需要使用指令 sudo（OSX、*nix、BSD 等），或者以管理员身份运行命令解释程序来做到这一点。</p>\n\n<pre><code>npm install -g grunt-cli\n</code></pre>\n\n<!-- This will put the `grunt` command in your system path, allowing it to be run from any directory. -->\n\n\n<p>这将把 <code>grunt</code> 放入系统路径中，使得可以从任意目录运行它。</p>\n\n<!-- Note that installing `grunt-cli` does not install the grunt task runner!  The job of the grunt CLI is simple: run the version of grunt which has been installed next to a `Gruntfile`. This allows multiple versions of grunt to be installed on the same machine simultaneously. -->\n\n\n<p>注意：安装 <code>grunt-cli</code> 并不会安装 <code>grunt</code>！CLI 的工作很简单：运行已安装的与 <code>Gruntfile</code> 紧挨着的 grunt 版本。这样可以在一台机器上同时安装多个版本的 grunt。</p>\n\n<!-- ## How the CLI works -->\n\n\n<h2>CLI 是如何工作的</h2>\n\n<!-- Each time `grunt` is run, it looks for a locally installed grunt using node's `require()` system. Because of this, you can run `grunt` from any subfolder in your project. -->\n\n\n<p>每次 <code>grunt</code> 被运行时，它会使用 node 的 <code>require()</code> 系统寻找一个本地安装的 grunt。正因为如此，你可以在项目的任意子文件夹中运行 <code>grunt</code>。</p>\n\n<!-- If a locally installed Grunt is found, the CLI loads the local installation of the grunt library, applies the configuration from your `Gruntfile`, and executes any tasks you've requested for it to run. -->\n\n\n<p>如果找到了本地安装的 Grunt，CLI 会加载它，并且应用 <code>Gruntfile</code> 中的配置，然后执行所要求的所有任务。</p>\n\n<!-- *To really understand what is happening, [read the code](https://github.com/gruntjs/grunt-cli/blob/master/bin/grunt).  It's very short.* -->\n\n\n<p><em>要了解真正发生了什么，<a href=\"https://github.com/gruntjs/grunt-cli/blob/master/bin/grunt\">读读这段代码</a>，很短的。</em></p>\n\n<!-- ## Working with an existing grunt project -->\n\n\n<h2>用现有的 grunt 项目工作</h2>\n\n<!-- Assuming that the Grunt CLI has been installed and that the project has already been configured with a `package.json` and a `Gruntfile`, it's very easy to start working with Grunt: -->\n\n\n<p>假设 Grunt CLI 已经被安装，并且项目已经配置了 <code>package.json</code> 和 <code>Gruntfile</code>，那么很容易使用 Grunt 开始工作：</p>\n\n<!-- 1. Change to the project's root directory.\n1. Install project dependencies with `npm install`.\n1. Run Grunt with `grunt`. -->\n\n\n\n\n<ol>\n<li>切换到项目的根目录。</li>\n<li>使用 `npm install` 安装项目的依赖库。</li>\n<li>使用 `grunt` 运行 Grunt。</li>\n</ol>\n\n\n\n\n<!-- That's really all there is to it. Installed Grunt tasks can be listed by running `grunt --help` but it's usually a good idea to start with the project's documentation. -->\n\n\n<p>这就是所要做的所有工作。安装的 Grunt 任务可以通过运行 <code>grunt --help</code> 罗列出来，通常这也是一个好主意：从项目的文档开始。</p>\n\n<!-- ## Preparing a new grunt project -->\n\n\n<h2>准备一个新的 grunt 项目</h2>\n\n<!-- A typical setup will involve adding two files to your project: `package.json` and the `Gruntfile`. -->\n\n\n<p>一次典型的安装会涉及添加两个文件到你的项目中：<code>package.json</code> 和 <code>Gruntfile</code>。</p>\n\n<!-- **package.json**: This file is used by [npm] to store metadata for projects published as npm modules.  You will list grunt and the Grunt plugins your project needs as [devDependencies] in this file. -->\n\n\n<p><strong>package.json</strong>：该文件被 <a href=\"https://npmjs.org/\">npm</a> 用来存储被发布为 npm 模块的项目的元数据。你将在该文件的 <a href=\"https://npmjs.org/doc/json.html#devDependencies\">devDependencies</a> 中列出项目所依赖的 grunt 和插件。</p>\n\n<blockquote><p>该文件用来存储 npm 模块的元数据，通过 <a href=\"https://npmjs.org/doc/json.html#devDependencies\">devDependencies</a> 列出项目依赖的 grunt 和插件。</p></blockquote>\n\n<!-- **Gruntfile**: This file is named `Gruntfile.js` or `Gruntfile.coffee` and is used to configure or define tasks and load Grunt plugins.  -->\n\n\n<p><strong>Gruntfile</strong>：该文件被命名为 <code>Gruntfile.js</code> 或 <code>Gruntfile.coffee</code>，被用于配置或定义任务、加载 Grunt 插件。</p>\n\n<!-- _This file was named `grunt.js` for 0.3.x versions of Grunt._ -->\n\n\n<p><em>在 Grunt 0.3.x 版本中，该文件被命名为 <code>grunt.js</code>。</em></p>\n\n<h2>package.json</h2>\n\n<!-- The `package.json` file belongs in the root directory of your project, next to the `Gruntfile`, and should be committed with your project source.  Running `npm install` in the same folder as a `package.json` file will install the correct version of each dependency listed therein. -->\n\n\n<p>文件 <code>package.json</code> 为了项目的根目录，紧挨着 <code>Gruntfile</code>，并且应该随项目源码一起提交。在文件 <code>package.json</code> 的同级目录下运行 <code>npm install</code> 将安装其中列出的每个依赖模块。</p>\n\n<!-- There are a few ways to create a `package.json` file for your project: -->\n\n\n<p>有几种方式为你的项目创建一个 <code>package.json</code> 文件：</p>\n\n<!-- * Most [grunt-init] templates will automatically create a project-specific `package.json` file.\n* The [npm init] command will create a basic `package.json` file.\n* Start with the example below, and expand as needed, following this [specification][json]. -->\n\n\n<ul>\n<li>大部分 <a href=\"Project-Scaffolding\">grunt-init</a> 模板会自动创建一个项目特定的 <code>package.json</code> 文件。</li>\n<li><a href=\"https://npmjs.org/doc/init.html\">npm init</a> 命令会创建一个基本的 <code>package.json</code> 文件。</li>\n<li>从下面的例子开始，需要时扩展，遵循这个<a href=\"https://npmjs.org/doc/json.html\">规范</a>。</li>\n</ul>\n\n\n<p></p>\n\n\n<pre><code>{\n  \"name\": \"my-project-name\",\n  \"version\": \"0.1.0\",\n  \"devDependencies\": {\n    \"grunt\": \"~0.4.1\",\n    \"grunt-contrib-jshint\": \"~0.1.1\",\n    \"grunt-contrib-nodeunit\": \"~0.1.2\"\n  }\n}\n</code></pre>\n\n<!-- ### Installing Grunt and gruntplugins -->\n\n\n<h3>安装 Grunt 和 插件</h3>\n\n<!-- The easiest way to add Grunt and gruntplugins to an existing `package.json` is with the command `npm install <module> --save-dev`.  Not only will this install `<module>` locally, but it will automatically be added to the [devDependencies] section, using a [tilde version range]. -->\n\n\n<p>向一个已存在的 <code>package.json</code> 添加 Grunt 和插件的最简单的方式是使用命令 <code>npm install &lt;module&gt; --save-dev</code>。不仅会本地安装 <code>&lt;module&gt;</code>，还会被自动添加到 <a href=\"https://npmjs.org/doc/json.html#devDependencies\">devDependencies</a>，使用<a href=\"https://npmjs.org/doc/json.html#Tilde-Version-Ranges\">波浪号版本范围</a>。</p>\n\n<!-- For example, this will install the latest version of Grunt in your project folder, adding it to your devDependencies: -->\n\n\n<p>下面的例子将安装最新版本的 Grunt 到你的项目文件夹中，并且添加到你的 devDependencies：</p>\n\n<pre><code>npm install grunt --save-dev\n</code></pre>\n\n<!-- The same can be done for gruntplugins and other node modules. Be sure to commit the updated `package.json` file with your project when you're done! -->\n\n\n<p>Grunt 插件和其他 node 模块同样可以这么做。当你完成后，请务必提供更新后的 <code>package.json</code>。</p>\n\n<!-- ## The Gruntfile -->\n\n\n<h2>Gruntfile</h2>\n\n<!-- The `Gruntfile.js` or `Gruntfile.coffee` file is a valid JavaScript or CoffeeScript file that belongs in the root directory of your project, next to the `package.json` file, and should be committed with your project source. _This file was named `grunt.js` for 0.3.x versions of Grunt._ -->\n\n\n<p>文件 <code>Gruntfile.js</code> 或 <code>Gruntfile.coffee</code> 是一个有效的 JavaScript 或 CoffeeScript 文件，位于项目的更目录中，紧挨着文件 <code>package.json</code>，并且应该随你的项目源码一起提交。<em>该文件在 Grunt 0.3.x 版本中被命名为 <code>grunt.js</code>。</em></p>\n\n<!-- A Gruntfile is comprised of the following parts: -->\n\n\n<p>一个 Gruntfile 文件由以下几部分组成：</p>\n\n<!-- * The \"wrapper\" function\n* Project and task configuration\n* Loading grunt plugins and tasks\n* Custom tasks -->\n\n\n\n\n<ul>\n<li>包裹函数</li>\n<li>项目和任务配置</li>\n<li>加载 grunt 插件和任务</li>\n<li>自定义任务</li>\n</ul>\n\n\n\n\n<!-- ### An example Gruntfile -->\n\n\n<h3>Gruntfile 示例</h3>\n\n<!-- In the following Gruntfile, project metadata is imported into the grunt config from the project's `package.json` file and the [grunt-contrib-uglify] plugin's `uglify` task is configured to minify a source file and generate a banner comment dynamically using that metadata. When grunt is run on the command line, the `uglify` task will be run by default. -->\n\n\n<p>在下面的 Gruntfile 文件中，项目元数据被从项目的 <code>package.json</code> 文件导入到 grunt 配置，并且插件 <a href=\"http://github.com/gruntjs/grunt-contrib-uglify\">grunt-contrib-uglify</a> 的任务 <code>uglify</code> 被配置为压缩一个源文件，并且使用元数据动态生成一个标题注释。当通过命令行运行 gurnt 时，任务 <code>uglify</code> 默认被运行。</p>\n\n<pre><code>module.exports = function(grunt) {\n  // Project configuration.\n  grunt.initConfig({\n    pkg: grunt.file.readJSON('package.json'),\n    uglify: {\n      options: {\n        banner: '/*! &lt;%= pkg.name %&gt; &lt;%= grunt.template.today(\"yyyy-mm-dd\") %&gt; */\\n'\n      },\n      build: {\n        src: 'src/&lt;%= pkg.name %&gt;.js',\n        dest: 'build/&lt;%= pkg.name %&gt;.min.js'\n      }\n    }\n  });\n  // Load the plugin that provides the \"uglify\" task.\n  grunt.loadNpmTasks('grunt-contrib-uglify');\n  // Default task(s).\n  grunt.registerTask('default', ['uglify']);\n};\n</code></pre>\n\n<!-- Now that you've seen the whole Gruntfile, let's look at its component parts. -->\n\n\n<p>现在你已经看到了完整的 Gruntfile，让我们看看它的组成部分。</p>\n\n<!-- ### The \"wrapper\" function -->\n\n\n<h3>包裹函数</h3>\n\n<!-- Every Gruntfile (and gruntplugin) uses this basic format, and all of your Grunt code must be specified inside this function: -->\n\n\n<p>每个 Gruntfile（和 Grunt 插件）使用这个基本格式，所有的 Grunt 代码必须被指定在这个函数内：</p>\n\n<pre><code>module.exports = function(grunt) {\n  // Do grunt-related things in here\n};\n</code></pre>\n\n<!-- ### Project and task configuration -->\n\n\n<h3>项目和任务配置</h3>\n\n<!-- Most Grunt tasks rely on configuration data defined in an object passed to the [[grunt.initConfig|grunt#grunt.initconfig]] method. -->\n\n\n<p>大部分 Grunt 任务依赖于传给方法 <a href=\"https://github.com/gruntjs/grunt/wiki/grunt#grunt.initconfig\">grunt.initConfig</a> 的配置对象。</p>\n\n<!-- In this example, `grunt.file.readJSON('package.json')` imports the JSON metadata stored in `package.json` into the grunt config. Because `<% %>` template strings may reference any config properties, configuration data like filepaths and file lists may be specified this way to reduce repetition. -->\n\n\n<p>在这个例子中，<code>grunt.file.readJSON('package.json')</code> 将存储在 <code>package.json</code> 中的 JSON 元数据导入到 grunt 配置中。因为模板字符串 <code>&lt;% %&gt;</code> 可以引用任何配置属性，像文件路径和文件列表这样的配置数据可以通过这种方式指定，以减少重复。</p>\n\n<!-- You may store any arbitrary data inside of the configuration object, and as long as it doesn't conflict with properties your tasks require, it will be otherwise ignored. Also, because this is JavaScript, you're not limited to JSON; you may use any valid JS here. You can even programmatically generate the configuration if necessary. -->\n\n\n<p>你可以在配置对象中存储任意数据，只要它不与你的任务需要的属性发生冲突，否则将被忽略。另外，因为是 JavaScript，所以不局限于 JSON；你可以在这里使用任何有效的 JS。有必要的话，你甚至可以用编程的方式生成配置对象。</p>\n\n<!-- Like most tasks, the [grunt-contrib-uglify] plugin's `uglify` task expects its configuration to be specified in a property of the same name. Here, the `banner` option is specified, along with a single uglify target named `build` that minifies a single source file to a single destination file. -->\n\n\n<p>像大部分任务一样，插件 <a href=\"http://github.com/gruntjs/grunt-contrib-uglify\">grunt-contrib-uglify</a> 的任务 <code>uglify</code> 需要它的配置被指定到一个同名属性。在这里，选项 <code>banner</code> 被指定，命名为 <code>build</code> 的一个 uglify 目标被一同指定，用于压缩一个源文件到一个目标文件。</p>\n\n<pre><code>// Project configuration.\ngrunt.initConfig({\n  pkg: grunt.file.readJSON('package.json'),\n  uglify: {\n    options: {\n      banner: '/*! &lt;%= pkg.name %&gt; &lt;%= grunt.template.today(\"yyyy-mm-dd\") %&gt; */\\n'\n    },\n    build: {\n      src: 'src/&lt;%= pkg.name %&gt;.js',\n      dest: 'build/&lt;%= pkg.name %&gt;.min.js'\n    }\n  }\n});\n</code></pre>\n\n<!-- ### Loading grunt plugins and tasks -->\n\n\n<h3>加载 grunt 插件和任务</h3>\n\n<!-- Many commonly used tasks like [concatenation], [minification][grunt-contrib-uglify] and [linting] are available as [grunt plugins](https://github.com/gruntjs). As long as a plugin is specified in `package.json` as a dependency, and has been installed via `npm install`, it may be enabled inside your `Gruntfile` with a simple command: -->\n\n\n<p>常用的任务，例如 <a href=\"https://github.com/gruntjs/grunt-contrib-concat\">concatenation</a>、<a href=\"http://github.com/gruntjs/grunt-contrib-uglify\">minification</a> 和 <a href=\"https://github.com/gruntjs/grunt-contrib-jshint\">linting</a> 都是有效的 <a href=\"https://github.com/gruntjs\">grunt 插件</a>。只要一个\n插件在 <code>package.json</code> 中作为依赖库被指定，并且已经通过 <code>npm install</code> 安装，就可以在你的 <code>Gruntfile</code> 中使用一个简单的命令启用它：</p>\n\n<pre><code>// Load the plugin that provides the \"uglify\" task.\ngrunt.loadNpmTasks('grunt-contrib-uglify');\n</code></pre>\n\n<!-- **Note:** the `grunt --help` command will list all available tasks. -->\n\n\n<p><strong>注意：</strong> 命令 <code>grunt --help</code> 将列出所有有效任务。</p>\n\n<!-- ### Custom tasks -->\n\n\n<h3>自定义任务</h3>\n\n<!-- You can configure Grunt to run one or more tasks by default by defining a `default` task. In the following example, running `grunt` at the command line without specifying a task will run the `uglify` task. This is functionally the same as explicitly running `grunt uglify` or even `grunt default`. Any number of tasks (with or without arguments) may be specified in the array. -->\n\n\n<p>默认情况下，你可以定义一个 <code>default</code> 任务来运行一个或多个任务。在下面的例子中，在命令行中运行 <code>grunt</code> 而不指定一个任务，将运行任务 <code>uglify</code>。等价于明确的运行 <code>grunt uglify</code>，甚至等价于 <code>grunt default</code>。可以在数组中指定任务数量的任务（可以带有或不带参数）。</p>\n\n<pre><code>// Default task(s).\ngrunt.registerTask('default', ['uglify']);\n</code></pre>\n\n<!-- If your project requires tasks not provided by a Grunt plugin, you may define custom tasks right inside the `Gruntfile`. For example, this Gruntfile defines a completely custom `default` task that doesn't even utilize task configuration: -->\n\n\n<p>如果 Grunt 插件不能提供项目所需的任务，你可以在 <code>Gruntfile</code> 中定义自定义任务。例如，下面的 Gruntfile 定义了一个完全自定义的任务 <code>default</code>，甚至没有使用任务配置：</p>\n\n<pre><code>module.exports = function(grunt) {\n\n  // A very basic default task.\n  grunt.registerTask('default', 'Log some stuff.', function() {\n    grunt.log.write('Logging some stuff...').ok();\n  });\n\n};\n</code></pre>\n\n<!-- Custom project-specific tasks don't need to be defined in the Gruntfile; they may be defined in external `.js` files and loaded via the [[gruntgrunt.loadTasks|grunt#grunt.loadtasks]] method. -->\n\n\n<p>自定义的项目特定任务不需要被定义在 Gruntfile 中；它们可以被定义在外部的 <code>.js</code> 文件中，然后通过方法 <a href=\"http://gruntjs.com/grunt#grunt.loadtasks\">gruntgrunt.loadTasks</a> 加载。</p>\n\n<!-- ## Further Reading -->\n\n\n<h2>延伸阅读</h2>\n\n<!-- * The [[Installing grunt]] guide has detailed information about installing specific, production or in-development, versions of Grunt and grunt-cli.\n* The [[Configuring Tasks]] guide has an in-depth explanation on how to configure tasks, targets, options and files inside the Gruntfile, along with an explanation of templates, globbing patterns and importing external data.\n* The [[Creating Tasks]] guide lists the differences between the types of Grunt tasks and shows a number of sample tasks and configurations.\n* For more information about writing custom tasks or Grunt plugins, check out the [[developer documentation|grunt]]. -->\n\n\n<ul>\n<li><a href=\"http://gruntjs.com/installing-grunt/\">安装 Grunt</a> 指南详细描述了安装、生产、开发、Grunt 版本、grunt-cli 版本的信息。</li>\n<li><a href=\"http://gruntjs.com/configuring-tasks/\">配置任务</a>指南深入说明了如何在 Gruntfile 中配置任务、目标、选项和文件，还解释了模板、通配符以及导入外部数据。</li>\n<li><a href=\"http://gruntjs.com/creating-tasks/\">创建任务</a>指南列出了 Grunt 任务之间的差异，并暂时了一些示例任务和配置。</li>\n<li>关于编写自定义任务或 Grunt 插件的更多信息，请查看<a href=\"http://gruntjs.com/grunt\">开发人员文档</a>。</li>\n</ul>\n\n\n<h2>译者后记</h2>\n\n<ol>\n<li>[[]] 的链接是如何生成的？</li>\n<li>通过在 md 文件的最后统一定义链接配置，以减少重复。</li>\n<li>只用 [] 可以生成锚文。</li>\n<li>grunt 采用了什么版本的 md 转换工具？</li>\n</ol>\n\n\n\n"
            ],
            "link": [
              "http://nuysoft.github.com/2013/03/29/grunt-getting-started"
            ],
            "guid": [
              "http://nuysoft.github.com/2013/03/29/grunt-getting-started"
            ],
            "pubDate": [
              "2013-03-29T00:00:00-07:00"
            ]
          },
          {
            "title": [
              "创建任务"
            ],
            "description": [
              "<blockquote><p>原文：<a href=\"https://github.com/gruntjs/grunt/wiki/Creating-tasks\">https://github.com/gruntjs/grunt/wiki/Creating-tasks</a></p></blockquote>\n\n<!-- Tasks are grunt's bread and butter. The stuff you do most often, like `jshint` or `nodeunit`. Every time Grunt is run, you specify one or more tasks to run, which tells Grunt what you'd like it to do. -->\n\n\n<p>任务是 Grunt 的面包和奶油。是你最常用的，例如 <code>jshint</code> 或 <code>nodeunit</code>。每次运行 Grunt 时，你可以指定一个或多个任务来运行，任务告诉了 Grunt 你想要它做的事情。</p>\n\n<blockquote><p>译注：bread and butter 基本生活资料，生计</p></blockquote>\n\n<!-- If you don't specify a task, but a task named \"default\" has been defined, that task will run (unsurprisingly) by default. -->\n\n\n<p>如果没有指定一个任务，但是已经定义了一个命名为“default”的任务，该任务将默认运行。</p>\n\n<!-- ## Alias Tasks -->\n\n\n<h2>别名任务</h2>\n\n<!-- If a task list is specified, the new task will be an alias for one or more other tasks. Whenever this \"alias task\" is run, every specified tasks in `taskList` will be run, in the order specified. The `taskList` argument must be an array of tasks. -->\n\n\n<p>如果指定了一个任务列表，新的任务将是其他一个或多个任务的别名。每当运行这个“别名任务”，在 <code>taskList</code> 中指定的每个任务将被执行，并按照指定的属性。参数 <code>taskList</code> 必须是一个任务数组。</p>\n\n<pre><code>grunt.registerTask(taskName, [description, ] taskList)\n</code></pre>\n\n<!-- This example alias task defines a \"default\" task whereby the \"jshint\", \"qunit\", \"concat\" and \"uglify\" tasks are run automatically if Grunt is executed without specifying any tasks: -->\n\n\n<p>示例的别名任务定义了一个“default”任务，如果执行 Grunt 时没有指定任何任务，其中的“jshint”、“qunit”、“concat”和“uglify”任务被自动运行。</p>\n\n<pre><code>grunt.registerTask('default', ['jshint', 'qunit', 'concat', 'uglify']);\n</code></pre>\n\n<!-- Task arguments can be specified as well. In this example, the alias \"dist\" runs both the \"concat\" and \"min\" tasks, each with a \"dist\" argument: -->\n\n\n<p>也可以为任务指定参数。在这个例子中，别名任务“dist”同时运行任务”concat“和”min“，并且各自带一个参数“dist”。</p>\n\n<pre><code>grunt.registerTask('dist', ['concat:dist', 'uglify:dist']);\n</code></pre>\n\n<!-- ## Multi Tasks -->\n\n\n<h2>多任务</h2>\n\n<!-- When a multi task is run, Grunt looks for a property of the same name in the Grunt configuration. Multi-tasks can have multiple configurations, defined using arbitrarily named \"targets.\" -->\n\n\n<p>当运行一个多任务时，Grunt 在配置中查找同名的属性。多任务可以有多个配置，通过任意命名的“targets”。</p>\n\n<blockquote><p>译注：Multi Tasks 理解为可以含有多个 Target 的 Task。</p></blockquote>\n\n<!-- Specifying both a task and target like `grunt concat:foo` or `grunt concat:bar` will process just the specified target's configuration, while running `grunt concat` will iterate over _all_ targets, processing each in turn.  Note that if a task has been renamed with [grunt.renameTask](https://github.com/gruntjs/grunt/wiki/grunt#wiki-grunt-renameTask), Grunt will look for a property with the _new_ task name in the config object. -->\n\n\n<p>同时指定一个任务和目标将只处理指定目标的配置，例如 <code>grunt concat:foo</code> 或 <code>grunt concat:bar</code>，而运行 <code>grunt concat</code> 将遍历<em>所有</em>目标，顺序处理每个目标。请注意，如果一个任务已经通过 <a href=\"https://github.com/gruntjs/grunt/wiki/grunt#wiki-grunt-renameTask\">grunt.renameTask</a> 重命名，Grunt 将在配置对象查找<em>新</em>任务名对应的属性。</p>\n\n<!-- Most of the contrib tasks, including the [grunt-contrib-jshint plugin jshint task](https://github.com/gruntjs/grunt-contrib-jshint), [concat task](https://github.com/gruntjs/grunt-contrib-concat) and [grunt-contrib-concat plugin concat task](https://github.com/gruntjs/grunt-contrib-concat) are multi tasks. -->\n\n\n<p>大部分扩展任务是多任务的，包括 <a href=\"https://github.com/gruntjs/grunt-contrib-jshint\">grunt-contrib-jshint plugin jshint task</a>、<a href=\"https://github.com/gruntjs/grunt-contrib-concat\">concat task</a> 和 <a href=\"https://github.com/gruntjs/grunt-contrib-concat\">grunt-contrib-concat plugin concat task</a>。</p>\n\n<pre><code>grunt.registerMultiTask(taskName, [description, ] taskFunction)\n</code></pre>\n\n<!-- Given the specified configuration, this example multi task would log `foo: 1,2,3` if Grunt was run via `grunt log:foo`, or it would log `bar: hello world` if Grunt was run via `grunt log:bar`. If Grunt was run as `grunt log` however, it would log `foo: 1,2,3` then `bar: hello world` then `baz: false`. -->\n\n\n<p>下面的多任务示例被指定了配置，如果运行 <code>grunt log:foo</code> 将打印 <code>foo: 1,2,3</code>，或者如果运行 <code>gurnt log:bar</code> 将打印 <code>bar: hello world</code>。但是如果运行 <code>grunt log</code> 将顺序打印 <code>foo: 1,2,3</code>、<code>bar: hello world</code>、<code>baz: false</code>。</p>\n\n<pre><code>grunt.initConfig({\n  log: {\n    foo: [1, 2, 3],\n    bar: 'hello world',\n    baz: false\n  }\n});\n//\ngrunt.registerMultiTask('log', 'Log stuff.', function() {\n  grunt.log.writeln(this.target + ': ' + this.data);\n});\n</code></pre>\n\n<!-- ## \"Basic\" Tasks -->\n\n\n<h2>“基本”任务</h2>\n\n<!-- When a basic task is run, Grunt doesn't look at the configuration or environment—it just runs the specified task function, passing any specified colon-separated arguments in as function arguments. -->\n\n\n<p>当一项基本任务运行时，Grunt 仅仅是运行指定的任务函数，不会查找配置或环境，传入任意冒号分割的参数作为函数参数。</p>\n\n<pre><code>grunt.registerTask(taskName, [description, ] taskFunction)\n</code></pre>\n\n<!-- This example task logs `foo, testing 123` if Grunt is run via `grunt foo:testing:123`. If the task is run without arguments as `grunt foo` the task logs `foo, no args`. -->\n\n\n<p>在这个例子中，如果运行 <code>grunt foo:testing:123</code> 将打印 <code>foo, testing 123</code>。如果不带参数运行 <code>grunt foo</code> 将打印 <code>foo, no args</code>。</p>\n\n<pre><code>grunt.registerTask('foo', 'A sample task that logs stuff.', function(arg1, arg2) {\n  if (arguments.length === 0) {\n    grunt.log.writeln(this.name + \", no args\");\n  } else {\n    grunt.log.writeln(this.name + \", \" + arg1 + \" \" + arg2);\n  }\n});\n</code></pre>\n\n<!-- ## Custom tasks -->\n\n\n<h2>自定义任务</h2>\n\n<!-- You can go crazy with tasks. If your tasks don't follow the \"multi task\" structure, use a custom task. -->\n\n\n<p>你可能会着迷于任务。如果你的任务不遵循“多任务”结构，使用一个自定义任务。</p>\n\n<pre><code>grunt.registerTask('default', 'My \"default\" task description.', function() {\n  grunt.log.writeln('Currently running the \"default\" task.');\n});\n</code></pre>\n\n<!-- Inside a task, you can run other tasks. -->\n\n\n<p>在一个任务中，你可以运行其他任务。</p>\n\n<pre><code>grunt.registerTask('foo', 'My \"foo\" task.', function() {\n  // Enqueue \"bar\" and \"baz\" tasks, to run after \"foo\" finishes, in-order.\n  grunt.task.run('bar', 'baz');\n  // Or:\n  grunt.task.run(['bar', 'baz']);\n});\n</code></pre>\n\n<!-- Tasks can be asynchronous. -->\n\n\n<p>任务可能是异步的。</p>\n\n<pre><code>grunt.registerTask('asyncfoo', 'My \"asyncfoo\" task.', function() {\n  // Force task into async mode and grab a handle to the \"done\" function.\n  var done = this.async();\n  // Run some sync stuff.\n  grunt.log.writeln('Processing task...');\n  // And some async stuff.\n  setTimeout(function() {\n    grunt.log.writeln('All done!');\n    done();\n  }, 1000);\n});\n</code></pre>\n\n<!-- Tasks can access their own name and arguments. -->\n\n\n<p>任务可以访问它们自己的名称和参数。</p>\n\n<pre><code>grunt.registerTask('foo', 'My \"foo\" task.', function(a, b) {\n  grunt.log.writeln(this.name, a, b);\n});\n\n// Usage:\n// grunt foo foo:bar\n//   logs: \"foo\", undefined, undefined\n//   logs: \"foo\", \"bar\", undefined\n// grunt foo:bar:baz\n//   logs: \"foo\", \"bar\", \"baz\"\n</code></pre>\n\n<!-- Tasks can fail if any errors were logged. -->\n\n\n<p>如果打印了任何错误，任务可能会失败。</p>\n\n<pre><code>grunt.registerTask('foo', 'My \"foo\" task.', function() {\n  if (failureOfSomeKind) {\n    grunt.log.error('This is an error message.');\n  }\n  //\n  // Fail by returning false if this task had errors\n  if (ifErrors) { return false; }\n  //\n  grunt.log.writeln('This is the success message');\n});\n</code></pre>\n\n<!-- When tasks fail, all subsequent tasks will be aborted unless `--force` was specified. -->\n\n\n<p>当任务失败时，所有后续任务将被终止，除非指定了 <code>--force</code>。</p>\n\n<pre><code>grunt.registerTask('foo', 'My \"foo\" task.', function() {\n  // Fail synchronously.\n  return false;\n});\n// \ngrunt.registerTask('bar', 'My \"bar\" task.', function() {\n  var done = this.async();\n  setTimeout(function() {\n    // Fail asynchronously.\n    done(false);\n  }, 1000);\n});\n</code></pre>\n\n<!-- Tasks can be dependent on the successful execution of other tasks. Note that `grunt.task.requires` won't actually RUN the other task(s). It'll just check to see that it has run and not failed. -->\n\n\n<p>任务可以依赖于其他任务的成功执行。需要注意的是，<code>grunt.task.requires</code> 实际上不会执行其他任务。它会仅仅检查其他任务是否已运行，并且没有失败。</p>\n\n<pre><code>grunt.registerTask('foo', 'My \"foo\" task.', function() {\n  return false;\n});\n\ngrunt.registerTask('bar', 'My \"bar\" task.', function() {\n  // Fail task if \"foo\" task failed or never ran.\n  grunt.task.requires('foo');\n  // This code executes if the \"foo\" task ran successfully.\n  grunt.log.writeln('Hello, world.');\n});\n\n// Usage:\n// grunt foo bar\n//   doesn't log, because foo failed.\n// grunt bar\n//   doesn't log, because foo never ran.\n</code></pre>\n\n<!-- Tasks can fail if required configuration properties don't exist. -->\n\n\n<p>如果需要的配置属性不存在，任务可能失败。</p>\n\n<pre><code>grunt.registerTask('foo', 'My \"foo\" task.', function() {\n  // Fail task if \"meta.name\" config prop is missing.\n  grunt.config.requires('meta.name');\n  // Also fails if \"meta.name\" config prop is missing.\n  grunt.config.requires(['meta', 'name']);\n  // Log... conditionally.\n  grunt.log.writeln('This will only log if meta.name is defined in the config.');\n});\n</code></pre>\n\n<!-- Tasks can access configuration properties. -->\n\n\n<p>任务可以访问配置属性。</p>\n\n<pre><code>grunt.registerTask('foo', 'My \"foo\" task.', function() {\n  // Log the property value. Returns null if the property is undefined.\n  grunt.log.writeln('The meta.name property is: ' + grunt.config('meta.name'));\n  // Also logs the property value. Returns null if the property is undefined.\n  grunt.log.writeln('The meta.name property is: ' + grunt.config(['meta', 'name']));\n});\n</code></pre>\n\n<!-- Take a look at the [contrib tasks](https://github.com/gruntjs/) for more examples. -->\n\n\n<p>更多例子请查看<a href=\"https://github.com/gruntjs/\">官方扩展任务</a>。</p>\n\n<!-- ## CLI options / environment -->\n\n\n<h2>CLI 选项/环境</h2>\n\n<p><em>TODO</em>\n(pull from FAQ, recommend process.env)</p>\n\n<!-- ## Why doesn't my asynchronous task complete? -->\n\n\n<h2>为什么我的异步任务不完成？</h2>\n\n<!-- Chances are this is happening because you have forgotten to call the [this.async](grunt.task#wiki-this-async) method to tell Grunt that your task is asynchronous. For simplicity's sake, Grunt uses a synchronous coding style, which can be switched to asynchronous by calling `this.async()` within the task body. -->\n\n\n<p>可能会发生这种情况，因为你忘记了调用方法 <a href=\"http://gruntjs.com/grunt.task#wiki-this-async\">this.async</a> 来告诉 Grunt 你的任务是异步的。为了简单起见，Grunt 使用一种同步编码风格，通过在任务体中调用 <code>this.async</code> 切换到异步。</p>\n\n<!-- Note that passing `false` to the `done()` function tells Grunt that the task has failed. -->\n\n\n<p>需要注意的是，通过为函数 <code>done()</code> 传入 <code>false</code> 来告诉 Grunt 任意已经失败。</p>\n\n<!-- For example: -->\n\n\n<p>例如：</p>\n\n<pre><code>grunt.registerTask('asyncme', 'My asynchronous task.', function() {\n  var done = this.async();\n  doSomethingAsync(done);\n});\n</code></pre>\n"
            ],
            "link": [
              "http://nuysoft.github.com/2013/03/29/grunt-creating-tasks"
            ],
            "guid": [
              "http://nuysoft.github.com/2013/03/29/grunt-creating-tasks"
            ],
            "pubDate": [
              "2013-03-29T00:00:00-07:00"
            ]
          },
          {
            "title": [
              "创建插件"
            ],
            "description": [
              "<blockquote><p>原文：<a href=\"https://github.com/gruntjs/grunt/wiki/Configuring-tasks\">https://github.com/gruntjs/grunt/wiki/Configuring-tasks</a></p></blockquote>\n\n<h2>创建插件</h2>\n\n<!-- 1. Install [grunt-init](https://github.com/gruntjs/grunt-init) with `npm install -g grunt-init`\n2. Install the gruntplugin template with `git clone git://github.com/gruntjs/grunt-init-gruntplugin.git ~/.grunt-init/gruntplugin`\n3. Run `grunt-init gruntplugin` in an empty directory.\n4. Run `npm install` to prepare the development environment.\n5. Author your plugin.\n6. Run `npm publish` to publish the grunt plugin to npm! -->\n\n\n\n\n<ol>\n<li>运行 `npm install -g grunt-init` 安装 [grunt-init](https://github.com/gruntjs/grunt-init)</li>\n<li>运行 `git clone git://github.com/gruntjs/grunt-init-gruntplugin.git ~/.grunt-init/gruntplugin` 安装 Grunt 插件模板</li>\n<li>在一个空目录中运行 `grunt-init gruntplugin`。</li>\n<li>运行 `npm install` 准备开发环境。</li>\n<li>编写你的插件。</li>\n<li>运行 `npm publish` 发布 Grunt 插件到 npm！</li>\n</ol>\n\n\n\n\n<!-- ## Notes -->\n\n\n<h2>注意</h2>\n\n<!-- ### Naming your task -->\n\n\n<h3>命名你的任务</h3>\n\n<!-- The \"grunt-contrib\" namespace is reserved for tasks maintained by the grunt team, please name your task something appropriate that avoids that naming scheme. -->\n\n\n<p>命名空间“grunt-contrib”是保留给 Grunt 团队维护的任务，请适当的命名你的任务，避免该命名方案。</p>\n\n<!-- ### Debugging -->\n\n\n<h3>调试</h3>\n\n<!-- Grunt hides error stack traces by default, but they can be enabled for easier task debugging with the `--stack` option. If you want grunt to always log stack traces on errors, create an alias in your shell. Eg, in bash, you could do `alias grunt='grunt --stack'`. -->\n\n\n<p>Grunt 默认隐藏堆栈跟踪信息，为了更容易调试任务，可以启用选项 <code>--stack</code>。如果你希望 Grunt 在发生错误时总是打印堆栈跟踪信息，在你的 shell 中创建一个别名。例如，在 bash 中你可以运行 <code>alias grunt='grunt --stack'</code>。</p>\n\n<!-- ### Storing task files -->\n\n\n<h3>存储任务文件</h3>\n\n<!-- Only store data files in a .grunt/[npm-module-name]/ directory at the project's root and clean up after yourself when appropriate. This is not a solution for temporary scratch files, use one of the common npm modules (eg [temporary](https://npmjs.org/package/temporary), [tmp](https://npmjs.org/package/tmp)) that take advantage of the OS level temporary directories for that case. -->\n\n\n<p>只在项目根目录的路径 .grunt/[npm-module-name]/ 存储数据文件，并且在适当的时候清理掉。这并不是一个临时文件解决方案，在这种情况下，使用利用了操作系统级别的临时文件的 common npm 模块（例如 <a href=\"https://npmjs.org/package/temporary\">temporary</a>、<a href=\"https://npmjs.org/package/tmp\">tmp</a>）。</p>\n\n<!-- ### Avoid Changing the Current Working Directory: `process.cwd()` -->\n\n\n<h3>避免改变当前工作目录：<code>process.cwd()</code></h3>\n\n<!-- By default, the current working directory is set to be the directory that contains the gruntfile. The user can change it using `grunt.file.setBase()` in their gruntfile, but plugins should take care to not change it. -->\n\n\n<p>默认情况下，当前工作目录被设置为包含了 Gruntfile 的目录。用户可以在 Gruntfile 中使用 <code>grunt.file.setBase()</code> 改变当前工作目录，但是插件应当小心不要改变它。</p>\n\n<!-- `path.resolve('foo')` can be used to get the absolute path of the filepath 'foo' relative to the gruntfile. -->\n\n\n<p><code>path.resolve('foo')</code> 可以用于获取文件路径 'foo' 相对于 Gruntfile 的绝对路径。</p>\n"
            ],
            "link": [
              "http://nuysoft.github.com/2013/03/29/grunt-creating-plugins"
            ],
            "guid": [
              "http://nuysoft.github.com/2013/03/29/grunt-creating-plugins"
            ],
            "pubDate": [
              "2013-03-29T00:00:00-07:00"
            ]
          },
          {
            "title": [
              "配置任务"
            ],
            "description": [
              "<blockquote><p>原文：<a href=\"https://github.com/gruntjs/grunt/wiki/Configuring-tasks\">https://github.com/gruntjs/grunt/wiki/Configuring-tasks</a></p></blockquote>\n\n<!-- # Configuring Tasks -->\n\n\n\n\n<!-- This guide explains how to configure tasks for your project using a Gruntfile.  If you don't know what a Gruntfile is, please read the [[Getting Started]] guide and check out a [[Sample Gruntfile]]. -->\n\n\n<p>本指南介绍了如何在项目中使用文件 Gruntfile 配置任务。如果你不知道 Gruntfile 是什么，请阅读 <a href=\"http://gruntjs.com/getting-started/\">Grunt 入门</a>指南，并查看 <a href=\"http://gruntjs.com/sample-gruntfile/\">Gruntfile 示例</a>。</p>\n\n<!-- ## Grunt Configuration -->\n\n\n<h2>Grunt 配置</h2>\n\n<!-- Task configuration is specified in your Gruntfile via the `grunt.initConfig` method. This configuration will mostly be under task-named properties, but may contain any arbitrary data. As long as properties don't conflict with properties your tasks require, they will be otherwise ignored. -->\n\n\n<p>任务配置通过 Gruntfile 中的 <code>grunt.initConfig</code> 指定。配置通常挂在以任务命名的属性上，但是可以包含任意数据。只要这些属性与任务需要的属性不冲突，否则会被忽略。</p>\n\n<!-- Also, because this is JavaScript, you're not limited to JSON; you may use any valid JavaScript here. You may even programmatically generate the configuration if necessary. -->\n\n\n<p>另外，因为是在 javaScript 文件中，就不局限于 JSON；你可以使用任何有效的 JavaScript。如有必要，你设置可以以编程的方法生成配置。</p>\n\n<pre><code>grunt.initConfig({\n  concat: {\n    // concat task configuration goes here.\n  },\n  uglify: {\n    // uglify task configuration goes here.\n  },\n  // Arbitrary non-task-specific properties.\n  my_property: 'whatever',\n  my_src_files: ['foo/*.js', 'bar/*.js'],\n});\n</code></pre>\n\n<!-- ## Task Configuration and Targets -->\n\n\n<h2>任务配置和目标</h2>\n\n<blockquote><p>Task 和 Target 似乎没必要翻译</p></blockquote>\n\n<!-- When a task is run, Grunt looks for its configuration under a property of the same name. Multi-tasks can have multiple configurations, defined using arbitrarily named \"targets.\" In the example below, the `concat` task has `foo` and `bar` targets, while the `uglify` task only has a `bar` target. -->\n\n\n<p>当一个任务运行时，Grunt 在同名属性下查找该任务的配置。多个任务可以有多个配置，定义在任意命名的 \"targets\" 中。在下面的例子中，任务 <code>concat</code> 含有 <code>foo</code> 和 <code>bar</code> 两个目标，而任务 <code>uglify</code> 只有一个目标 <code>bar</code>。</p>\n\n<pre><code>grunt.initConfig({\n  concat: {\n    foo: {\n      // concat task \"foo\" target options and files go here.\n    },\n    bar: {\n      // concat task \"bar\" target options and files go here.\n    },\n  },\n  uglify: {\n    bar: {\n      // uglify task \"bar\" target options and files go here.\n    },\n  },\n});\n</code></pre>\n\n<!-- Specifying both a task and target like `grunt concat:foo` or `grunt concat:bar` will process just the specified target's configuration, while running `grunt concat` will iterate over _all_ targets, processing each in turn.  Note that if a task has been renamed with [grunt.renameTask](https://github.com/gruntjs/grunt/wiki/grunt#wiki-grunt-renameTask), Grunt will look for a property with the _new_ task name in the config object. -->\n\n\n<p>同时指定一个任务和目标，例如 <code>grunt concat:foo</code> 或 <code>grunt concat:bar</code> 将只处理指定目标的配置，而运行 <code>grunt concat</code> 则会遍历<em>所有</em>的目标，顺序处理。注意，如果一个任务已经通过 <a href=\"https://github.com/gruntjs/grunt/wiki/grunt#wiki-grunt-renameTask\">grunt.renameTask</a> 重命名，Grunt 将在配置对象中查找以<em>新</em>任务名命名的属性。</p>\n\n<!-- ## Options -->\n\n\n<h2>选项</h2>\n\n<!-- Inside a task configuration, an `options` property may be specified to override built-in defaults.  In addition, each target may have an `options` property which is specific to that target.  Target-level options will override task-level options. -->\n\n\n<p>在一个任务配置中，可以指定属性 <code>options</code> 来覆盖内置的默认子。此外，每个目标可以含有一个特定该目标的 <code>options</code> 属性。Target 级别的选项将覆盖任务界别的选项。</p>\n\n<!-- The `options` object is optional and may be omitted if not needed. -->\n\n\n<p>对象 <code>options</code> 时可选的，如果不需要的话还可以省略它。</p>\n\n<pre><code>grunt.initConfig({\n  concat: {\n    options: {\n      // Task-level options may go here, overriding task defaults.\n    },\n    foo: {\n      options: {\n        // \"foo\" target options may go here, overriding task-level options.\n      },\n    },\n    bar: {\n      // No options specified; this target will use task-level options.\n    },\n  },\n});\n</code></pre>\n\n<!-- ## Files -->\n\n\n<h2>文件集合</h2>\n\n<!-- Because most tasks perform file operations, Grunt has powerful abstractions for declaring on which files the task should operate. There are several ways to define **src-dest** (source-destination) file mappings, offering varying degrees of verbosity and control. Any multi task will understand all the following formats, so choose whichever format best meets your needs. -->\n\n\n<p>因为大部分任务执行的是文件操作，Grunt 拥有强大的抽象，用于声明任务应该操作哪些文件。有几种方式来定义 <strong>src-dest</strong> (源-目标) 文件映射，提供了不同程度的冗余和控制。任何任务都会明白以下所有格式，所以选择最能满足你的需求的格式。</p>\n\n<!-- All files formats support `src` and `dest` but the \"Compact\" and \"Files Array\" formats support a few additional properties: -->\n\n\n<p>所有文件都支持 <code>src</code> 和 <code>dest</code>，但是“紧凑型”和“文件数组”格式支持一些额外的属性：</p>\n\n<!-- * `filter` Either a valid [fs.Stats method name](http://nodejs.org/docs/latest/api/fs.html#fs_class_fs_stats) or a function that is passed the matched `src` filepath and returns `true` or `false`.\n* `nonull` When a match is not found, return a list containing the pattern itself. Otherwise, an empty list is returned if there are no matches. Combined with grunt's `--verbose` flag, this option can help debug file path issues.\n* `dot` Allow patterns to match filenames starting with a period, even if the pattern does not explicitly have a period in that spot.\n* `matchBase` If set, patterns without slashes will be matched against the basename of the path if it contains slashes. For example, a?b would match the path `/xyz/123/acb`, but not `/xyz/acb/123`.\n* `expand` Process a dynamic src-dest file mapping, see \"Building the files object dynamically\" for more information.\n* Other properties will be passed into the underlying libs as matching options. See the [node-glob][] and [minimatch][] documentation for more options. -->\n\n\n<ul>\n<li><code>filter</code> 可以是一个有效的 <a href=\"http://nodejs.org/docs/latest/api/fs.html#fs_class_fs_stats\">fs.Stats 方法名</a>，也可以是一个函数，接受匹配的文件路径 <code>src</code>，并返回 <code>true</code> 或 <code>false</code>。</li>\n<li><code>nonull</code> 当没有找到任何匹配文件时，返回含有通配符的列表。否则，如果没有任何匹配文件，则返回一个空列表。结合 Grunt <code>--verbose</code> 标记，该选项可以帮助调试文件路径问题。</li>\n<li><code>dot</code> 允许通配符匹配以一段字符开头的文件名，即使是通配符没有明确指定那段字符的位置。</li>\n<li><code>matchBase</code> 如果设置了属性，不含斜杠的模式将不配路径名，如果该路径还有斜杠。例如，模式 a?b 将匹配路径 <code>/xyz/123/acb</code>，但是不匹配 <code>/xyz/acb/123</code>。</li>\n<li><code>expand</code> 处理一个动态的源文件-目标文件的映射，更多信息请查看“动态构建文件集合对象”。</li>\n<li>其他属性会被作为匹配选项传递到底层库。更多选项查看文档 <a href=\"https://github.com/isaacs/node-glob\">node-glob</a> 和 <a href=\"https://github.com/isaacs/minimatch\">minimatch</a>。</li>\n</ul>\n\n\n<!-- ### Compact Format -->\n\n\n<h3>紧凑型格式</h3>\n\n<!-- This form allows a single **src-dest** (source-destination) file mapping per-target. It is most commonly used for read-only tasks, like [grunt-contrib-jshint](https://github.com/gruntjs/grunt-contrib-jshint), where a single `src` property is needed, and no `dest` key is relevant. This format also supports additional properties per src-dest file mapping. -->\n\n\n<p>该格式允许为每个目标设置一个单独的 <strong>src-dest</strong>（源-目标）文件映射。经常用于只读任务，例如 <a href=\"https://github.com/gruntjs/grunt-contrib-jshint\">grunt-contrib-jshint</a>，只需要一个单一的 <code>src</code> 属性，没有相关的 <code>dest</code> 属性。该格式还支持为每个 src-dest 文件映射附加额外属性。</p>\n\n<pre><code>grunt.initConfig({\n  jshint: {\n    foo: {\n      src: ['src/aa.js', 'src/aaa.js']\n    },\n  },\n  concat: {\n    bar: {\n      src: ['src/bb.js', 'src/bbb.js'],\n      dest: 'dest/b.js',\n    },\n  },\n});\n</code></pre>\n\n<!-- ### Files Object Format -->\n\n\n<h3>文件对象格式</h3>\n\n<!-- This form supports multiple src-dest mappings per-target, where the property name is the destination file, and its value is the source file(s). Any number of src-dest file mappings may be specified in this way, but additional properties may not be specified per mapping. -->\n\n\n<p>该格式支持为每个目标设置多个 src-dest 映射，此时属性名是目标文件，值是源文件。可以通过这种方法指定任意属性的 src-dest 文件映射，但是每对映射可以无法指定额外的属性。</p>\n\n<pre><code>grunt.initConfig({\n  concat: {\n    foo: {\n      files: {\n        'dest/a.js': ['src/aa.js', 'src/aaa.js'],\n        'dest/a1.js': ['src/aa1.js', 'src/aaa1.js'],\n      },\n    },\n    bar: {\n      files: {\n        'dest/b.js': ['src/bb.js', 'src/bbb.js'],\n        'dest/b1.js': ['src/bb1.js', 'src/bbb1.js'],\n      },\n    },\n  },\n});\n</code></pre>\n\n<!-- ### Files Array Format -->\n\n\n<h3>文件数组格式</h3>\n\n<!-- This form supports multiple src-dest file mappings per-target, while also allowing additional properties per mapping. -->\n\n\n<p>该格式支持为每个目标设置多个 src-dest 文件映射，也允许为每对映射指定额外的属性。</p>\n\n<pre><code>grunt.initConfig({\n  concat: {\n    foo: {\n      files: [\n        {src: ['src/aa.js', 'src/aaa.js'], dest: 'dest/a.js'},\n        {src: ['src/aa1.js', 'src/aaa1.js'], dest: 'dest/a1.js'},\n      ],\n    },\n    bar: {\n      files: [\n        {src: ['src/bb.js', 'src/bbb.js'], dest: 'dest/b/', nonull: true},\n        {src: ['src/bb1.js', 'src/bbb1.js'], dest: 'dest/b1/', filter: 'isFile'},\n      ],\n    },\n  },\n});\n</code></pre>\n\n<!-- ### Older Formats -->\n\n\n<h3>旧格式</h3>\n\n<!-- The **dest-as-target** file format is a holdover from before multi tasks and targets existed, where the destination filepath is actually the target name. Unfortunately, because target names are filepaths, running `grunt task:target` can be awkward. Also, you can't specify target-level options or additional properties per src-dest file mapping. -->\n\n\n<p>文件格式 <strong>dest-as-target</strong> 多任务和多目标存在之前的剩余物，即目标文件就是目标名。不幸的是，由于目标名是文件路径，运行 <code>grunt task:target</code> 可能是尴尬的。此外，你不能执行目标级别的选项，或者为每对 src-dest 文件映射指定额外的属性。</p>\n\n<!-- Consider this format deprecated, and avoid it where possible. -->\n\n\n<p>思考一下这种过时的格式，并在可能的情况下避免它。</p>\n\n<pre><code>grunt.initConfig({\n  concat: {\n    'dest/a.js': ['src/aa.js', 'src/aaa.js'],\n    'dest/b.js': ['src/bb.js', 'src/bbb.js'],\n  },\n});\n</code></pre>\n\n<!-- ### Custom Filter Function -->\n\n\n<h3>自定义过滤函数</h3>\n\n<!-- The `filter` property can help you target files with a greater level of detail. Simply use a valid [fs.Stats method name](http://nodejs.org/docs/latest/api/fs.html#fs_class_fs_stats). The following will clean only if the pattern matches an actual file: -->\n\n\n<p>属性 <code>filter</code> 可以帮助你定位文件，在更高的文件详细信息级别。只需使用一个有效的 <a href=\"http://nodejs.org/docs/latest/api/fs.html#fs_class_fs_stats\">fs.Stats 方法名</a>。下面的例子将在模式匹配实际文件时清理。</p>\n\n<pre><code>grunt.initConfig({\n  clean: {\n    foo: {\n      src: ['tmp/**/*'],\n      filter: 'isFile',\n    },\n  },\n});\n</code></pre>\n\n<!-- Or create your own `filter` function and return `true` or `false` whether the file should be matched. For example the following will only clean folders that are empty: -->\n\n\n<p>或者创建你自己的 <code>filter</code> 函数，当文件是否该匹配时返回 <code>true</code> 或 <code>false</code>。例如下面的例子将只清理空文件夹。</p>\n\n<pre><code>grunt.initConfig({\n  clean: {\n    foo: {\n      src: ['tmp/**/*'],\n      filter: function(filepath) {\n        return (grunt.file.isDir(filepath) &amp;&amp; require('fs').readdirSync(filepath).length === 0);\n      },\n    },\n  },\n});\n</code></pre>\n\n<!-- ### Globbing patterns -->\n\n\n<h3>匹配模式</h3>\n\n<!-- It is often impractical to specify all source filepaths individually, so Grunt supports filename expansion (also know as globbing) via the built-in [node-glob][] and [minimatch][] libraries. -->\n\n\n<p>单独指定所有的源文件路径，往往是不切实际的，所以 Grunt 通过内置的 <a href=\"https://github.com/isaacs/node-glob\">node-glob</a> 和 <a href=\"https://github.com/isaacs/minimatch\">minimatch</a> 库支持文件名扩展（也称为通配符）。</p>\n\n<!-- While this isn't a comprehensive tutorial on globbing patterns, know that in a filepath: -->\n\n\n<p>虽然这不是一个全面的匹配模式指南，但是要知道，在一个文件路径中：</p>\n\n<!-- * `*` matches any number of characters, but not `/`\n* `?` matches a single character, but not `/`\n* `**` matches any number of characters, including `/`, as long as it's the only thing in a path part\n* `{}` allows for a comma-separated list of \"or\" expressions\n* `!` at the beginning of a pattern will negate the match -->\n\n\n\n\n<ul>\n<li><code>*</code> 匹配任意数量的字符，但是不匹配 <code>/</code></li>\n<li><code>?</code> 匹配单个字符，但是不匹配 <code>/</code></li>\n<li><code>**</code> 匹配任意数量的字符，包括 <code>/</code>，只要它是唯一的路径部分</li>\n<li><code>{}</code> 允许用逗号分割的“或”表达式列表</li>\n<li><code>!</code> 在模式的开始处，将对匹配取反</li>\n</ul>\n\n\n\n\n<!-- All most people need to know is that `foo/*.js` will match all files ending with `.js` in the `foo/` subdirectory, but `foo/**/*.js` will match all files ending with `.js` in the `foo/` subdirectory _and all of its subdirectories_. -->\n\n\n<p>大多数人都需要知道的是，<code>foo/*.js</code> 将匹配子目录 <code>foo/</code> 中所有以 <code>.js</code> 结尾的文件，但是 <code>foo/**/*.js</code> 将匹配子目录 <code>foo/</code> <em>和它的所有子目录</em>中所有以 <code>.js</code> 结尾的文件。</p>\n\n<!-- Also, in order to simplify otherwise complicated globbing patterns, Grunt allows arrays of file paths or globbing patterns to be specified. Patterns are processed in-order, with `!`-prefixed matches excluding matched files from the result set. The result set is uniqued. -->\n\n\n<p>此外，为了简化复杂的模式匹配，Grunt 允许指定文件路径数组或匹配模式。模式被顺序处理，以 <code>!</code> 为前缀的模式剔除结果集中匹配的文件。结果集是唯一的。</p>\n\n<p>For example:</p>\n\n<pre><code>// You can specify single files:\n{src: 'foo/this.js', dest: ...}\n// Or arrays of files:\n{src: ['foo/this.js', 'foo/that.js', 'foo/the-other.js'], dest: ...}\n// Or you can generalize with a glob pattern:\n{src: 'foo/th*.js', dest: ...}\n\n// This single node-glob pattern:\n{src: 'foo/{a,b}*.js', dest: ...}\n// Could also be written like this:\n{src: ['foo/a*.js', 'foo/b*.js'], dest: ...}\n\n// All .js files, in foo/, in alpha order:\n{src: ['foo/*.js'], dest: ...}\n// Here, bar.js is first, followed by the remaining files, in alpha order:\n{src: ['foo/bar.js', 'foo/*.js'], dest: ...}\n\n// All files except for bar.js, in alpha order:\n{src: ['foo/*.js', '!foo/bar.js'], dest: ...}\n// All files in alpha order, but with bar.js at the end.\n{src: ['foo/*.js', '!foo/bar.js', 'foo/bar.js'], dest: ...}\n\n// Templates may be used in filepaths or glob patterns:\n{src: ['src/&lt;%= basename %&gt;.js'], dest: 'build/&lt;%= basename %&gt;.min.js'}\n// But they may also reference file lists defined elsewhere in the config:\n{src: ['foo/*.js', '&lt;%= jshint.all.src %&gt;'], dest: ...}\n</code></pre>\n\n<p>For more on glob pattern syntax, see the <a href=\"https://github.com/isaacs/node-glob\">node-glob</a> and <a href=\"https://github.com/isaacs/minimatch\">minimatch</a> documentation.</p>\n\n<p>关于匹配模式语法的更新信息，请查看 <a href=\"https://github.com/isaacs/node-glob\">node-glob</a> 和 <a href=\"https://github.com/isaacs/minimatch\">minimatch</a> 文档。</p>\n\n<!-- ### Building the files object dynamically -->\n\n\n<h3>动态创建文件对象</h3>\n\n<blockquote><p>似乎应该保留 files，因为属性名就是 files</p></blockquote>\n\n<!-- When you want to process many individual files, a few additional properties may be used to build a files list dynamically. These properties may be specified in both \"Compact\" and \"Files Array\" mapping formats. -->\n\n\n<p>当你要处理许多单独文件时，一些额外的属性可以用来动态的创建一个文件列表。这些属性可能被指定在映射格式“紧凑型”和“文件数组”中。</p>\n\n<!-- * `expand` Set to `true` to enable the following options:\n* `cwd` All `src` matches are relative to (but don't include) this path.\n* `src` Pattern(s) to match, relative to the `cwd`.\n* `dest` Destination path prefix.\n* `ext` Replace any existing extension with this value in generated `dest` paths.\n* `flatten` Remove all path parts from generated `dest` paths.\n* `rename` This function is called for each matched `src` file, (after extension renaming and flattening). The `dest` and matched `src` path are passed in, and this function must return a new `dest` value.  If the same `dest` is returned more than once, each `src` which used it will be added to an array of sources for it. -->\n\n\n<ul>\n<li><code>expand</code> 设置为 true，以启用以下选项：</li>\n<li><code>cwd</code> 所有 <code>src</code> 相对于（但不包括）该路径进行匹配。</li>\n<li><code>src</code> 匹配模式，相对于 <code>cwd</code>。</li>\n<li><code>dest</code> 目标路径前缀。</li>\n<li><code>ext</code> 在生成的 <code>dest</code> 路径中替换任何现有的扩展名。</li>\n<li><code>flatten</code> 从生成的 <code>dest</code> 路径中移除所有的路径部分。</li>\n<li><code>rename</code> 为每个匹配的 <code>src</code> 文件调用该函数，（在扩展名重命名和扁平化之后）。<code>dest</code> 和匹配的 <code>src</code> 被转入，该函数必须返回一个新 <code>dest</code> 值。如果多次返回同样的 <code>dest</code>，使用它的每个 <code>src</code> 将被添加到它一个源数组中。</li>\n</ul>\n\n\n<!-- In the following example, the `minify` task will see the same list of src-dest file mappings for both the `static_mappings` and `dynamic_mappings` targets, because Grunt will automatically expand the `dynamic_mappings` files object into 4 individual static src-dest file mappings—assuming 4 files are found—when the task runs. -->\n\n\n<p>在下面的例子中，任务 <code>minify</code> 将得到相同的源-目标文件映射列表，对于目标 <code>static_mapping</code> 和 <code>dynamic_mapping</code>，因为 Grunt 将自动扩展 <code>dynamic_mappings</code> 文件对象为 4 个独立的静态的源-目标文件映射，假设任务运行时只找到 4 个文件。</p>\n\n<!-- Any combination of static src-dest and dynamic src-dest file mappings may be specified. -->\n\n\n<p>可以指定任意组合的静态和动态的源-目标文件映射。</p>\n\n<pre><code>grunt.initConfig({\n  minify: {\n    static_mappings: {\n      // Because these src-dest file mappings are manually specified, every\n      // time a new file is added or removed, the Gruntfile has to be updated.\n      files: [\n        {src: 'lib/a.js', dest: 'build/a.min.js'},\n        {src: 'lib/b.js', dest: 'build/b.min.js'},\n        {src: 'lib/subdir/c.js', dest: 'build/subdir/c.min.js'},\n        {src: 'lib/subdir/d.js', dest: 'build/subdir/d.min.js'},\n      ],\n    },\n    dynamic_mappings: {\n      // Grunt will search for \"**/*.js\" under \"lib/\" when the \"minify\" task\n      // runs and build the appropriate src-dest file mappings then, so you\n      // don't need to update the Gruntfile when files are added or removed.\n      files: [\n        {\n          expand: true,     // Enable dynamic expansion.\n          cwd: 'lib/',      // Src matches are relative to this path.\n          src: ['**/*.js'], // Actual pattern(s) to match.\n          dest: 'build/',   // Destination path prefix.\n          ext: '.min.js',   // Dest filepaths will have this extension.\n        },\n      ],\n    },\n  },\n});\n</code></pre>\n\n<!-- ## Templates -->\n\n\n<h2>模板</h2>\n\n<!-- Templates specified using `<% %>` delimiters will be automatically expanded when tasks read them from the config. Templates are expanded recursively until no more remain. -->\n\n\n<p>使用分隔符 <code>&lt;% %&gt;</code> 指定的模板将被自动扩展，当任务从配置中读取它们时。模板被递归扩展直到没有剩余。</p>\n\n<!-- The entire config object is the context in which properties are resolved. Additionally, `grunt` and its methods are available inside templates, eg. `<%= grunt.template.today('yyyy-mm-dd') %>`. -->\n\n\n<p>整个配置对象是上下文，在使用的属性下的。此外，在模板中，<code>grunt</code> 和它的方法也是有效的，例如 <code>&lt;%= grunt.template.today('yyyy-mm-dd') %&gt;</code>。</p>\n\n<!-- * `<%= prop.subprop %>` Expand to the value of `prop.subprop` in the config, regardless of type. Templates like this can be used to reference not only string values, but also arrays or other objects.\n* `<% %>` Execute arbitrary inline JavaScript code. This is useful with control flow or looping. -->\n\n\n<ul>\n<li><code>&lt;%= prop.subprop %&gt;</code> 扩展为配置中 <code>prop.subprop</code> 的值。像这样的模板可能用来不仅仅引用字符串值，也可以是数组或其他对象。</li>\n<li><code>&lt;% %&gt;</code> 执行任意的内联 JavaScript 代码。对于控制流程或循环非常有用。</li>\n</ul>\n\n\n<!-- Given the sample `concat` task configuration below, running `grunt concat:sample` will generate a file named `build/abcde.js` by concatenating the banner `/* abcde */` with all files matching `foo/*.js` + `bar/*.js` + `baz/*.js`. -->\n\n\n<p>下面给定简单任务 <code>concat</code> 的配置，运行 <code>grunt concat:sample</code> 将生成一个命名为 <code>build/abcde.js</code> 的文件，通过合并 <code>/* abcde */</code> 和所有匹配 <code>foo/*.js</code> + <code>bar/*.js</code> + <code>baz/*.js</code> 的文件。</p>\n\n<pre><code>grunt.initConfig({\n  concat: {\n    sample: {\n      options: {\n        banner: '/* &lt;%= baz %&gt; */\\n',   // '/* abcde */\\n'\n      },\n      src: ['&lt;%= qux %&gt;', 'baz/*.js'],  // [['foo/*.js', 'bar/*.js'], 'baz/*.js']\n      dest: 'build/&lt;%= baz %&gt;.js',      // 'build/abcde.js'\n    },\n  },\n  // Arbitrary properties used in task configuration templates.\n  foo: 'c',\n  bar: 'b&lt;%= foo %&gt;d', // 'bcd'\n  baz: 'a&lt;%= bar %&gt;e', // 'abcde'\n  qux: ['foo/*.js', 'bar/*.js'],\n});\n</code></pre>\n\n<!-- ## Importing External Data -->\n\n\n<h2>导入外部数据</h2>\n\n<!-- In the following Gruntfile, project metadata is imported into the Grunt config from a `package.json` file, and the [grunt-contrib-uglify plugin](http://github.com/gruntjs/grunt-contrib-uglify) `uglify` task is configured to minify a source file and generate a banner comment dynamically using that metadata. -->\n\n\n<p>在下面的 Gruntfile 中，项目元数据从一个 <code>package.json</code> 文件被导入到 Grunt 配置，并且 <a href=\"http://github.com/gruntjs/grunt-contrib-uglify\">grunt-contrib-uglify 插件</a>任务被配置为压缩源文件并且使用元数据动态生成一段顶部注释。</p>\n\n<!-- Grunt has `grunt.file.readJSON` and `grunt.file.readYAML` methods for importing JSON and YAML data. -->\n\n\n<p>Grunt 拥有方法 <code>grunt.file.readJSON</code> and <code>grunt.file.readYAML</code>，来导入 JSON 和 YAML 数据。</p>\n\n<pre><code>grunt.initConfig({\n  pkg: grunt.file.readJSON('package.json'),\n  uglify: {\n    options: {\n      banner: '/*! &lt;%= pkg.name %&gt; &lt;%= grunt.template.today(\"yyyy-mm-dd\") %&gt; */\\n'\n    },\n    dist: {\n      src: 'src/&lt;%= pkg.name %&gt;.js',\n      dest: 'dist/&lt;%= pkg.name %&gt;.min.js'\n    }\n  }\n});\n</code></pre>\n"
            ],
            "link": [
              "http://nuysoft.github.com/2013/03/29/grunt-configuring-tasks"
            ],
            "guid": [
              "http://nuysoft.github.com/2013/03/29/grunt-configuring-tasks"
            ],
            "pubDate": [
              "2013-03-29T00:00:00-07:00"
            ]
          },
          {
            "title": [
              "Grunt 0.4.x Documentation"
            ],
            "description": [
              "\n\n<ul>\n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n      \n        <li>\n            <a href=\"/2013/03/29/grunt-sample-gruntfile\">Gruntfile 示例</a>\n            <br>\n            <span>Sample Gruntfile。介绍和分析一个 Gruntfile 示例，其中使用了 5 个 grunt 插件</span>\n        </li>\n      \n    \n  \n    \n      \n        <li>\n            <a href=\"/2013/03/29/grunt-project-scaffolding\">项目脚手架</a>\n            <br>\n            <span>Project Scaffolding。grunt-init 是一个脚手架工具，用于自动创建项目。基于当前的环境和几个问题的答案创建一个完整的目录结构。确切的文件和内容取决于所选的模板，和模板提出的问题的答案。</span>\n        </li>\n      \n    \n  \n    \n      \n        <li>\n            <a href=\"/2013/03/29/grunt-installing-grunt\">安装 Grunt</a>\n            <br>\n            <span>Installing Grunt。介绍如何安装特定版本的 grunt 和 grunt 插件。</span>\n        </li>\n      \n    \n  \n    \n      \n        <li>\n            <a href=\"/2013/03/29/grunt-getting-started\">Grunt 入门</a>\n            <br>\n            <span>Getting Started。</span>\n        </li>\n      \n    \n  \n    \n      \n        <li>\n            <a href=\"/2013/03/29/grunt-creating-tasks\">创建任务</a>\n            <br>\n            <span>Creating Tasks。每次运行 Grunt 时，你可以指定一个或多个任务来运行，任务告诉了 Grunt 你想要它做的事情。</span>\n        </li>\n      \n    \n  \n    \n      \n        <li>\n            <a href=\"/2013/03/29/grunt-creating-plugins\">创建插件</a>\n            <br>\n            <span>Creating Plugins。如何创建插件以及注意事项。</span>\n        </li>\n      \n    \n  \n    \n      \n        <li>\n            <a href=\"/2013/03/29/grunt-configuring-tasks\">配置任务</a>\n            <br>\n            <span>Configuring Tasks。介绍如何在项目中使用文件 Gruntfile 配置任务。</span>\n        </li>\n      \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n    \n  \n</ul>\n\n\n\n\n<!-- \n## Documentation\n* [Getting Started]\n* [Configuring Tasks]\n* [Sample Gruntfile]\n* [Creating Tasks]\n* [Creating Plugins]\n\n## Advanced\n* [Installing Grunt]\n* Frequently Asked Questions\n* [Project Scaffolding]\n\n## API\n* Inside Tasks \n-->\n\n\n\n"
            ],
            "link": [
              "http://nuysoft.github.com/2013/03/21/grunt-04x-documentation"
            ],
            "guid": [
              "http://nuysoft.github.com/2013/03/21/grunt-04x-documentation"
            ],
            "pubDate": [
              "2013-03-21T00:00:00-07:00"
            ]
          },
          {
            "title": [
              "Jison Docs"
            ],
            "description": [
              "\n"
            ],
            "link": [
              "http://nuysoft.github.com/2013/03/19/jison-docs-cn"
            ],
            "guid": [
              "http://nuysoft.github.com/2013/03/19/jison-docs-cn"
            ],
            "pubDate": [
              "2013-03-19T00:00:00-07:00"
            ]
          },
          {
            "title": [
              "A FRONT END ENGINEER'S MANIFESTO"
            ],
            "description": [
              "\n"
            ],
            "link": [
              "http://nuysoft.github.com/2013/03/16/a-front-end-engineer-s-manifesto"
            ],
            "guid": [
              "http://nuysoft.github.com/2013/03/16/a-front-end-engineer-s-manifesto"
            ],
            "pubDate": [
              "2013-03-16T00:00:00-07:00"
            ]
          },
          {
            "title": [
              "SPA Demo"
            ],
            "description": [
              "\n"
            ],
            "link": [
              "http://nuysoft.github.com/2013/03/15/spa-demo"
            ],
            "guid": [
              "http://nuysoft.github.com/2013/03/15/spa-demo"
            ],
            "pubDate": [
              "2013-03-15T00:00:00-07:00"
            ]
          },
          {
            "title": [
              "Templating"
            ],
            "description": [
              "\n"
            ],
            "link": [
              "http://nuysoft.github.com/2013/03/06/templating"
            ],
            "guid": [
              "http://nuysoft.github.com/2013/03/06/templating"
            ],
            "pubDate": [
              "2013-03-06T00:00:00-08:00"
            ]
          },
          {
            "title": [
              "Markdown Editor"
            ],
            "description": [
              "\n"
            ],
            "link": [
              "http://nuysoft.github.com/2013/02/04/markdown-editor"
            ],
            "guid": [
              "http://nuysoft.github.com/2013/02/04/markdown-editor"
            ],
            "pubDate": [
              "2013-02-04T00:00:00-08:00"
            ]
          },
          {
            "title": [
              "jQuery 技术内幕"
            ],
            "description": [
              "<h2>审校邀请</h2>\n\n<p>《jQuery 技术内幕》的审校正式开始了，请阅读下面的目录，选择感兴趣和有研究的章节与 <a href=\"&#109;&#x61;&#105;&#108;&#x74;&#111;&#58;&#110;&#117;&#121;&#115;&#x6f;&#x66;&#116;&#x40;&#103;&#x6d;&#97;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;\">&#x6e;&#117;&#121;&#x73;&#x6f;&#x66;&#x74;&#x40;&#103;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#x6d;</a> 沟通确认。</p>\n\n<p>如果你认为文稿中哪里有问题或者不合理，请整理出来一并回复邮件 nuysoft@gmail.com 给我，格式不限，只要能把问题描述清楚即可。</p>\n\n<p>校对过程中应当留心这些内容：</p>\n\n<ul>\n<li>理解和描述错误</li>\n<li>表述不清楚</li>\n<li>严重的术语使用错误</li>\n<li>术语不统一</li>\n<li>概念错误</li>\n</ul>\n\n\n<p>希望我们能共同努力提高这本书的原创质量，期待您的回复。</p>\n\n<p>《jQuery技术内幕》作者 高云</p>\n\n<h2>审校人&amp;状态</h2>\n\n<table>\n<thead>\n<tr>\n<th></th>\n<th> #  </th>\n<th> 章             </th>\n<th> 审校                  </th>\n<th> 进度      </th>\n<th> 状态    </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td></td>\n<td> 1  </td>\n<td> 总体架构        </td>\n<td>                      </td>\n<td>           </td>\n<td>         |</td>\n</tr>\n<tr>\n<td></td>\n<td> 2  </td>\n<td> 构造jQuery对象  </td>\n<td> 段英杰                </td>\n<td>           </td>\n<td>         |</td>\n</tr>\n<tr>\n<td></td>\n<td> 3  </td>\n<td> 选择器          </td>\n<td> 肖平原               </td>\n<td>           </td>\n<td>        |</td>\n</tr>\n<tr>\n<td></td>\n<td> 4  </td>\n<td> 异步队列        </td>\n<td> 叶克良 李志博         </td>\n<td> 已反馈     </td>\n<td>         |</td>\n</tr>\n<tr>\n<td></td>\n<td> 5  </td>\n<td> 数据缓存        </td>\n<td>                      </td>\n<td>           </td>\n<td>         |</td>\n</tr>\n<tr>\n<td></td>\n<td> 6  </td>\n<td> 队列            </td>\n<td> 尼奥                 </td>\n<td>           </td>\n<td>         |</td>\n</tr>\n<tr>\n<td></td>\n<td> 7  </td>\n<td> 浏览器功能测试   </td>\n<td> 李锦                 </td>\n<td>           </td>\n<td>         |</td>\n</tr>\n<tr>\n<td></td>\n<td> 8  </td>\n<td> 属性操作        </td>\n<td> 马金刚                </td>\n<td>           </td>\n<td>         |</td>\n</tr>\n<tr>\n<td></td>\n<td> 9  </td>\n<td> 事件处理        </td>\n<td> 马金刚 杨剑           </td>\n<td>           </td>\n<td>         |</td>\n</tr>\n<tr>\n<td></td>\n<td> 10 </td>\n<td> DOM遍历        </td>\n<td> 王阳光                </td>\n<td> 已反馈      </td>\n<td>         |</td>\n</tr>\n<tr>\n<td></td>\n<td> 11 </td>\n<td> DOM操作        </td>\n<td> 余鹏                  </td>\n<td>           </td>\n<td>         |</td>\n</tr>\n<tr>\n<td></td>\n<td> 12 </td>\n<td> CSS操作        </td>\n<td> 崇志                  </td>\n<td>           </td>\n<td>         |</td>\n</tr>\n<tr>\n<td></td>\n<td> 13 </td>\n<td> Ajax           </td>\n<td> 许杰 蒋伟阳           </td>\n<td>           </td>\n<td>         |</td>\n</tr>\n<tr>\n<td></td>\n<td> 14 </td>\n<td> 动画           </td>\n<td> 尼奥                  </td>\n<td>           </td>\n<td>         |</td>\n</tr>\n</tbody>\n</table>\n\n\n<script type=\"text/javascript\">\n    $(function(){\n        $('table').addClass('table table-bordered')\n    })\n</script>\n\n"
            ],
            "link": [
              "http://nuysoft.github.com/2013/02/01/book"
            ],
            "guid": [
              "http://nuysoft.github.com/2013/02/01/book"
            ],
            "pubDate": [
              "2013-02-01T00:00:00-08:00"
            ]
          },
          {
            "title": [
              "jQuery Code Overview"
            ],
            "description": [
              "\n"
            ],
            "link": [
              "http://nuysoft.github.com/2012/12/03/jquery-code-overview"
            ],
            "guid": [
              "http://nuysoft.github.com/2012/12/03/jquery-code-overview"
            ],
            "pubDate": [
              "2012-12-03T00:00:00-08:00"
            ]
          },
          {
            "title": [
              "Why QUnit"
            ],
            "description": [
              "<h2>WHAT - 测试工具</h2>\n\n<ul>\n<li><p><a href=\"http://github.com/jquery/qunit\">QUnit</a>\n<span class=\"ghbtns\" style=\"padding-left: 10px; float: right; \" data-fullname=\"jquery/qunit\"></span></p>\n\n<ul>\n<li>An easy-to-use JavaScript Unit Testing framework.</li>\n</ul>\n</li>\n<li><p><a href=\"https://github.com/pivotal/jasmine\">Jasmine</a>\n<span class=\"ghbtns\" style=\"padding-left: 10px; float: right; \" data-fullname=\"pivotal/jasmine\"></span></p>\n\n<ul>\n<li>DOM-less simple JavaScript testing framework</li>\n</ul>\n</li>\n<li><p><a href=\"https://github.com/cloudhead/vows\">Vows</a>\n<span class=\"ghbtns\" style=\"padding-left: 10px; float: right; \" data-fullname=\"cloudhead/vows\"></span></p>\n\n<ul>\n<li>Asynchronous BDD &amp; continuous integration for node.js</li>\n</ul>\n</li>\n<li><p><a href=\"https://github.com/visionmedia/mocha\">Mocha</a>\n<span class=\"ghbtns\" style=\"padding-left: 10px; float: right; \" data-fullname=\"visionmedia/mocha\"></span></p>\n\n<ul>\n<li>mocha - simple, flexible, fun javascript test framework for node.js &amp; the browser. (BDD, TDD, QUnit styles via interfaces)</li>\n</ul>\n</li>\n<li><p><a href=\"http://hirojs.com/\">Hiro</a>\n<span class=\"ghbtns\" style=\"padding-left: 10px; float: right; \" data-fullname=\"antonkovalyov/hiro\"></span></p>\n\n<ul>\n<li>Hiro is a framework for testing third-party JavaScript applications. It runs each test suite in a separate sandbox preventing global state leaks and conflicts.</li>\n</ul>\n</li>\n<li><a href=\"https://code.google.com/p/js-test-driver/\">JsTestDriver</a>\n\n<ul>\n<li>JsTestDriver aims to help javascript developers use good TDD practices and aims to make writing unit tests as easy as what already exists today for java with JUnit.</li>\n</ul>\n</li>\n<li><p><a href=\"http://busterjs.org/\">Buster.js</a>\n<span class=\"ghbtns\" style=\"padding-left: 10px; float: right; \" data-fullname=\"busterjs/buster\"></span></p>\n\n<ul>\n<li>A powerful suite of automated test tools for JavaScript.</li>\n</ul>\n</li>\n<li><p><a href=\"http://sinonjs.org/\">Sinon.js</a>\n<span class=\"ghbtns\" style=\"padding-left: 10px; float: right; \" data-fullname=\"cjohansen/Sinon.JS\"></span></p>\n\n<ul>\n<li>Standalone and test framework agnostic JavaScript test spies, stubs and mocks.</li>\n</ul>\n</li>\n</ul>\n\n\n<h2>WHAT - 什么是单元测试&amp;自动化测试？</h2>\n\n<p>不用解释了吧。</p>\n\n<h2>WHAT - 为什么要做单元测试&amp;自动化测试？</h2>\n\n<ul>\n<li>验证程序正确性</li>\n<li>修复 bug 后的回归测试</li>\n<li>安全的代码重构</li>\n<li>缩短测试周期</li>\n</ul>\n\n\n<h2>HOW – Jasmine vs Qunit</h2>\n\n<h3>基本结构</h3>\n\n<ul>\n<li>测试套件&amp;模块 suit</li>\n<li>测试用例 case</li>\n<li>断言 assertion</li>\n</ul>\n\n\n<h3>规范：CommonJS Unit Testing/1.1</h3>\n\n<ul>\n<li><a href=\"http://wiki.commonjs.org/wiki/Unit_Testing/1.0\">http://wiki.commonjs.org/wiki/Unit_Testing/1.0</a></li>\n<li><a href=\"http://wiki.commonjs.org/wiki/Unit_Testing/1.1\">http://wiki.commonjs.org/wiki/Unit_Testing/1.1</a></li>\n</ul>\n\n\n<h3>Jasmine ['dʒæzmɪn; 'dʒæs-]</h3>\n\n<ul>\n<li><a href=\"https://github.co[/pivotal/jasmine\">https://github.com/pivotal/jasmine</a></li>\n<li><a href=\"http://pivotal.github.com/jasmine/\">http://pivotal.github.com/jasmine/</a></li>\n<li><a href=\"https://github.com/mhevery/jasmine-node\">https://github.com/mhevery/jasmine-node</a></li>\n</ul>\n\n\n<p>Jasmine 是行为驱动的 JavaScript 测试框架。不依赖于任何第三方 JavaScript 框架。不需要 DOM。拥有干净、明确的语法，可以容易的编写测试用例。</p>\n\n<ul>\n<li><p>优点：实现很完整，对于异步、同步测试的支持很好。</p></li>\n<li><p>缺点：不符合规范，写法语义化导致繁琐，方法太多。</p></li>\n</ul>\n\n\n<p>The Jasmine Ruby Gem is for Rails, Ruby, or Ruby-friendly development</p>\n\n<h3>基本语法</h3>\n\n<pre><code>describe(\"A suite\", function() {\n  it(\"contains spec with an expectation\", function() {\n    expect(true).toBe(true);\n  });\n});\n</code></pre>\n\n<h2>QUnit</h2>\n\n<p><a href=\"http://qunitjs.com/\">http://qunitjs.com/</a></p>\n\n<p>QUnit 是一个强大、易用的 JavaScript 测试套件。它用于测试 jQuery 和插件，但是也适用于测试任何通用的 JavaScript 代码（甚至可用于服务端的 JavaScript 代码）。</p>\n\n<ul>\n<li><strong>优先</strong>：清晰、高质的源码；符合 CommonJS Unit Test 规范。</li>\n<li><strong>缺点</strong>：异步操作太繁琐（stop()、start()）。</li>\n</ul>\n\n\n<h3>历史</h3>\n\n<p>QUnit 最初作为 jQuery 的一部分，由 John Resig 开发。2008年有了自己的主页、名称、API 文档，允许作为其他 JavaScript 代码的单元测试工具，此时它仍然依赖于 jQuery。2009年重写，QUnit 完全独立运行。\nQUnit 的断言方法遵从 CommonJS Unit Test 规范，该规范在某种程度上受到了 QUnit 的影响。</p>\n\n<h3>基本语法</h3>\n\n<pre><code>module( \"group a\" );\ntest( \"a basic test example\", function() {\n    ok( true, \"this test is fine\" );\n});\ntest( \"a basic test example 2\", function() {\n    ok( true, \"this test is fine\" );\n});\n\nmodule( \"group b\" );\ntest( \"a basic test example 3\", function() {\n    ok( true, \"this test is fine\" );\n});\ntest( \"a basic test example 4\", function() {\n    ok( true, \"this test is fine\" );\n});\n</code></pre>\n\n<h3>哪些开源库&amp;框架在用 QUnit？</h3>\n\n<p><a href=\"https://github.com/twitter/bootstrap\">bootstrap</a>、<a href=\"https://github.com/jquery/jquery\">jquery</a>、<a href=\"https://github.com/documentcloud/backbone\">backbone</a>、<a href=\"https://github.com/gruntjs/grunt\">grunt</a> ...</p>\n\n<h2>HOW - Demo</h2>\n\n<p>QUnit + jQuery Queue</p>\n\n<h2>HOW - 最佳实践</h2>\n\n<ul>\n<li>测试粒度（覆盖率）足够细</li>\n<li>按照业务模块组织测试代码</li>\n<li>与业务代码分离</li>\n</ul>\n\n\n<h2>WHY - QUnit 实现原理</h2>\n\n<ol>\n<li><p><strong>初始化</strong>：用一个数组 config.queue 存放待执行的测试用例：</p>\n\n<pre><code> config = {\n     queue: [],\n };\n function synchronize( callback, last ) {\n     config.queue.push( callback );\n     if ( config.autorun &amp;&amp; !config.blocking ) {\n         process( last );\n     }\n }\n</code></pre></li>\n<li><p><strong>运行时</strong>：用一个 while 循环遍历数组 config.queue，从头部开始顺序执行：</p>\n\n<pre><code> function process( last ) {\n     function next() {\n         process( last );\n     }\n     var start = new Date().getTime();\n     config.depth = config.depth ? config.depth + 1 : 1;\n     while ( config.queue.length &amp;&amp; !config.blocking ) {\n         if ( !defined.setTimeout || config.updateRate &lt;= 0 || ( ( new Date().getTime() - start ) &lt; config.updateRate ) ) {\n             config.queue.shift()();\n         } else {\n             window.setTimeout( next, 13 );\n             break;\n         }\n     }\n     config.depth--;\n     if ( last &amp;&amp; !config.blocking &amp;&amp; !config.queue.length &amp;&amp; config.depth === 0 ) {\n         done();\n     }\n }\n</code></pre></li>\n<li><p><strong>异步操作</strong>：调用 stop() 后设置 config.blocking = true；调用 start() 后设置 config.blocking = false。如果 config.blocking 为 true，则会每隔 13ms 尝试恢复 while 循环。</p></li>\n</ol>\n\n"
            ],
            "link": [
              "http://nuysoft.github.com/2012/08/29/why-qunit"
            ],
            "guid": [
              "http://nuysoft.github.com/2012/08/29/why-qunit"
            ],
            "pubDate": [
              "2012-08-29T00:00:00-07:00"
            ]
          },
          {
            "title": [
              "How JavaScript MV* Works"
            ],
            "description": [
              "<h2>参考资料</h2>\n\n<ul>\n<li><a href=\"http://blog.stevensanderson.com/2012/08/01/rich-javascript-applications-the-seven-frameworks-throne-of-js-2012/\">Rich JavaScript Applications – the Seven Frameworks</a>\n\n<ul>\n<li><a href=\"http://www.ituring.com.cn/article/8108\">[翻译] JavaScript宝座：七大框架论剑</a></li>\n<li>AngularJS、Backbone、Batman、CanJS、Ember、Meteor、Knockout、Spine</li>\n</ul>\n</li>\n<li><a href=\"http://stackoverflow.com/questions/6530444/backbone-js-vs-spine-js\">Backbone.js vs Spine.js</a></li>\n<li><a href=\"http://www.codeproject.com/Articles/42830/Model-View-Controller-Model-View-Presenter-and-Mod\">Model View Controller, Model View Presenter, and Model View ViewModel Design Patterns</a></li>\n<li><a href=\"http://channel9.msdn.com/Events/TechEd/NorthAmerica/2011/DPR305\">MVC, MVP and MVVM: A Comparison of Architectural Patterns</a></li>\n<li><a href=\"http://nirajrules.wordpress.com/2009/07/18/mvc-vs-mvp-vs-mvvm/\">MVC vs. MVP vs. MVVM</a></li>\n<li><a href=\"http://joel.inpointform.net/software-development/mvvm-vs-mvp-vs-mvc-the-differences-explained/\">MVVM vs MVP vs MVC: The differences explained</a></li>\n<li><a href=\"http://joel.inpointform.net/software-development/mvvm-vs-mvp-vs-mvc/\">MVVM vs MVP vs MVC  The concise explanation</a></li>\n<li><a href=\"http://wenku.baidu.com/view/16decd4e852458fb770b560f.html\">MVP(SC),MVP(PV),PM,MVVM 和 MVC 表现模式架构对比</a></li>\n<li><a href=\"http://www.codeproject.com/Articles/228214/Understanding-Basics-of-UI-Design-Pattern-MVC-MVP\">Understanding Basics of UI Design Pattern MVC, MVP and MVVM</a></li>\n<li><a href=\"http://www.cnblogs.com/piaopiao7891/archive/2012/09/04/2670390.html\">MVC系列之一:图解MVC MVP MVVM区别</a></li>\n<li><a href=\"http://en.wikipedia.org/wiki/Model-view-controller\">wiki MVC</a></li>\n<li><a href=\"http://www.dotblogs.com.tw/regionbbs/archive/2011/09/29/compare.to.mvp.mvc.mvvm.aspx\">MVP, MVC, MVVM, 傻傻分不清楚~</a></li>\n<li><a href=\"http://csharperimage.jeremylikness.com/2010/04/model-view-viewmodel-mvvm-explained.html\">Model-View-ViewModel (MVVM) Explained</a></li>\n<li><a href=\"http://www.zhihu.com/question/20148405\">知乎 MVC、MVP、MVVM</a></li>\n<li><a href=\"http://baike.baidu.com/view/3507915.htm\">百科 MVVM</a></li>\n<li><a href=\"http://feliving.github.com/developing-backbone-applications/\">白汀 Backbone Application</a></li>\n<li><a href=\"http://heim.ifi.uio.no/~trygver/1979/mvc-2/1979-12-MVC.pdf\">MODELS - VIEWS - CONTROLLERS</a>\n\n<ul>\n<li><a href=\"http://www.cnblogs.com/winter-cn/archive/2012/06/13/2547662.html\">[翻译] MODELS - VIEWS – CONTROLLERS</a></li>\n<li><a href=\"http://www.cnblogs.com/winter-cn/archive/2012/09/16/2687184.html\">为何选择MVVM而非MVC</a></li>\n</ul>\n</li>\n<li><a href=\"http://stackoverflow.com/questions/4751633/clarification-mvc-mvp-mvvm\">Clarification :MVC,MVP,MVVM</a></li>\n<li><a href=\"http://geekswithblogs.net/dlussier/archive/2009/11/21/136454.aspx\">MVVM Compared To MVC and MVP</a></li>\n<li><a href=\"http://books.google.com.hk/books?id=6WJ5oQT0dcUC&amp;hl=zh-CN\">Building Enterprise Applications with Windows Presentation Foundation and the MVVM Model View ViewModel Pattern</a></li>\n<li><a href=\"http://ghbtns.com/\">GitHub Buttons</a></li>\n</ul>\n\n\n<h2>参考框架&amp;库</h2>\n\n<ul>\n<li><p><a href=\"https://github.com/documentcloud/backbone\">Backbone</a>\n<span class=\"ghbtns\" style=\"padding-left: 10px; float: right; \" data-fullname=\"documentcloud/backbone\"></span></p>\n\n<ul>\n<li>Backbone supplies structure to JavaScript-heavy applications by providing models key-value binding and custom events, collections with a rich API of enumerable functions, views with declarative event handling, and connects it all to your existing application over a RESTful JSON interface.</li>\n</ul>\n</li>\n<li><p><a href=\"https://github.com/meteor/meteor\">Meteor</a>\n<span class=\"ghbtns\" style=\"padding-left: 10px; float: right; \" data-fullname=\"meteor/meteor\"></span></p>\n\n<ul>\n<li>Meteor is an ultra-simple environment for building modern web applications.</li>\n<li>With Meteor you write apps:\n\n<ul>\n<li>in pure Javascript</li>\n<li>that send data over the wire, rather than HTML</li>\n<li>using your choice of popular open-source libraries</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><a href=\"https://github.com/emberjs/ember.js\">Ember.js</a>\n<span class=\"ghbtns\" style=\"padding-left: 10px; float: right; \" data-fullname=\"emberjs/ember.js\"></span></p>\n\n<ul>\n<li>Ember.js is a JavaScript framework that does all of the heavy lifting that you'd normally have to do by hand. There are tasks that are common to every web app; Ember.js does those things for you, so you can focus on building killer features and UI.</li>\n<li>These are the three features that make Ember.js a joy to use:\n\n<ul>\n<li>Bindings</li>\n<li>Computed properties</li>\n<li>Auto-updating templates</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><a href=\"https://github.com/angular/angular.js\">AngularJS</a>\n<span class=\"ghbtns\" style=\"padding-left: 10px; float: right; \" data-fullname=\"janl/mustache.js\"></span></p>\n\n<ul>\n<li>AngularJS lets you write client-side web applications as if you had a smarter browser. It lets you use good old HTML (or HAML, Jade and friends!) as your template language and lets you extend HTML’s syntax to express your application’s components clearly and succinctly. It automatically synchronizes data from your UI (view) with your JavaScript objects (model) through 2-way data binding. To help you structure your application better and make it easy to test, AngularJS teaches the browser how to do dependency injection and inversion of control. Oh yeah and it also helps with server-side communication, taming async callbacks with promises and deferreds; and make client-side navigation and deeplinking with hashbang urls or HTML5 pushState a piece of cake. The best of all: it makes development fun!</li>\n</ul>\n</li>\n<li><p><a href=\"https://github.com/SteveSanderson/knockout\">Knockout</a>\n<span class=\"ghbtns\" style=\"padding-left: 10px; float: right; \" data-fullname=\"SteveSanderson/knockout\"></span></p>\n\n<ul>\n<li>Knockout is a JavaScript MVVM (a modern variant of MVC) library that makes it easier to create rich, desktop-like user interfaces with JavaScript and HTML. It uses observers to make your UI automatically stay in sync with an underlying data model, along with a powerful and extensible set of declarative bindings to enable productive development.</li>\n</ul>\n</li>\n<li><p><a href=\"https://github.com/spine/spine\">Spine</a>\n<span class=\"ghbtns\" style=\"padding-left: 10px; float: right; \" data-fullname=\"spine/spine\"></span></p>\n\n<ul>\n<li>Spine is a lightweight framework for building JavaScript web applications. Spine gives you an MVC structure and then gets out of your way, allowing you to concentrate on the fun stuff, building awesome web applications.</li>\n</ul>\n</li>\n<li><p><a href=\"https://github.com/Shopify/batman\">batman.js</a>\n<span class=\"ghbtns\" style=\"padding-left: 10px; float: right; \" data-fullname=\"Shopify/batman\"></span></p>\n\n<ul>\n<li>batman.js is a framework for building rich single-page browser applications. It is written in CoffeeScript and its API is developed with CoffeeScript in mind, but of course you can use plain old JavaScript too.</li>\n</ul>\n</li>\n<li><p><a href=\"https://github.com/bitovi/canjs\">CanJS</a>\n<span class=\"ghbtns\" style=\"padding-left: 10px; float: right; \" data-fullname=\"bitovi/canjs\"></span></p>\n\n<ul>\n<li>CanJS is a MIT-licensed, client-side, JavaScript framework that makes building rich web applications easy. Use it because it’s: Smaller, Faster, Safer, Easier, Library-er.</li>\n</ul>\n</li>\n<li><p><a href=\"https://github.com/addyosmani/todomvc\">TodoMVC</a>\n<span class=\"ghbtns\" style=\"padding-left: 10px; float: right; \" data-fullname=\"addyosmani/todomvc\"></span></p>\n\n<ul>\n<li>Helping you select an MV* framework - Todo apps for Backbone.js, Ember.js, AngularJS, Spine and many more</li>\n</ul>\n</li>\n</ul>\n\n\n<h2>前言开光 - 框架>=本质</h2>\n\n<p>先起个头谈谈对框架认识和学习吧。</p>\n\n<p>优秀的框架是对某一类问题的本质认知、对关键特征的精确把握，需要深厚的软件功底和大量应用开发经验，是设计模式在某一领域的最佳实践，以及对诸多因素的平衡。</p>\n\n<p>学习框架就是在学习某一类问题的本质和关键特征，学习作者对理论、实现、应用、市场的平衡理念。</p>\n\n<p>通过这个系列我希望达到以下目的：</p>\n\n<ul>\n<li>MVC 提出了什么问题（或希望解决什么问题）</li>\n<li>学习 Backbone 是如何解决的（或作者是如何理解 JSMVC 的）</li>\n<li>学习 Backbone 的实现技巧</li>\n<li>学习 Backbone 涉及的基础知识</li>\n<li>以及前端开发的方向</li>\n<li>最终接近作者的专业水平</li>\n</ul>\n\n\n<p>附：《Backbone 源码分析系列》依然是以源码分析为主，目前会把时间放在这个系列上，入门和应用开发会另开两个系列《Backbone 入门》和《精通 Backbone》，视时间而定。</p>\n\n<h2>MVC 模型</h2>\n\n<h3>代码混乱</h3>\n\n<p>前端攻城师是个新兴的职业，一直以来前端开发面临着以下的问题：</p>\n\n<ul>\n<li>数据模型、业务模型不清晰</li>\n<li>代码复用率低，很多时候是 Ctrl-C/V</li>\n<li>代码可读性和可维护性低</li>\n<li>难以满足需求的变化，特别是前端需求的频繁变化</li>\n</ul>\n\n\n<p>jQuery 在很大程度上改善了这种状态，解决了原生 JS 代码写起来繁琐的问题；jQuery 的革命性特征可以总结为：</p>\n\n<ul>\n<li>良好的浏览器兼容</li>\n<li>独特的链式语法</li>\n<li>高效 CSS 选择器</li>\n<li>丰富的插件</li>\n<li>以及更好的贯彻 HTML、CSS、JS 的分工。</li>\n</ul>\n\n\n<p>不过，总体感觉 jQuery 是定位于 DOM 查找和操作为主的基础库，这样的定位使得 jQuery 的大型前端项目中只能作为底层支持库使用。应用代码依然是杂乱无章，从而不得不依赖于攻城师的技术水准和职业素养。</p>\n\n<p>MVC 模型则通过细分模型、视图、控制器的职责，可以解耦合、提高代码复用、简化重构、适应变化、易扩展、易读、较少维护代码、提高可维护性。同时，因为是分层结构化、模块化开发，还可以实现代码自动生成。但是MVC也会导致复杂度上升、运行效率下降。</p>\n\n<p>MVC 的核心目标是：分离显示逻辑和业务逻辑，即减弱业务逻辑接口与数据逻辑接口之间的耦合，以及让视图层更富于变化。</p>\n\n<p>MVC 的优点可以概括为：可扩展性、可复用性、可维护性、有利于软件工程管理。</p>\n\n<p>Backbone 的优点集中体现在：提供 MVC 模型基础实现、面向对象、导航。</p>\n\n<p>导航使系统的脉络更加清晰，通过一个配置文件，即可把握整个系统各部分之间联系，便于维护。</p>\n\n<p>MVC 特别适用于事件驱动的场景，通过约定开发方式，还可以使代码开发和代码管理变得有章可循。JS 应用程序运行的的本质是基于事件驱动，这与 MVC 不谋而合。并且，MVC 在大部分语言的框架中都有实现，随着前端和 JS 越来越被认可和重视，JSMVC 框架的出现成为必然。</p>\n\n<p>Backbone 正是 MVC 开发模型在浏览器环境中的实践，从目前看也是一款优秀的 JSMVC 框架。</p>\n\n<h3>传说中的单页面应用程序 SPA（或一站式应用程序）</h3>\n\n<p>SPA Sigle-page Application，也称为 OPOA One Page One Application、SPI Sigle-page Interface。</p>\n\n<p>SPA 的优势相当诱人，可以共享框、库、数据，减少 HTTP 请求和流量，缩短加载时间、降低成本；不必重新加载整个页面，不会出现界面调整时的空白页面，加上合理的加载提示动画，可以实现不间断的用户体验。</p>\n\n<p>但是 SPA 也带来了更多的挑战，比如：</p>\n\n<ul>\n<li>所有的 HTML、CSS、JS 都在一个页面中加载和销毁，需要安全、可靠、开发简单的内存管理，尤其是IE臭名昭著的内存泄漏。</li>\n<li>事件管理会更加复杂，jQuery 提供的事件缓存不能完全满足这种需求。</li>\n<li>浏览器历史管理。</li>\n<li>还有诸多难题，都会导致开发方式和成本的增加。</li>\n</ul>\n\n\n<p>SPA 传统的实现方式是使用分帧（frameset + frame + iframe），但 URL 不会发生变化，这导致浏览器历史的前进、后退和收藏功能失效，因此在过去，SPA 仅局限于对 URL 不敏感的场合，比如 MIS 系统。</p>\n\n<p>站在攻城师的角度，这种复杂性和局限性不是我们所乐意看到的，谁愿意受无谓的虐待呢？</p>\n\n<p>即使对 Ajax 的发掘也没有让 SPA 真正变得可行，虽然 Ajax 拯救了曾经半死不活的 JavaScript。Ajax 可以实现无刷新加载界面（即动态加载），但同样不能修改 URL，只能通过延迟加载、异步加载等技巧，来减少 HTTP 流量、加速网页打开速度、优化用户体验。</p>\n\n<p>直到对 URL hash（即 location.hash）的挖掘，SPA 才变得切实可行。location.hash 是一个可读写的字符串，指定了当前 URL 中的锚部分，包括前导散列符 #。URL hash 虽然不会在请求时传给服务器，但是在浏览器中，改变 URL hash 却可以支持前进、后退、收藏（在低版本的 IE 中需要通过 iframe 实现）。</p>\n\n<p>hash 驱动正是 Backbone 事件驱动模型中一种，在某些应用中甚至是最重要的一种，此外 Backbone 还有模型事件驱动和视图事件驱动。</p>\n\n<h3>结构化的 Web 应用程序</h3>\n\n<p>个人认为 SPA 最能体现 MVC 设计思想，当然，MVC 也适合应用在由多个页面组成的 Web 应用程序中，以 Backbone 为例，每个页面分别基于 Backbone 的 Model 和 View 进行设计和开发，同样可以增加可复用性、可扩展性、可维护性。</p>\n\n<h3>还不够完美</h3>\n\n<p>模块化、模块依赖、动态载入、模板等概念、库、框架需要去研究和学习，虽然这些已算不得什么新鲜事务，但是如何将各种专注的库、工具、框架无缝集成，变成完整、可靠、稳定、可以高效开发、可以成熟应用的系统解决方案，是目前前端领域需要继续研究和实践的课题。这方面推荐 <a href=\"http://weibo.com/lifesinger\">@玉伯</a> 领导的 <a href=\"http://aralejs.org/\">Arale</a> 项目。</p>\n\n<p>更少的代码、更短的开发周期、更少的 BUG、易读、易维护、易扩展，才是优秀攻城师的追求。</p>\n\n<p>回到本文的主题 MVC，模型与视图的关系在实际应用中的关系可能更加复杂，视图不仅要引用模型，负责渲染、交互，还会涉及模板引擎、数据解析、数据适配等等。</p>\n\n<p>为了更清晰的探讨和分析 JSMVC 的实现，非常必要对 MVC 在 JS 中的职责做一番梳理。</p>\n\n<h2>JSMVC</h2>\n\n<h3>JSMVC 职责划分</h3>\n\n<ul>\n<li><p>M 模型（数据和业务）</p>\n\n<ul>\n<li>业务模型：业务逻辑、流程、状态、规则</li>\n<li>数据模型（核心）：业务数据、数据校验、增删改查（Ajax、RESTful）</li>\n</ul>\n</li>\n<li><p>V 视图（UI）</p></li>\n<li><p>视图（核心）：定义、管理、配置</p></li>\n<li>模板：定义、配置、管理</li>\n<li>组件：定义、配置、管理</li>\n<li>交互事件（核心）：配置、管理</li>\n<li>输入：校验、配置、管理</li>\n<li><p>输出：更新</p></li>\n<li><p>C 控制器/分发器</p>\n\n<ul>\n<li>事件分发（核心）、模型分发、视图分发</li>\n<li>不做数据处理和业务处理，即业务无关</li>\n<li>扩展：权限控制、异常处理等</li>\n<li>C 是 JSMVC 框架的核心，实现集中式配置和管理，并且可以有多个控制器</li>\n</ul>\n</li>\n<li><p>工具库</p>\n\n<ul>\n<li>主要是异步请求、DOM 操作，可以依赖于 jQuery 等库</li>\n</ul>\n</li>\n</ul>\n\n\n<h3>JSMVC 实现探讨</h3>\n\n<p>MVC 的模型 Model、视图 View、控制器 Control 相互独立又相互联系，C 则是作为其中联系的桥梁。</p>\n\n<p>MVC 作为由来已久的成熟开发模型，已有大量经典的实现可供参考，在浏览器和 JS 这个新的特定应用场景中，我们权做如下探索：</p>\n\n<ul>\n<li><strong>M</strong> 模型是自包含的，可以嵌套包含，不会主动引用视图和控制器；可以是简单的 JSON 对象/数组，也可以用组合模式 Composite 实现嵌套包含。</li>\n<li><strong>V</strong> 视图是嵌套包含的，可以用组合 Composite 实现；视图需要引用模型（M-V），一个视图可以引用一个或多个模型，视图会收到模型的通知并自动更新，可以用观察者模式 Observer 实现；视图需要响应用户的交互，可以使用浏览器事件模型实现。</li>\n<li><strong>C</strong> 控制器作为 MVC 框架关注的核心，采取集中配置的策略（V-C）；可以有多个控制器（C + C），用策略模式 Strategy 实现；hash 事件驱动则需要用到浏览器的事件模型。</li>\n</ul>\n\n\n<p>M 模型和 C 控制器之间（M-C）一般我认为是不需要关联的；但是在有的框架中实现了 M 模型和 C 控制器的关联（例如一淘在用的 <a href=\"https://github.com/limu/magix\">Magix</a>），也是一类值得参考和启发的实践。</p>\n\n<h3>事件驱动</h3>\n\n<p>前面的小节中，我们形而上学的从理论上分析了模型 M、视图 V、控制器 C 在 JS 中的职责定位以及它们之间的引用关系，并尝试着用设计模式来探索和诠释 JSMVC 框架的实现思路。</p>\n\n<p>此外，在学习 JSMVC 的过程中，还要认识到 JSMVC 的运行方式是基于事件驱动，这一点非常之重要，本节对在浏览器中可能用到的事件做简练的说明。</p>\n\n<p>在浏览器中，JSMVC 会用到三类事件，分别对应着三种事件驱动方式：</p>\n\n<ol>\n<li><p>hash 事件，即 popstate/hashchange 事件，绑定在 window 对象上，用来驱动控制器。hash 变化触发 popstate/hashchange 事件之后，控制器根据配置找到相应的回调函数并执行；配置是指存有 hash 与回调函数的映射关系的 Map 对象。</p>\n\n<p>这个过程称为“hash驱动控制器”，在 Backbone 中由 Router 和 History 共同实现。</p></li>\n<li><p>DOM 事件，即我们熟知的 click、focus 等浏览器事件，用来响应用户操作、实现交互。DOM 事件被绑定在视图 View上，特别的是 Backbone 提倡采用集中配置的方式，例如下面的代码：</p>\n\n<pre><code>events: {\n    \"click .check\"              : \"toggleDone\",\n    \"dblclick div.todo-text\"    : \"edit\",\n    \"click span.todo-destroy\"   : \"clear\",\n    \"keypress .todo-input\"      : \"updateOnEnter\"\n}\n</code></pre>\n\n<p>这个过程称为“DOM 事件驱动视图“，在 Backbone 中由 View 实现，其中事件的绑定、触发、销毁则依赖于 jQuery 等第三方库。</p></li>\n<li><p>模型事件，包括业务模型事件和数据模型事件，用来驱动模型以及模型集合，实现模型和视图之间的观察者模式。\n这个过程称之为”模型驱动“，在 Backbone 中由 Model、Collection、Event 共同实现。</p></li>\n</ol>\n\n\n<h3>应该关注什么</h3>\n\n<p>框架最应该关注的是控制器 C，部分视图 V。</p>\n\n<p>框架用户则主要关注模型 M 和视图 V，即业务、数据以及展示，并关注模型 M 的复用和视图 V 的变化。</p>\n\n<h2>Backbone</h2>\n\n<h3>Backbone 架构</h3>\n\n<p><img src=\"/project/mvc/Backbone.png\" alt=\"\" /></p>\n\n<h4>参考资料</h4>\n\n<ul>\n<li>基于 <a href=\"https://github.com/documentcloud/backbone/tree/0.9.1\">Backbone 0.9.1</a></li>\n<li><a href=\"http://documentcloud.github.com/backbone/\">官方文档</a></li>\n<li><a href=\"http://www.csser.com/tools/backbone/backbone.js.html\">中文翻译</a></li>\n</ul>\n\n\n<h4>官网介绍</h4>\n\n<p>Backbone 通过提供模型 Model、集合 Collection、视图 View 赋予了 Web 应用程序分层结构。</p>\n\n<p>通过以下方式实现分层结构：</p>\n\n<ul>\n<li>模型 Model 绑定键值数据和自定义事件。</li>\n<li>集合 Colection 是模型的有序或无序集合，带有丰富的可枚举 API。</li>\n<li>视图 View 声明事件监听函数。</li>\n<li>将模型、集合、视图与服务端的 RESTful JSON 接口连接。</li>\n</ul>\n\n\n<h4>自调用匿名函数</h4>\n\n<p>整个 Backbone 的源码用一个自调用匿名函数包裹，通过闭包特性引用变量（例如 previousBackbone、slice、splice 等），同时避免污染全局命名空间。</p>\n\n<p>整体结构如下，还是很清晰的：</p>\n\n<pre><code>(function() {\n    Backbone.Events     // 自定义事件\n    Backbone.Model      // 模型构造函数和原型扩展\n    Backbone.Collection // 集合构造函数和原型扩展\n    Backbone.Router     // 路由配置器构造函数和原型扩展\n    Backbone.History    // 路由器构造函数和原型扩展\n    Backbone.View       // 视图构造函数和原型扩展\n    Backbone.sync       // 异步请求工具方法\n    var extend = function (protoProps, classProps) { ... } // 自扩展函数\n    Backbone.Model.extend = Backbone.Collection.extend = Backbone.Router.extend = Backbone.View.extend = extend; // 自扩展方法\n}).call(this);\n</code></pre>\n\n<h4>依赖库</h4>\n\n<p>Backbone 必须依赖于 Underscore.js，DOM 操作和 Ajax 请求依赖于第三方 jQuery/Zepto/ender 之一，也可以通过方法 <code>Backbone.setDomLibrary( lib )</code> 设置其他的第三方库。</p>\n\n<h4>自定义事件模块 Backbone.Events</h4>\n\n<p>可以和任意对象合体（将方法赋值到其他对象或原型上），合体后的对象支持自定义事件，提供了三个方法来绑定、移除、触发自定义事件：</p>\n\n<pre><code>on(events, callback, context)   // 绑定一个或多个事件回调函数\noff(events, callback, context)  // 移除一个或多个事件回调函数\ntriggle(events)                 // 触发一个或多个事件回调函数\n</code></pre>\n\n<p>方法功能和调用关系如下图所示：</p>\n\n<p><img src=\"/project/mvc/Backbone.Events.png\" alt=\"\" /></p>\n\n<h4>模型 Backbone.Model</h4>\n\n<p>模型是 JavaScript 应用程序的核心，包含了业务数据以及对业务数据的读写和持久化，模型的主要方法包括读写和持久化：</p>\n\n<pre><code>// 初始化\ninitialize()                // 执行构造函数时会被自动调用     \n\n// 读写\n_validate(attrs, options)   // 验证属性集\nhasChanged(attr)            // 判断模块是否改变\nchange(options)             // 手动触发一个change事件\nget(id)                     // 返回一个属性的值\nescape(attr)                // 获取一个属性的HTML转义后的值\nhas(attr)                   // 是否含有某个属性（有效值）\nset(key, value, options)    // 设置或删除模块属性散列表\nunset(attr, options)        // 删除一个属性\nclear(options)              // 清除模块的所有属性\n\n// 持久化\nurl()                       // 模块在服务端对应的URL\nfetch(options)              // 从服务器获取模块\nsave(key, value, options)   // 将模块同步到服务器，create or update\ndestroy(options)            // 在服务器上销毁这个模块\n</code></pre>\n\n<p>支持的事件包括：</p>\n\n<pre><code>change:attr\nchage\nsync\ndestory\nerror\n</code></pre>\n\n<p>方法功能和调用关系如下图所示：</p>\n\n<p><img src=\"/project/mvc/Backbone.Model.png\" alt=\"\" /></p>\n\n<h4>集合 Backbone.Collection</h4>\n\n<p>集合是模型的有序集合，可以在集合上绑定 \"change\" 事件，当集合中的任意模型发生变化时将收到通知，集合也可以监听 \"add\" 和 “remove\" 事件，从服务器获取数据，并能使用 Underscore.js 提供的全套方法。为了方便，在集合中的模型上触发的任何事件都会在集合上直接触发。这样就可以监听集合中模型的指定属性的变化。 例如：Documents.on(\"change:selected\", ...)。</p>\n\n<p>集合的主要方法包括读写、维护和持久化：</p>\n\n<pre><code>// 初始化\ninitialize() // 执行构造函数时会被自动调用\n\n// 读写、维护\nadd(models, options)    // 添加一个一组模型对象到集合中\nremove(models, options) // 从集合中移除一个或一组模型对象\nget(id)                 // 通过id获取模型对象\ngetByCid(cid)           // 通过客户端id返回模型对象\nsort(options)           // 强制集合排序\nreset(models, options)  // 重置整个集合\n_reset(options)         // 重置所有状态\n_prepareModel(model, options) // 创建一个模型，用以添加到这个集合中\n_removeReference(model) // 移除模块与集合的关系\n_onModelEvent(ev, model, collection, options) // 集合中的元素每次触发事件时内部调用的方法\n\n// 持久化\nfetch(options)          // 获取集合的默认模块对象集合\ncreate(model, options)  // 在集合中创意一个新模型实例\nparse(resp, xhr)        // 将响应转换为模型对象列表\n// 其他借用 Underscore 的工具方法，借鸡生蛋\n</code></pre>\n\n<p>支持的事件包括：</p>\n\n<pre><code>add\nremove\nreset\nsync\nerror\n(change:attr, chage, sync, destory)\n</code></pre>\n\n<p>方法功能和调用关系如下图所示：</p>\n\n<p><img src=\"/project/mvc/Backbone.Collection.png\" alt=\"\" /></p>\n\n<h4>路由配置器 Backbone.Router</h4>\n\n<p>Web 应用程序通常需要为重要页面提供可链接、收藏、可分享的 URL。直到最近， 锚文片段（hash #page）可以被用来提供这种固定链接；同时随着 History API 的到来，锚文现在可以用于处理标准 URLs（/page）。</p>\n\n<p>Backbone.Router 为客户端页面路由提供了许多方法，并能连接到指定的动作（actions）和事件（events）。</p>\n\n<p>对于不支持 History API 的旧浏览器（IE6、IE7），路由器提供了优雅的回调函数并可以透明的进行 URL 片段的转换。</p>\n\n<p>页面加载期间，当应用程序已经创建了所有的路由表，需要调用 Backbone.history.start() 或 Backbone.history.start({pushState : true}) 来确保路由初始 URL。</p>\n\n<p>提供了的主要方法有：</p>\n\n<pre><code>initialize()                 // 初始化，执行构造函数时会被自动调用。\nroute(route, name, callback) // 手动绑定一个路由 到 一个回调函数\nnavigate(fragment, options)  // 手动到达应用程序中的某个位置\n_bindRoutes()                // 绑定所有定义的映射关系给Backbone.history\n_routeToRegExp(route)        // 将虚拟URL转换为正则表达式，用于与当前路径的hash部分匹配\n_extractParameters: function(route, fragment) // 正则匹配URL片段fragment，取出其中的参数部分\n</code></pre>\n\n<p>支持的事件包括：</p>\n\n<pre><code>route:name\nroute\n</code></pre>\n\n<h4>路由器 Backbone.History</h4>\n\n<p>作为全局路由器，用于处理 hashchange 或 pushState 事件，匹配适合的路由表，并触发回调函数。</p>\n\n<p>如果使用带有路由表的路由器，会自动创建一个 History 对象，此时，不要再创建一个 History 对象，而是直接使用 Backbone.history。</p>\n\n<p>Backbone 会自动判断浏览器对 pushState 的支持，以做内部的选择。不支持 pushState 的浏览器将会继续使用基于锚点的 URL 片段。</p>\n\n<p>提供的主要方法有：</p>\n\n<pre><code>start(options)              // 开始监听hash变化（绑定popstate事件 或 绑定hashchange事件 或 通过定时器监听hash变化）\nstop()                      // 临时性的停止Backbone.history\nroute(route, callback)      // 添加映射关系\ncheckUrl(e)                 // 检查当前URL是否已改变，如果已改变，调用loadUrl\nloadUrl(fragmentOverride)   // 检查是否有路由匹配\nnavigate(fragment, options) // 保存URL片段到锚文历史（history.replaceState 或 history.pushState 或 location.replace 或 location.hash）\n_updateHash(location, fragment, replace) // 更新锚文路径（location.replace 或 location.hash）\n</code></pre>\n\n<p>方法功能和调用关系如下图所示：</p>\n\n<p><img src=\"/project/mvc/Backbone.Router+History.png\" alt=\"\" /></p>\n\n<h4>视图 Backbone.View</h4>\n\n<p>视图的使用相当方便，不需要判断任何 HTML、CSS，可以和任意 JavaScript 模板引擎集成。</p>\n\n<p>通用的做法是，将界面组织成基于模型的逻辑视图，当模型改变时视图立即更新，而不需要重画整个页面。</p>\n\n<p>不再需要纠结于 JSON 对象、查找 DOM 元素、手动更新 HTML，只需把视图 render 方法绑定到模型的 change 事件，模型数据会立即更新到界面上。</p>\n\n<p>方法功能和调用关系如下图所示：</p>\n\n<p><img src=\"/project/mvc/Backbone.View.png\" alt=\"\" /></p>\n\n<h4>扩展方法 extend</h4>\n\n<p>模型、集合、视图、路由器都含有一个 extend(protoProps, classProps) 方法，用于扩展原型属性和静态属性，创建自定义的视图、集合、视图、路由器类。</p>\n\n<h3>事件 Event - 最佳基友</h3>\n\n<blockquote><p>TODO 概述、使用、流程、事件、源码</p></blockquote>\n\n<h3>模型 Model - 自娱自乐</h3>\n\n<blockquote><p>TODO</p></blockquote>\n\n<h3>集合 Collection - 不是一个人在战斗</h3>\n\n<blockquote><p>TODO</p></blockquote>\n\n<h3>视图 View - 能者多劳</h3>\n\n<blockquote><p>TODO</p></blockquote>\n\n<h3>控制器 Route + History - ？</h3>\n\n<blockquote><p>TODO</p></blockquote>\n\n<h3>Backbone 插件</h3>\n\n<ul>\n<li><a href=\"https://github.com/rotundasoftware/backbone.subviews\">Backbone.Subviews</a>\n\n<ul>\n<li>A minimalist view mixin for creating and managing named subviews (views within views) in your Backbone.js applications.</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/rotundasoftware/backbone.courier\">Backbone.Courier</a>\n\n<ul>\n<li>Easily bubble events (\"messages\") up your view hierarchy in your Backbone.js applications.</li>\n</ul>\n</li>\n</ul>\n\n\n<h3>可以学习的编码技巧 - 上士闻道</h3>\n\n<ol>\n<li>字符串用单引号包裹，提高编码效率（高效）。</li>\n<li>将对象包装成数组，统一处理，砍掉对象，什么都是数组的编程思想（多功能）。</li>\n<li>总是预留一个选项对象，函数根据选项中的属性执行不同的逻辑（可扩展，增加策略）。</li>\n<li>复制选项对象，避免在执行过程中改变选项对象中的属性，影响外围函数的执行逻辑（高内聚）。</li>\n<li>等待策略：决定是立即在浏览器中生效，还是等到服务器响应根据响应结果决定是否生效（便于测试）。</li>\n<li>细致的事件类型：应用开发虽然用不到，但是利于插件或基于 Backbone 开发。</li>\n<li>设计模式：MVC模式、观察者模式。</li>\n</ol>\n\n\n<h3>可以改进或扩展的地方 - 三省她身</h3>\n\n<ol>\n<li>对其他库的依赖：jQuery/Zepto/Ender，Underscore，最讨厌库依赖！</li>\n<li>深受 Rails 的影响，与 MVC 的理解和实现必然有其局限性，不过是一家之言。</li>\n<li>仅仅是对 JSMVC 框架的探索，没有实现诸如嵌套模型、嵌套集合、嵌套视图的管理，虽然有诸多插件，但这又造成更多的依赖，诸多原因局限了它在实际项目中的应用，处于探索不成熟阶段。</li>\n<li>代码行数不多且容易理解，是学习 JSMVC 的很好示例，但是会导致更多的工程师学习并创造自己的 MVC 框架（比如我、我所在的团队），一个不是革命性的框架导致的诸多模仿者，会让 MVC 框架更加泛滥（看看其他语言的发展历史，总是在重复）。</li>\n</ol>\n\n\n<h3>待分类</h3>\n\n<ol>\n<li>使用了大量有副作用的表达式、语句，比如\n 布尔表达式\n 在 if 中调用设置方法</li>\n<li>所有的方法都预留一个 options 对象参数，用于存放可以改变方法行为的参数。</li>\n<li>将工具函数underscore和backbone分离，underscore负责提供基础工具函数，backbone则负责实现MVC框架；这种分离有利于两个库的复用。可以集成第三方库。</li>\n<li>关于回调函数和触发事件的二选一，如果设置回调函数则不触发事件，未设置回调函数才会触发事件；这样会减少重复响应，在框架这一级避免出现这样的bug，更健壮，不会让新手遇到莫名其妙的问题。</li>\n</ol>\n\n\n<h3>Backbone 发布记录</h3>\n\n<ul>\n<li><a href=\"http://backbonejs.org/#changelog\">Backbone Change Log</a></li>\n<li><a href=\"https://github.com/documentcloud/backbone/tags\">Backbone Tags</a></li>\n</ul>\n\n\n<h2>AngularJS</h2>\n\n<h2>Knockout</h2>\n\n<h2>Meteor</h2>\n\n<h2>Ember.js</h2>\n\n<h2>何谈理解</h2>\n\n<p>在很多文章中会提到，学习开源框架最重要的学习它的思想、架构，这应该是最终的目标，也是最初的动机，但这两个境界截然不同。</p>\n\n<p>姑且分为一、二、三层境界，第一层为了解思想架构，第二层为熟读源码细节，深刻体会思想架构；第三层将思想架构融入自己的体系和实践，收为己有运用自如。</p>\n\n<p>大部分源码分析的文章和书籍局限于第一层，可以帮助写出更好的应用。</p>\n\n<p>一小部分工程师会细致的钻研每一行源码，他们更接近框架的本质，学习实现的技巧，抄袭然后美名自创一套。</p>\n\n<p>第三层已经跳出学习既有框架的范畴，本人高度不足没有体会，不想它。</p>\n\n<p>大部分的熟练工停留在第一层，大部分的高手停留在第二层，可怕的不是无知，可怕的意识不到。在你走到更高的层次之前，你不会有更高的觉悟。而这个过程，没有捷径。</p>\n\n<p>不深入何谈理解，引以为戒，与君共勉。</p>\n\n<h2>Backbone 过时了吗？</h2>\n\n<p>不是潮流不一定就是过时。</p>\n\n<h2>修订记录</h2>\n\n<p>版本、日期、编制人、说明、行为、备注</p>\n\n<p><strong>nuysoft 2012-02-18 0.01</strong></p>\n\n<ul>\n<li>文档结构，前言、技巧</li>\n</ul>\n\n\n<p><strong>nuysoft 2013-01-31 0.02</strong></p>\n\n<ul>\n<li>转换为 Markdown 格式</li>\n</ul>\n\n\n<p><strong>nuysoft 2013-03-07 0.03</strong></p>\n\n<ul>\n<li>增加代码块</li>\n<li>美化图片</li>\n</ul>\n\n\n<p><strong>nuysoft 2013-03-21 0.04</strong></p>\n\n<ul>\n<li>校对已有内容</li>\n</ul>\n\n\n<p><strong>nuysoft 2013-03-22 0.05</strong></p>\n\n<ul>\n<li>增加参考资料、参考库&amp;框架</li>\n</ul>\n\n"
            ],
            "link": [
              "http://nuysoft.github.com/2012/03/18/mvc"
            ],
            "guid": [
              "http://nuysoft.github.com/2012/03/18/mvc"
            ],
            "pubDate": [
              "2012-03-18T00:00:00-07:00"
            ]
          },
          {
            "title": [
              "Backbone 0.9.1 源码分析（停止更新）"
            ],
            "description": [
              "\n"
            ],
            "link": [
              "http://nuysoft.github.com/2012/03/14/backbone-091"
            ],
            "guid": [
              "http://nuysoft.github.com/2012/03/14/backbone-091"
            ],
            "pubDate": [
              "2012-03-14T00:00:00-07:00"
            ]
          },
          {
            "title": [
              "jQuery 1.6.1 源码分析系列（停止更新）"
            ],
            "description": [
              "\n"
            ],
            "link": [
              "http://nuysoft.github.com/2011/09/14/jquery161"
            ],
            "guid": [
              "http://nuysoft.github.com/2011/09/14/jquery161"
            ],
            "pubDate": [
              "2011-09-14T00:00:00-07:00"
            ]
          },
          {
            "title": [
              "回忆2009"
            ],
            "description": [
              "<p>早上 7:50 起床，8:05出门，挤5号线，到东单，再步行至王府井的公司，</p>\n\n<p>偶尔也早到，但工作性质所然，还是迟到居多，</p>\n\n<p>刷完卡，就开始一天忙碌的工作了。</p>\n\n<p>上班的大部分时间，我也穿牛仔裤和运动鞋，经常还背个旅行包，</p>\n\n<p>这与王府井富丽堂皇，到处西装革履的浓厚商业味道，格格不入。</p>\n\n<p>候车和乘车时，就从书包里拿出书来看看，</p>\n\n<p>毕业之后，看书多与IT相关，</p>\n\n<p>只是最近一年，看得颇杂，尤好历史，哲学和人物传记；</p>\n\n<p>做了两年软件研发，职业水平越加纯熟，职业的感觉却渐渐淡化，越发像个学者了。</p>\n\n<p>与第一年的初生牛犊，第二年的迷茫和思考，相比如今，更多的是坦然和宁静。</p>\n\n<p>我在计算机上的天赋毋庸置疑，两年下来，工作上，除了加班，并没有给我多余的压力，自己也计划在近两年内，继续深造。</p>\n\n<p>最近搬了家，出五环，楼层不高，晚上也安静，</p>\n\n<p>与在老家上学时住在马路边上，上大学时喧嚣的寝室相比，立水桥的环境，有种身居闹市区，悠然见南山的感觉。</p>\n\n<p>来北京之后，周末大部分时间，是在图书城，找个临窗的位置，席地而坐。</p>\n\n<p>近半年来，安心休息和出去玩玩的时候倒是居多。</p>\n\n<p>晚上回家，活动活动，上不了网，就看会书，差不多，就睡觉了。</p>\n\n<p>就是这样，呵呵，毕竟，生活吗。</p>\n\n<p>2009年 北京</p>\n"
            ],
            "link": [
              "http://nuysoft.github.com/2009/04/02/2009"
            ],
            "guid": [
              "http://nuysoft.github.com/2009/04/02/2009"
            ],
            "pubDate": [
              "2009-04-02T00:00:00-07:00"
            ]
          },
          {
            "title": [
              "回忆198x"
            ],
            "description": [
              "<p>最近的心情有些乱，想写点东西。</p>\n\n<p>小时候好像到过好多地方，从这个村子到那个村子。</p>\n\n<p>不管到哪，很喜欢做的事当中，有一件是顺着下坡路狂奔，呼呼的风声，无法停止的脚步，用现在的词，那叫一爽。在离石住了好像是两年，这是有记忆的最早了，遥远而模糊，依稀记得发大水把小院门口的沟冲的更深以至我矮小的个子不再爬的上来，顺山而下的洪水也冲毁了小院门前的小桥，冲过大路，冲进河里，有一年的洪水里捞到了金鱼，冬天有人到河上凿冰取水，出了院门就是一所小学的侧墙，印象中打扫过小学的院子却记不得我有没有在那上过学，弯着腰，屁股朝天，扫帚从两腿中间玩命的向后扫去，拿个镜子反射太阳光竟然也能把我逗哭，自己做个\"老牛\"比赛爬水泥坡，还赛过\"老婆歪度\"，校门前有几棵桑树，桑星就像串微型葡萄，好吃，在外求学连看都看不到了，夏天时垂下的枝条就成了秋千，逆河而上不远有座小桥，桥附近的枸杞又黑又甜，这些现在都无从寻觅了，最后一次回去时，意外发现了把爸爸为我仿制的枪，能打纸弹，枪柄却有了道裂缝，不懂事，拿个忘了什么东西想修理修理，却砸成了两半，想来真是可惜，然后就再也没回去那个地方了，只是坐车路过的时候，隔着那条河，远远的望着那个没落的村庄，人都搬走了，想着那山那院，那个和我一起喝尿的的孩子，那时爸爸很年轻。</p>\n\n<p>到了外祖母住的村子，就清晰起来了。漫山遍野的果树，很多果实现在都看不到了，住的是窑洞，夏天的中午，端着饭来到一颗杏树下，外祖母的拿手饭是玉米窝窝，有时吃饭时还能看到杏树上小洞里的啄木鸟，我们叫签书嘣嘣，和外祖父比赛吃饭，晚上生堆火驱蚊，我，外祖母，外祖父，有时还有小舅舅，分坐在两条石板凳上，对着对面山上的星星灯火，人都搬到对面山上了，这边这座山就我外祖父一家，远处的古塔孤独的站着，塔下是凄凉的寺庙遗址，文化大革命时荒废的，窑洞是不能回去的，打了敌敌畏。冬日的早上，泥土冻的硬梆梆的，翻过一个土丘，绕过一个山沟，去最近的人家去玩，放假时这户人家的孩子都回来了，很热闹，再远些还有个家族，有马棚，有石磨，小孩子还留辫子。</p>\n\n<p>中午差不多就原路返回吃饭，泥化了，一路磨蹭，到家时鞋上还裹层稀泥。</p>\n\n<p>山里人注定了要穷困一生，因为只能种地。早上吃完饭，带点馒头窝窝什么的，再灌壶稀饭，就上路了，一种种一天，日出而做，日落而息。翻过一个大大的山沟，是外祖母家的地，我帮些小忙，中午吃饭的时候，我还加个鸡蛋，自己家鸡生的，火柴盒里装着盐，可以蘸着吃。有一天雨来的突然，山坡太滑，牛下不了山。后来有一年老天不下雨，种的苗子都枯了，山民们筹款杀了只猪，祭神求雨，当天晚上，雨下得非常大，几座山上人头篡动，人们大声的呼喊着，一场救命的雨。炎热的夏天，泡在河水里，彻头彻尾的清凉，累了，就用水浇浇河边的大岩石，爬上去，躺着，JJ朝天，一帮光P小孩就这么躺着晒太阳。。。。。</p>\n\n<p>这个山沟里住着很多我的长辈，外祖母，外祖父，还有老姑，剩下的连名都记不住了，老姑很慈祥，最后一次见她时是在秋天的晚上，躺在炕上，盖着厚厚的被子，瘫痪了，孤零零的，窑洞里就她一个人，孤独而凄凉</p>\n\n<p>童年一半的记忆在这个山沟里。</p>\n\n<p>起风了，院子里的槐树唰唰的响，我拿个小竹筐，跑到杏树下，捡回刚刚吹落的杏子；松鼠翘着大大的尾巴，在石墙上蹦着，我那拿起土块满地砸，它偷粮食；石墙外墙角长着些杂草，意外的发现了在离石玩过的一种植物，把它的种子放到手心，然后对着种子说＃￥％……※（忘了），种子就会动，神奇吧；在杂草下的土壤里，我挖出了一枚铜钱，比见过的都小，深黄色，看着特别精巧，那几天死了个人，灵台搭在院子，没有点灯的，就把我的铜钱拿去了，小碗里放着半碗油，铜钱漂在上面，芯穿过钱眼，一头浸在油里，一头被点着了，日夜都亮着，等丧事完了，我的钱也不见了，再挖，什么也没出；钻进玉米地里，把杆一折，边咬边吮吸断口，隔天就有个大爷在地里骂；往灶里放柴的时候不老实，一不小心，一根玉米秆弹了出来，弹在了脸上，右边的眉毛焦了大半，报复我；沟里什么都没，自己做象棋，做摘枣的钩子；天黑了，外祖母对着蝙蝠说，这些鸟儿找不到回家的路了。。。。。。</p>\n\n<p>2006年 天津</p>\n"
            ],
            "link": [
              "http://nuysoft.github.com/2006/09/20/2006"
            ],
            "guid": [
              "http://nuysoft.github.com/2006/09/20/2006"
            ],
            "pubDate": [
              "2006-09-20T00:00:00-07:00"
            ]
          }
        ]
      }
    ]
  }
}