{
  "feed": {
    "$": {
      "xmlns": "http://www.w3.org/2005/Atom"
    },
    "title": [
      {
        "_": "博客园_紫云飞",
        "$": {
          "type": "text"
        }
      }
    ],
    "subtitle": [
      {
        "$": {
          "type": "text"
        }
      }
    ],
    "id": [
      "uuid:87b278c6-621a-444d-a3f2-f7cf745b0d4c;id=3988"
    ],
    "updated": [
      "2013-08-15T07:35:45Z"
    ],
    "author": [
      {
        "name": [
          "紫云飞"
        ],
        "uri": [
          "http://www.cnblogs.com/ziyunfei/"
        ]
      }
    ],
    "generator": [
      "feed.cnblogs.com"
    ],
    "entry": [
      {
        "id": [
          "http://www.cnblogs.com/ziyunfei/p/3256116.html"
        ],
        "title": [
          {
            "_": "[译]ES6新特性:八进制和二进制整数字面量 - 紫云飞",
            "$": {
              "type": "text"
            }
          }
        ],
        "summary": [
          {
            "_": "原文:http://whereswalden.com/2013/08/12/micro-feature-from-es6-now-in-firefox-aurora-and-nightly-binary-and-octal-numbers/几年前,当SpiderMonkey实现了严格模式的时候.我了解到,严格模式禁用了八进制整数字面量的写法.因为有证据表明,一些新手会利用前导0来对齐多行中的数字,从而导致意想不到的结果:var sum = 015 + // 相当于十进制的13,而不是15 197 + 001; // 反正是1console.log(su...",
            "$": {
              "type": "text"
            }
          }
        ],
        "published": [
          "2013-08-14T02:20:00Z"
        ],
        "updated": [
          "2013-08-14T02:20:00Z"
        ],
        "author": [
          {
            "name": [
              "紫云飞"
            ],
            "uri": [
              "http://www.cnblogs.com/ziyunfei/"
            ]
          }
        ],
        "link": [
          {
            "$": {
              "rel": "alternate",
              "href": "http://www.cnblogs.com/ziyunfei/p/3256116.html"
            }
          },
          {
            "$": {
              "rel": "alternate",
              "type": "text/html",
              "href": "http://www.cnblogs.com/ziyunfei/p/3256116.html"
            }
          }
        ],
        "content": [
          {
            "_": "<p>原文:<a href=\"http://whereswalden.com/2013/08/12/micro-feature-from-es6-now-in-firefox-aurora-and-nightly-binary-and-octal-numbers/\" target=\"_blank\">http://whereswalden.com/2013/08/12/micro-feature-from-es6-now-in-firefox-aurora-and-nightly-binary-and-octal-numbers/</a></p><hr /><p>几年前,当SpiderMonkey实现了严格模式的时候.我<a href=\"https://hacks.mozilla.org/2011/01/ecmascript-5-strict-mode-in-firefox-4/\" target=\"_blank\">了解到</a>,严格模式禁用了八进制整数字面量的写法.因为有证据表明,一些新手会利用前导0来对齐多行中的数字,从而导致意想不到的结果:</p><div style=\"background-color: #F5F5F5;border: 1px solid #CCCCCC;padding:10px;\"><span style=\"color: #0000ff;\">var</span> sum = 015 +  <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\"> 相当于十进制的13,而不是15</span><br/>          197 +<br/>          001;   <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\"> 反正是1</span><br/>console.log(sum) <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\"> 相加得到的和是211,而不是新手认为的213</span></div><p>但是仍有一些开发者们需要八进制整数(尤其是那些Mozilla扩展开发者和node.js开发者),最常见的就是用在处理文件权限(755,644这些)的时候.因此,<abbr title=\"ECMAScript, 6th edition\">ES6</abbr>又增加了一种新的八进制整数字面量写法.和十六进制的<code>0x</code>或<code>0X类似,新的八进制整数使用</code><code>0o或</code><code>0O作为前导标识,后面跟若干个八进制的数字字符(0到7)</code>,这种写法就不会再困扰新手了:</p><div style=\"background-color: #F5F5F5;border: 1px solid #CCCCCC;padding:10px;\"><span style=\"color: #0000ff;\">var</span> DEFAULT_PERMS = 0o644; <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\"> 严格模式下也可用</span></div><p><code><span>值得注意的一点是,</span>0O前缀</code>的可读性太差了(0和大写的O长的太像了,很难区分),我在esdiscuss上提出了<a href=\"http://esdiscuss.org/topic/is-it-really-a-good-idea-for-octal-numbers-to-allow-capital-o-e-g-0o755\" target=\"_blank\">这个问题</a>,希望能禁用掉大写的0O前缀,不过TC39目前的决定还是认为一致性应该大于可读性(一致性指的是要和0X以及0B等一致).我认为这个决定是值得商榷的,我推荐你永远不要使用大写的0O.</p><p>另外,一些开发者们还需要二进制的整数字面量写法,这种写法ECMAScript从来没有支持过.ES6支持了这种写法,和八进制以及十六进制类似,使用0b或0B前缀:</p><div style=\"background-color: #F5F5F5;border: 1px solid #CCCCCC;padding:10px;\"><span>var</span> FLT_SIGNBIT  =<span> 0b10000000000000000000000000000000;<br/></span><span>var</span> FLT_EXPONENT =<span> 0b01111111100000000000000000000000;<br/></span><span>var</span> FLT_MANTISSA = 0b00000000011111111111111111111111;</div><p>目前<a href=\"http://www.mozilla.org/en-US/firefox/aurora/\" target=\"_blank\">Firefox Aurora</a>已经实现了这两个语法,如果你更富有冒险精神,还可以使用更新的<a href=\"http://nightly.mozilla.org/\" target=\"_blank\">Firefox Nightly</a>.</p><img src=\"http://counter.cnblogs.com/blog/rss/3256116\" width=\"1\" height=\"1\" alt=\"\"/><br/><p>本文链接：<a href=\"http://www.cnblogs.com/ziyunfei/p/3256116.html\" target=\"_blank\">http://www.cnblogs.com/ziyunfei/p/3256116.html</a>，转载请注明。</p>",
            "$": {
              "type": "html"
            }
          }
        ]
      },
      {
        "id": [
          "http://www.cnblogs.com/ziyunfei/p/3202281.html"
        ],
        "title": [
          {
            "_": "[译]学习HTTP协议的请求行 - 紫云飞",
            "$": {
              "type": "text"
            }
          }
        ],
        "summary": [
          {
            "_": "原文:http://fiddler2.com/blog/blog/2013/02/13/understanding-the-request-line最近有一位Fiddler用户问我一个问题:我在使用Fiddler查看HTTP请求的时候发现Raw和HexView两个面板中显示的数据有点小区别,比如当我请求www.microsoft.com时,Raw面板中的数据是这样的: GEThttp://www.microsoft.com/ HTTP/1.1 ... Host: www.microsoft.com而HexView面板中是这样的: GET / HTTP/1.1 ... Host: www.mic",
            "$": {
              "type": "text"
            }
          }
        ],
        "published": [
          "2013-07-21T05:21:00Z"
        ],
        "updated": [
          "2013-07-21T05:21:00Z"
        ],
        "author": [
          {
            "name": [
              "紫云飞"
            ],
            "uri": [
              "http://www.cnblogs.com/ziyunfei/"
            ]
          }
        ],
        "link": [
          {
            "$": {
              "rel": "alternate",
              "href": "http://www.cnblogs.com/ziyunfei/p/3202281.html"
            }
          },
          {
            "$": {
              "rel": "alternate",
              "type": "text/html",
              "href": "http://www.cnblogs.com/ziyunfei/p/3202281.html"
            }
          }
        ],
        "content": [
          {
            "_": "<p class=\"p1\">原文:<a href=\"http://fiddler2.com/blog/blog/2013/02/13/understanding-the-request-line\" target=\"_blank\">http://fiddler2.com/blog/blog/2013/02/13/understanding-the-request-line</a></p><hr /><p class=\"p1\">最近有一位Fiddler用户问我一个问题:</p><blockquote><p class=\"p3\">我在使用Fiddler查看HTTP请求的时候发现Raw和HexView两个面板中显示的数据有点小区别,比如当我请求www.microsoft.com时,Raw面板中的数据是这样的:</p><p class=\"p4\">&nbsp;&nbsp;&nbsp; GET&nbsp;<span class=\"s1\"><strong>http://www.microsoft.com</strong></span>/ HTTP/1.1<br />&nbsp;&nbsp;&nbsp; ...<br />&nbsp;&nbsp;&nbsp; Host: www.microsoft.com</p><p class=\"p3\">而<span>HexView面板中是这样的</span>:</p><p class=\"p4\">&nbsp;&nbsp;&nbsp; GET / HTTP/1.1<br />&nbsp;&nbsp;&nbsp; ...<br />&nbsp;&nbsp;&nbsp; Host: www.microsoft.com</p><p class=\"p3\">为什么请求行(Request Line)中的文本不一样?我还发现如果我使用socket<span>直接发送这样一个使用绝对路径的</span>GET请求<span>(不经过Fiddler)</span>,一些服务器会返回错误信息.</p></blockquote><p class=\"p1\">原理是这样的.当客户端比如浏览器认为自己在向一个代理服务器发送HTTP请求时,它会在请求行中使用绝对路径的URL.如果它认为自己在向目标服务器直接发送请求,则请求行中只会包含相对路径的URL(完整URL的path部分).这正是遵循了<span class=\"s2\"><a href=\"http://www.ietf.org/rfc/rfc2616.txt\" target=\"_blank\">RFC2616 (5.1.2小节)</a>标准</span>的规定.遵照标准,服务器必须能正确解析这两种形式的请求行.但正如上面问题中提到的,有些服务器不能正确解析请求行中包含绝对路径的情况,会返回HTTP/4xx或者HTTP/5xx错误.</p><p class=\"p1\">提问者遇到的情况,正是浏览器向Fiddler发送了请求行为<strong>GET</strong> <strong>http://www.microsoft.com/</strong> <strong>HTTP/1.1</strong>的请求(因为Fiddler也是个代理),然后Fiddler将其中的请求行改写成了<strong>GET</strong> <strong>/ HTTP/1.1</strong>,再发送给服务器.</p><p class=\"p1\">Fiddler的检查器(Inspector)中的各个面板能够自由选择在请求行中显示绝对路径还是相对路径,每种选择都有各自的好处.显示绝对路径能够让用户更方便的查看,修改(需要开启Unlock for editing),以及链接化请求地址(Raw面板中),而显示相对路径更符合实际情况,因为Fiddler发送给服务器的请求最终都是使用相对路径的.</p><blockquote><p class=\"p1\">译者注:在最新的Fiddler版本中,不管Fiddler接受到的请求中的请求行使用绝对路径还是相对路径,Fiddler都会在各个面板中显示绝对路径(也就是说提问中两个面板显示数据不同的这个表现已经不存在了),而发送的真实数据会使用相对路径.</p><p class=\"p1\">总结一下就是,Fiddler中看到的请求数据并不一定是客户端发送的真实数据,<span>Fiddler最后发送的请求数据也不一定是你在<span>Fiddler中看到的那样.</span></span></p><p class=\"p1\"><span><span>有些情况下,我们需要看到客户端发送的真实的请求数据,一点也不能经过篡改.我们就得使用真正的抓包软件,而不是代理,比如SmartSniff.</span></span></p><p class=\"p1\"><span>有些情况下,我们希望我们构造的HTTP请求不经任何修改的发送给服务器,这时就不能使用Fiddler自带的composer了,你可以<a href=\"http://sony-soft.iteye.com/blog/1654252\" target=\"_blank\">使用命令行的telnet程序</a>,还可以使用我自己写的一个小工具,叫<a href=\"http://files.cnblogs.com/ziyunfei/HRB.zip\">HTTP Request Builder</a>.这个工具的特点是,请求数据使用socket直接发送(没有使用.net中更高级的封装类).因此就不会有任何的格式限制和异常捕获,你甚至可以去谷歌的主机上请求百度的网站,想要的却是淘宝首页:<br /></span></p><p class=\"p1\">&nbsp;<img src=\"http://images.cnitblog.com/blog/116671/201307/21120712-26761aee4cce41558a9e6a9265d18292.png\" alt=\"\" /></p><p class=\"p1\">&nbsp;使用这个工具,可以验证一下原文中所说的Fiddler是否的确会修改请求行中的URL,可以这样构造请求:</p><p class=\"p1\"><img src=\"http://images.cnitblog.com/blog/116671/201307/21121047-edb9b2ec17494508a8dfb0fe9920384f.png\" alt=\"\" /></p><p class=\"p1\">&nbsp;之后在Fiddler中的<span>Raw和HexView两个面板中看看,都是绝对URL.</span></p><p class=\"p1\"><span><img src=\"http://images.cnitblog.com/blog/116671/201307/21032321-9a88e48ddfdd41f093443d97e7d04fd1.png\" alt=\"\" />&nbsp; <img src=\"http://images.cnitblog.com/blog/116671/201307/21123757-57b973b640d1482481d63793306b966a.png\" alt=\"\" /></span></p><p class=\"p1\"><span>而在抓包软件中看到的,也就是Fiddler真正发送出去的请求,是篡改后的相对URL.</span></p><p class=\"p1\"><img src=\"http://images.cnitblog.com/blog/116671/201307/21124044-0ee1ed5af092429eaf49aa0419f3d50e.png\" alt=\"\" /></p></blockquote><img src=\"http://counter.cnblogs.com/blog/rss/3202281\" width=\"1\" height=\"1\" alt=\"\"/><br/><p>本文链接：<a href=\"http://www.cnblogs.com/ziyunfei/p/3202281.html\" target=\"_blank\">http://www.cnblogs.com/ziyunfei/p/3202281.html</a>，转载请注明。</p>",
            "$": {
              "type": "html"
            }
          }
        ]
      },
      {
        "id": [
          "http://www.cnblogs.com/ziyunfei/p/3183325.html"
        ],
        "title": [
          {
            "_": "[译]JavaScript源码转换:非破坏式与再生式 - 紫云飞",
            "$": {
              "type": "text"
            }
          }
        ],
        "summary": [
          {
            "_": "原文:http://ariya.ofilabs.com/2013/06/javascript-source-transformation-non-destructive-vs-regenerative.html很多的JavaScript工具都需要对JavaScript源码进行转换,包括压缩器(minifier)和转译器(transpiler).这些工具所使用的转换的技术可以分为两种:对源码进行非破坏式的(non-destructive)修改和从语法树完全再生(full regeneration)出新的源码.这两种技术服务于不同的需求,且往往是相辅相成的.无论选择哪种技术,输入的源码都需要先被解",
            "$": {
              "type": "text"
            }
          }
        ],
        "published": [
          "2013-07-15T03:14:00Z"
        ],
        "updated": [
          "2013-07-15T03:14:00Z"
        ],
        "author": [
          {
            "name": [
              "紫云飞"
            ],
            "uri": [
              "http://www.cnblogs.com/ziyunfei/"
            ]
          }
        ],
        "link": [
          {
            "$": {
              "rel": "alternate",
              "href": "http://www.cnblogs.com/ziyunfei/p/3183325.html"
            }
          },
          {
            "$": {
              "rel": "alternate",
              "type": "text/html",
              "href": "http://www.cnblogs.com/ziyunfei/p/3183325.html"
            }
          }
        ],
        "content": [
          {
            "_": "<p class=\"lead\">原文:<a href=\"http://ariya.ofilabs.com/2013/06/javascript-source-transformation-non-destructive-vs-regenerative.html\" target=\"_blank\">http://ariya.ofilabs.com/2013/06/javascript-source-transformation-non-destructive-vs-regenerative.html</a></p><hr /><p class=\"lead\">很多的JavaScript工具都需要对JavaScript源码进行转换,包括压缩器(minifier)和转译器(transpiler).这些工具所使用的转换的技术可以分为两种:对源码进行非破坏式的(non-destructive)修改和从语法树完全再生(full regeneration)出新的源码.这两种技术服务于不同的需求,且往往是相辅相成的.</p><p>无论选择哪种技术,输入的源码都需要先被解析.这项任务可以交给一个解析器(比如<a href=\"http://esprima.org/\" target=\"_blank\">Esprima</a>)来做.之后,再对解析器生成的语法树进行两种不同的操作,如下图所示:</p><p><img src=\"http://images.cnitblog.com/blog/116671/201307/11104428-01eb0c154243459080ab00660b6231fb.png\" alt=\"\" width=\"625\" /></p><p>如果使用非破坏式的修改,则我们需要利用语法树中相关语法节点(<span>syntax node</span>)和词法单元(tokens)的位置信息来计算出应该在输入源码的哪段位置处进行修改.举个简单的例子,就是把源码中字符串两边的<a href=\"http://www.cnblogs.com/ziyunfei/p/3184248.html\" target=\"_blank\">双引号转换成单引号</a>(或者反或来):通过定位字符串字面量,我们就能知道引号的具体位置,从而能够对这个引号进行原位替换(in-place replacement),注意字符串本身的内容可能需要转义,因为其中可能包含引号.</p><p>完全再生的方式可以用在语法转译(<span>syntax transpilation</span>)的需求中.比如,如果我们现在就想使用上ECMAScript 6中的块级作用域(block scope)特性,则我们需要对自己写的代码进行转换(已经有了现成的<a href=\"https://github.com/olov/defs\" target=\"_blank\">defs.js</a>),让输出的代码能够正确的运行在目前更通用的ECMAScript 5环境中.具体要做的就是将<code>let声明语句转换成等效的</code><code>var语句</code>(主要考虑如何对变量的作用域进行限制).</p><p>非破坏式转换的优点是,我们不会丢失那些输入源码中与语法无关且不影响程序执行但也有必要保留的那部分代码.比如,在将双引号转换成单引号这一需求中,所有已有的缩进,注释等应当被完全保留.非破坏式转换工具只对它感兴趣的部分代码做修改,其他的所有代码都应该保持完全不变.</p><p>但如果我们想要编写的这个工具不需要保留输入源码中的注释和缩进,则完全扔掉原始代码,根据语法树生成一份新源码的方式会更简单点.比如,一个压缩器生成的源码从语义上要完全等同于输入源码,只是少了额外的空白,就应该使用完全再生的方式.另外现在大部分高级压缩器还会去做一些缩短变量名,移除无用代码的一些处理,因为这些处理能让代码变的更短.</p><blockquote><p>译者注:目前比较有名的三个压缩器<span>YUI Compressor, Closure Compiler, UglifyJS都是使用再生的方式生成源码的.不过前两者使用的解析器是Mozilla的<span>Rhino(Java编写),后者使用的解析器是<span>parse-js(JavaScript编写).</span></span></span></p><p><span><span><span>Esprima作为目前最好的js parser in js,怎么会没有基于<span>Esprima的压缩器呢.于是我咨询了本文的作者,也就是Esprima的作者,他让我看看<a href=\"http://aosd.net/2013/escodegen.html\" target=\"_blank\">Escodegen和Esmangle</a>.其中,Escodegen是一个代码生成器,可以把AST转换成JavaScript代码,刚好干了和解析器相反的工作,这里有一个<a href=\"http://constellation.github.io/escodegen/demo/index.html\" target=\"_blank\">demo</a>.Esmangle是一个压缩器,但它和其他的压缩器不同,它的输入是解析器生成的AST,返回的是压缩过的AST,也就是说Esprima +&nbsp;<span>Esmangle +&nbsp;Escodegen配合在一起,才能算是完整的JavaScript代码压缩器,这里有一个<a href=\"http://esprima.org/demo/minify.html\" target=\"_blank\">demo</a>.</span></span></span></span></span></p></blockquote><p>如果要做代码覆盖率分析,则<span>代码插装</span>(code instrumentation)是最重要的一步操作.一个代码覆盖率工具比如<a title=\"JavaScript Code Coverage with Istanbul\" href=\"http://ariya.ofilabs.com/2012/12/javascript-code-coverage-with-istanbul.html\" target=\"_blank\">Istanbul</a>会把它的插装代码(instrumentation code)包装在目标代码的每个语法节点上.通过这种方式,就可以跟踪到那些真正被JavaScript引擎执行过的语句和代码分支了.这样的插装器(instrumenter)也是代码再生技术的又一个用武之地.在代码插装完毕之后,新生成的代码马上就要被解释器执行了,也就没有人会去关心代码长什么样,有没有缩进等外观方面的事情了.</p><blockquote><p>译者注:<span>讲一个我自己的真实案例,情节稍有简化.就是在公司的项目中,需要在js文件中拼接mastache模板字符串,像这样</span></p><div style=\"background-color: #F5F5F5;border: 1px solid #CCCCCC;padding:10px;\"><span style=\"color: #0000ff;\">var</span> template = <br />'&lt;ul&gt;' +<br/>    '{{#list}}' +<br />    '&lt;li&gt;' +<br />　　    '{{value}}' +<br />　　 '&lt;/li&gt;' +<br/>    '{{/list}}' +<br />'&lt;/ul&gt;' + <br />......</div><p>显然,这种写法可维护性不好.于是我想出了一种解决办法,就是利用提取函数多行注释来实现多行字符串.像这样</p><div style=\"background-color: #F5F5F5;border: 1px solid #CCCCCC;padding:10px;\"><span style=\"color: #0000ff;\">var</span> template = heredoc(<span style=\"color: #0000ff;\">function</span>(){<span style=\"color: #008000;\">/*</span><span style=\"color: #008000;\"><br/>&lt;ul&gt;<br/>    {{#list}}<br/>    &lt;li&gt;<br/>        {{value}}<br/>    &lt;/li&gt;<br/>    {{/list}}<br/>&lt;/ul&gt;<br />......<br/></span><span style=\"color: #008000;\">*/</span>})</div><p>两种写法下template的值应该是一样的.heredoc是一个工具函数,负责从参数函数的source里提取出多行注释作为字符串,怎么实现的我这里就不说了.</p><p>重点是,在发布的时候,这样的代码会经过UglifyJS的压缩.注释被删除,程序错误,这是可以预料到的.于是我写了一个node脚本,负责在发布的时候把所有js文件中的heredoc函数的调用转换成单行的字符串,转换之后的代码就变成了</p><div style=\"background-color: #F5F5F5;border: 1px solid #CCCCCC;padding:10px;\"><span style=\"color: #0000ff;\">...... <br />var</span> template = '&lt;ul&gt;{{#list}}&lt;li&gt;{{value}}&lt;/li&gt;{{/list}&lt;/ul&gt;'<br />......</div><p>省略号代表了其他部分的代码,是不会有任何修改的.下一步再交给UglifyJS压缩,这样就没问题了.</p><p><span>这个node脚本是怎么写的,我正是用到了本文中所讲的非破坏式修改源码的技术,使用的解析器是Esprima.其代码比起双引号转单引号的那个例子要复杂一些,只遍历tokens数组是不够的,需要遍历整棵语法树以及comments数组.完整的代码如下</span></p><div style=\"background-color: #F5F5F5;border: 1px solid #CCCCCC;padding:10px;\"><span style=\"color: #0000ff;\">var</span> fs = require(\"fs\"<span style=\"color: #000000;\">);<br/></span><span style=\"color: #0000ff;\">var</span> path = process.argv[2<span style=\"color: #000000;\">];<br/></span><span style=\"color: #0000ff;\">var</span> esprima = require(\"esprima\"<span style=\"color: #000000;\">);<br/></span><span style=\"color: #0000ff;\">var</span> source = fs.readFileSync(path, \"utf-8\"<span style=\"color: #000000;\">);<br/></span><span style=\"color: #0000ff;\">var</span> ast = esprima.parse(source, {  <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">将源码解析成ast</span><br/>    comment: <span style=\"color: #0000ff;\">true</span>,  <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">把所有的注释节点放到ast.comments数组内</span><br/>    range: <span style=\"color: #0000ff;\">true</span>         <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">输出所有语法节点的位置信息</span><br/><span style=\"color: #000000;\">});<br/></span><span style=\"color: #0000ff;\">var</span> collectedDatas =<span style=\"color: #000000;\"> [];<br/>JSON.stringify(ast, </span><span style=\"color: #0000ff;\">function</span> (key, value) {  <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">遍历所有的语法节点,找到heredoc的函数调用,抽取出多行注释</span><br/>    <span style=\"color: #0000ff;\">if</span> (value &amp;&amp; value.type === \"CallExpression\" &amp;&amp; value.callee.name === \"heredoc\" &amp;&amp; value.arguments.length === 1 &amp;&amp; value.arguments[0].type === \"FunctionExpression\" &amp;&amp; value.arguments[0].body.body.length === 0) { <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">找到heredoc函数调用,且参数必须是一个不包含任何语句的空函数</span><br/>        <span style=\"color: #0000ff;\">var</span> heredocCallExpression =<span style=\"color: #000000;\"> value;<br/>        </span><span style=\"color: #0000ff;\">var</span> blockStatementRange = heredocCallExpression.arguments[0<span style=\"color: #000000;\">].body.range;<br/>        </span><span style=\"color: #0000ff;\">var</span> blockStatementSource = source.slice(blockStatementRange[0] + 1, blockStatementRange[1] - 1<span style=\"color: #000000;\">);<br/>        </span><span style=\"color: #0000ff;\">var</span> offsetLeft = blockStatementSource.match(/^\\s*/)[0<span style=\"color: #000000;\">].length;<br/>        </span><span style=\"color: #0000ff;\">var</span> offsetRight = blockStatementSource.match(/\\s*$/)[0<span style=\"color: #000000;\">].length;<br/>        </span><span style=\"color: #0000ff;\">var</span> commentRange = [blockStatementRange[0] + offsetLeft + 1, blockStatementRange[1] - offsetRight - 1]; <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">假设这个空函数只包含一个多行注释,计算出该注释的位置信息</span><br/>        ast.comments.some(<span style=\"color: #0000ff;\">function</span> (comment) { <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">和解析出来的comments数组做对比,如果有相同位置信息的,则说明已经正确定位到了一个约定好的多行字符串写法</span><br/>            <span style=\"color: #0000ff;\">if</span> (comment.range[0] == commentRange[0] &amp;&amp; comment.range[1] == commentRange[1<span style=\"color: #000000;\">]) {<br/>                </span><span style=\"color: #0000ff;\">var</span> commentSourceRange = [commentRange[0] + 2, commentRange[1] - 2<span style=\"color: #000000;\">];<br/>                </span><span style=\"color: #0000ff;\">var</span> commentSource = source.slice(commentSourceRange[0], commentSourceRange[1<span style=\"color: #000000;\">]);<br/>                </span><span style=\"color: #0000ff;\">var</span> escapedCommentSource = (\"'\" + commentSource.replace(/(?=\\\\|')/g, \"\\\\\") + \"'\").replace(/\\s*^\\s*/mg, \"\"<span style=\"color: #000000;\">);<br/>                collectedDatas.push({<br/>                    range: heredocCallExpression.range,<br/>                    replaceString: escapedCommentSource<br/>                });<br/>            }<br/>        });<br/>    }<br/>    </span><span style=\"color: #0000ff;\">return</span><span style=\"color: #000000;\"> value;<br/>})<br/></span><span style=\"color: #0000ff;\">for</span> (<span style=\"color: #0000ff;\">var</span> i = collectedDatas.length - 1; i &gt;= 0; i--) { <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">从后往前修改输入源码,就可以不用考虑偏移量的问题了</span><br/>    <span style=\"color: #0000ff;\">var</span> range =<span style=\"color: #000000;\"> collectedDatas[i].range;<br/>    </span><span style=\"color: #0000ff;\">var</span> replaceString =<span style=\"color: #000000;\"> collectedDatas[i].replaceString;<br/>    source </span>= source.slice(0, range[0]) + replaceString + source.slice(range[1<span style=\"color: #000000;\">]);<br/>}<br/>fs.writeFileSync(path, source, </span>\"utf-8\");  <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">将修改后的源码写回源文件</span></div>还有个浏览器中的demo<script type=\"text/javascript\">// <![CDATA[document.write('<table style=\"border:0\"><tbody><tr><td style=\"border:0\"><textarea id=\"input\" style=\"width: 400px; height: 165px;\">var template = heredoc(function(){/*\\n<ul>\\n    {{#list}}\\n    <li>\\n        {{value}}\\n    </li>\\n    {{/list}}\\n</ul>\\n*/})</textarea></td><td style=\"border:0\"><textarea id=\"output\" style=\"width: 400px; height: 165px;\"></textarea></td></tr></tbody></table>');$.getScript(\"http://files.cnblogs.com/ziyunfei/esprima.js\", function () {  $(\"#input\").on(\"input\", function () {    try {      var source = this.value;      var ast = esprima.parse(source, {        comment: true,        range: true      });      var collectedDatas = [];      var offset = 0;      JSON.stringify(ast, function (key, value) {        if (value && value.type === \"CallExpression\" && value.callee.name === \"heredoc\" && value.arguments.length === 1 && value.arguments[0].type === \"FunctionExpression\" && value.arguments[0].body.body.length === 0) {          var heredocCallExpression = value;          var blockStatementRange = heredocCallExpression.arguments[0].body.range;          var blockStatementSource = source.slice(blockStatementRange[0] + 1, blockStatementRange[1] - 1);          var offsetLeft = blockStatementSource.match(/^\\s*/)[0].length;          var offsetRight = blockStatementSource.match(/\\s*$/)[0].length;          var commentRange = [blockStatementRange[0] + offsetLeft + 1, blockStatementRange[1] - offsetRight - 1];          ast.comments.some(function (comment) {            if (comment.range[0] == commentRange[0] && comment.range[1] == commentRange[1]) {              var commentSourceRange = [commentRange[0] + 2, commentRange[1] - 2];              var commentSource = source.slice(commentSourceRange[0], commentSourceRange[1]);              var escapedCommentSource = (\"'\" + commentSource.replace(/(?=\\\\|')/g, \"\\\\\") + \"'\").replace(/\\s*^\\s*/mg, \"\");              collectedDatas.push({                range: heredocCallExpression.range,                replaceString: escapedCommentSource              });            }          });        }        return value;      })      for (var i = collectedDatas.length - 1; i >= 0; i--) {        var range = collectedDatas[i].range;        var replaceString = collectedDatas[i].replaceString;        source = source.slice(0, range[0] + offset) + replaceString + source.slice(range[1] + offset);      }      $(\"#output\").val(source);    } catch (error) {      $(\"#output\").val(error);    }  }).trigger(\"input\");});// ]]></script></blockquote><img src=\"http://counter.cnblogs.com/blog/rss/3183325\" width=\"1\" height=\"1\" alt=\"\"/><br/><p>本文链接：<a href=\"http://www.cnblogs.com/ziyunfei/p/3183325.html\" target=\"_blank\">http://www.cnblogs.com/ziyunfei/p/3183325.html</a>，转载请注明。</p>",
            "$": {
              "type": "html"
            }
          }
        ]
      },
      {
        "id": [
          "http://www.cnblogs.com/ziyunfei/p/3187867.html"
        ],
        "title": [
          {
            "_": "[译]ES6中的代理对象 - 紫云飞",
            "$": {
              "type": "text"
            }
          }
        ],
        "summary": [
          {
            "_": "原文:http://ariya.ofilabs.com/2013/07/es6-and-proxy.html能够拦截在一个对象上的指定操作的能力是非常有用的,尤其是在故障调试的时候.通过ECMAScript 6中的新特性——代理(proxy),这种能力才最终得以实现.在目前最新的ES6规范草案中(2013年5月14日发布,第15次修订版),第15.18小节——代理对象(Proxy Objects)这部分的文档仍然是空的.不过随着规范的日趋稳定,这里会补充上完整的参考文档的.目前,可以在ES wiki上的直接代理(Direct Proxies)页面内找到最详细的资料.在我写这篇文章的时候,只有F",
            "$": {
              "type": "text"
            }
          }
        ],
        "published": [
          "2013-07-14T02:42:00Z"
        ],
        "updated": [
          "2013-07-14T02:42:00Z"
        ],
        "author": [
          {
            "name": [
              "紫云飞"
            ],
            "uri": [
              "http://www.cnblogs.com/ziyunfei/"
            ]
          }
        ],
        "link": [
          {
            "$": {
              "rel": "alternate",
              "href": "http://www.cnblogs.com/ziyunfei/p/3187867.html"
            }
          },
          {
            "$": {
              "rel": "alternate",
              "type": "text/html",
              "href": "http://www.cnblogs.com/ziyunfei/p/3187867.html"
            }
          }
        ],
        "content": [
          {
            "_": "<p class=\"lead\">原文:<a href=\"http://ariya.ofilabs.com/2013/07/es6-and-proxy.html\" target=\"_blank\">http://ariya.ofilabs.com/2013/07/es6-and-proxy.html</a></p><hr /><p class=\"lead\">能够拦截在一个对象上的指定操作的能力是非常有用的,尤其是在故障调试的时候.通过ECMAScript 6中的新特性<span>&mdash;&mdash;</span>代理(proxy),这种能力才最终得以实现.</p><p>在目前最新的<a href=\"http://wiki.ecmascript.org/doku.php?id=harmony:specification_drafts\" target=\"_blank\">ES6规范草案</a>中(2013年5月14日发布,第15次修订版),第<a href=\"http://people.mozilla.org/~jorendorff/es6-draft.html#sec-15.18\" target=\"_blank\">15.18小节</a>&mdash;&mdash;代理对象(Proxy Objects)这部分的文档仍然是空的.不过随着规范的日趋稳定,这里会补充上完整的参考文档的.目前,可以在ES wiki上的<a href=\"http://wiki.ecmascript.org/doku.php?id=harmony:direct_proxies\" target=\"_blank\">直接代理</a>(Direct Proxies)页面内找到最详细的资料.在我写这篇文章的时候,只有Firefox 18+实现了最新的代理规范(Chrome实现了一个旧版的已经被废弃的代理规范&mdash;&mdash;<span>Proxy.create</span>).</p><p>演示代理特性最好的方式就是通过下面这个简单的例子:</p><div style=\"background-color: #F5F5F5;border: 1px solid #CCCCCC;padding:10px;\"><span style=\"color: #0000ff;\">var</span> engineer = { name: 'Joe Sixpack', salary: 50<span style=\"color: #000000;\"> };<br/> <br/></span><span style=\"color: #0000ff;\">var</span> interceptor =<span style=\"color: #000000;\"> {<br/>  set: </span><span style=\"color: #0000ff;\">function</span><span style=\"color: #000000;\"> (receiver, property, value) {<br/>    console.log(property, </span>'is changed to'<span style=\"color: #000000;\">, value);<br/>    receiver[property] </span>=<span style=\"color: #000000;\"> value;<br/>  }<br/>};<br/> <br/>engineer </span>= Proxy(engineer, interceptor);</div><p><span style=\"line-height: 1.5;\">在上面的代码中,我们首先创建了一个简单的对象</span><code style=\"line-height: 1.5;\">engineer和另外一个对象interceptor.然后,</code><span style=\"line-height: 1.5;\"><span>engineer</span>对象被另外一个由</span><code style=\"line-height: 1.5;\">Proxy()函数构建的代理对象所代替</code><span style=\"line-height: 1.5;\">.传入Proxy()的第二个参数</span><span style=\"line-height: 1.5;\">interceptor</span><span style=\"line-height: 1.5;\">是一个处理器(handler)对象.一个处理器对象可以包含有多种处理方法,在这个例子中只有一种处理方法,就是</span><code style=\"line-height: 1.5;\">set.set处理方法能够拦截到那些在代理对象身上进行的所有的属性赋值操作</code><span style=\"line-height: 1.5;\">.</span></p><p>让我们看看执行下面的这句赋值语句时会发生什么:</p><div style=\"background-color: #F5F5F5;border: 1px solid #CCCCCC;padding:10px;\">engineer.salary = 60;</div><p>这时,先前设置好<code>set处理方法将会被调用</code>.因此,会输出这样一条信息:</p><div style=\"background-color: #F5F5F5;border: 1px solid #CCCCCC;padding:10px;\">salary is changed to 60</div><div class=\"wp_syntax\"><code><span style=\"font-family: verdana, Arial, Helvetica, sans-serif;\">每当</span>代理对象<span>engineer</span>上的一个属性被赋值时,处理器对象</code>interceptor都会得到通知.只要提前设置好对应的处理方法(set),我们就能够拦截到这一操作,实现自己想要的功能.当然,不只是属性的赋值操作,代理对象身上的其他操作,比如属性的读取,属性的删除,属性的遍历等操作也都可以使用set之外的其他处理方法来进行拦截.</div><p>除了调试用途,代理对象还可以用到那些需要数据绑定(data binding)功能的框架中.我们可以把数据模型(data model)设置成为一个代理对象,监控它的属性的值的变化.也就不需要再使用其他的语法(比如必须使用显示的<code>set方法来更改模型的值</code>)或者持续追踪模型的值的变化(比如脏状态检查(<a href=\"http://stackoverflow.com/questions/9682092/databinding-in-angularjs?answertab=votes#answer-9693933\" target=\"_blank\">dirty state checking</a>))了.</p><p>你觉的代理还有什么用呢?</p><blockquote><p>译者注:关于调试用途,我讲一个我自己的真实案例,情节稍有简化.就在前两天,公司的项目中出现一个bug,需要我来解决.我分析出是一个对象的某个属性<span>在运行途中</span>被误删除导致,由于用的是模块化开发,这个对象又<span>被</span>多个模块中的代码处理过,我很难找到这个delete语句到底在哪个文件中.虽然可以在本页面内加载的十几个js文件中搜索delete然后一一排除,但我决定试一下更高端的调试方法.</p><p>我在这个对象刚刚生成的代码位置处的下一行写下一句:</p><div style=\"background-color: #F5F5F5;border: 1px solid #CCCCCC;padding:10px;\">obj.watch(\"prop\", <span style=\"color: #0000ff;\">function</span>(){console.log(arguments.callee.caller)})</div><p>我使用了Firefox特有的watch方法来找出到底哪个函数删掉了obj对象的prop属性,但情况出乎我意料,刷新页面后没有任何东西输出.于是我查一查<a href=\"https://developer.mozilla.org/zh-CN/docs/JavaScript/Reference/Global_Objects/Object/watch\" target=\"_blank\">MDN</a>,原来watch只能监测到属性的变更,而不会监测到属性的删除.关键是这个MDN页面我去年翻译过啊,但我当时没注意到这个细节.</p><p>于是我又使出Firefox特有的第二个特性,Proxy.啪啪啪打出这样一句:</p><div style=\"background-color: #F5F5F5;border: 1px solid #CCCCCC;padding:10px;\">obj = Proxy(obj, {deleteProperty : <span style=\"color: #0000ff;\">function</span>(){console.log(arguments.callee.caller)}})</div><p>就这样成功找到了那个想要找的函数,这应该就是作者一开始所说的故障调试的用途了.</p></blockquote><img src=\"http://counter.cnblogs.com/blog/rss/3187867\" width=\"1\" height=\"1\" alt=\"\"/><br/><p>本文链接：<a href=\"http://www.cnblogs.com/ziyunfei/p/3187867.html\" target=\"_blank\">http://www.cnblogs.com/ziyunfei/p/3187867.html</a>，转载请注明。</p>",
            "$": {
              "type": "html"
            }
          }
        ]
      },
      {
        "id": [
          "http://www.cnblogs.com/ziyunfei/p/3184248.html"
        ],
        "title": [
          {
            "_": "[译]JavaScript:将字符串两边的双引号转换成单引号 - 紫云飞",
            "$": {
              "type": "text"
            }
          }
        ],
        "summary": [
          {
            "_": "原文:http://ariya.ofilabs.com/2012/02/from-double-quotes-to-single-quotes.html代码的不一致性总是让人发狂,如果每位开发者都能遵守约定好的编码规范(coding conventions),那么生活将变的更加美好.比如在JavaScript中,一个字符串字面量可以用单引号引起,也可以用双引号来引起(ECMAScript 5规范7.8.4小节).很多人习惯于使用某种特定的引号,比如jQuery编码风格推荐人们使用双引号.但我个人更喜欢使用单引号,这仅仅是我的偏好.自从有了Esprima,我意识到,我可以利用Esprima能够以",
            "$": {
              "type": "text"
            }
          }
        ],
        "published": [
          "2013-07-13T03:39:00Z"
        ],
        "updated": [
          "2013-07-13T03:39:00Z"
        ],
        "author": [
          {
            "name": [
              "紫云飞"
            ],
            "uri": [
              "http://www.cnblogs.com/ziyunfei/"
            ]
          }
        ],
        "link": [
          {
            "$": {
              "rel": "alternate",
              "href": "http://www.cnblogs.com/ziyunfei/p/3184248.html"
            }
          },
          {
            "$": {
              "rel": "alternate",
              "type": "text/html",
              "href": "http://www.cnblogs.com/ziyunfei/p/3184248.html"
            }
          }
        ],
        "content": [
          {
            "_": "<p class=\"lead\">原文:<a href=\"http://ariya.ofilabs.com/2012/02/from-double-quotes-to-single-quotes.html\" target=\"_blank\">http://ariya.ofilabs.com/2012/02/from-double-quotes-to-single-quotes.html</a></p><hr /><p class=\"lead\">代码的不一致性总是让人发狂,如果每位开发者都能遵守约定好的编码规范(<a href=\"http://en.wikipedia.org/wiki/Coding_conventions\" target=\"_blank\">coding conventions</a>),那么生活将变的更加美好.比如在JavaScript中,一个字符串字面量可以用单引号引起,也可以用双引号来引起(ECMAScript 5规范<a href=\"http://es5.github.com/x7.html#x7.8.4\" target=\"_blank\">7.8.4</a>小节).很多人习惯于使用某种特定的引号,比如<a href=\"http://contribute.jquery.org/style-guide/js/\" target=\"_blank\">jQuery编码风格</a>推荐人们使用双引号.</p><p>但我个人更喜欢使用单引号,这仅仅是我的偏好.自从有了<a href=\"http://esprima.org/\" target=\"_blank\">Esprima</a>,我意识到,我可以利用Esprima能够以非破坏式(non-destructive)的方式对输入的JavaScript源码进行局部修改(partial modification)的能力,来强制让输入JavaScript源码中的每个字符串字面量都使用单引号.于是我就写出了下面的<code>singlequote.js脚本:</code></p><div style=\"background-color: #F5F5F5;border: 1px solid #CCCCCC;padding:10px;\"><span style=\"color: #0000ff;\">var</span> fs = require('fs'<span style=\"color: #000000;\">),<br/>    esprima </span>= require('esprima'<span style=\"color: #000000;\">),<br/>    input </span>= process.argv[2<span style=\"color: #000000;\">],<br/>    output </span>= process.argv[3<span style=\"color: #000000;\">],<br/>    offset </span>= 0<span style=\"color: #000000;\">,<br/>    content </span>= fs.readFileSync(input, 'utf-8'<span style=\"color: #000000;\">),<br/>    tokens </span>= esprima.parse(content, { tokens: <span style=\"color: #0000ff;\">true</span>, range: <span style=\"color: #0000ff;\">true</span><span style=\"color: #000000;\"> }).tokens;<br/> <br/></span><span style=\"color: #0000ff;\">function</span><span style=\"color: #000000;\"> convert(literal) {<br/>    </span><span style=\"color: #0000ff;\">var</span> result = literal.substring(1, literal.length - 1<span style=\"color: #000000;\">);<br/>    result </span>= result.replace(/'/g, '\\''<span style=\"color: #000000;\">);<br/>    </span><span style=\"color: #0000ff;\">return</span> ''' + result + '''<span style=\"color: #000000;\">;<br/>}<br/> <br/>tokens.forEach(</span><span style=\"color: #0000ff;\">function</span><span style=\"color: #000000;\"> (token) {<br/>    </span><span style=\"color: #0000ff;\">var</span><span style=\"color: #000000;\"> str;<br/>    </span><span style=\"color: #0000ff;\">if</span> (token.type === 'String' &amp;&amp; token.value[0] !== '\\''<span style=\"color: #000000;\">) {<br/>        str </span>=<span style=\"color: #000000;\"> convert(token.value);<br/>        content </span>= content.substring(0, offset + token.range[0]) + str +<span style=\"color: #000000;\"><br/>            content.substring(offset </span>+ token.range[1] + 1<span style=\"color: #000000;\">, content.length);<br/>        offset </span>+= (str.length -<span style=\"color: #000000;\"> token.value.length);<br/>    }<br/>});<br/>fs.writeFileSync(output, content);</span>　</div><p><span style=\"line-height: 1.5;\">这个脚本需要用</span><a style=\"line-height: 1.5;\" href=\"http://nodejs.org/\" target=\"_blank\">Node.js</a><span style=\"line-height: 1.5;\">来执行,像这样:</span></p><div style=\"background-color: #F5F5F5;border: 1px solid #CCCCCC;padding:10px;\">node singlequote.js inputfile outputfile</div><p>该脚本具体是如何工作的?让我们假设输入源码的内容是这样的:</p><div style=\"background-color: #F5F5F5;border: 1px solid #CCCCCC;padding:10px;\">console.log(\"Hello\")</div><p>在我们把这句代码传入Esprima解析器的时候,要把其中一个解析选项tokens设为true,这样解析器才会在解析的过程中把遇到的所有token(词法单元)收集到一个数组中,并返回它.对于我们上面的这句代码,返回的token数组看起来是这样的:</p><div style=\"background-color: #F5F5F5;border: 1px solid #CCCCCC;padding:10px;\"><span style=\"color: #000000;\">[<br/>    { type: </span>\"Identifier\", value: \"console\", range: [0, 6<span style=\"color: #000000;\">] },<br/>    { type: </span>\"Punctuator\", value: \".\", range: [7, 7<span style=\"color: #000000;\">] },<br/>    { type: </span>\"Identifier\", value: \"log\", range: [8, 10<span style=\"color: #000000;\">] },<br/>    { type: </span>\"Punctuator\", value: \"(\", range: [11, 11<span style=\"color: #000000;\">] },<br/>    { type: </span>\"String\", value: \"\"Hello\"\", range: [12, 18<span style=\"color: #000000;\">] },<br/>    { type: </span>\"Punctuator\", value: \")\", range: [19, 19<span style=\"color: #000000;\">] }<br/>]</span></div><blockquote><p>译者注:在编译原理领域中,token这个词可以被翻译成词法单元或者词法记号,它表示一个在源码中拥有独立意义的最小单位,是不可再分的词法单元(<span>lexical unit</span>).一个token是由若干个字符组成的,就像英文中的单词一样,所以也有人直接把它翻译成单词.在ES标准中,token具体包含有保留字,标识符,字面量,标点符号这几种输入元素(input element).</p></blockquote><p>一旦我们拿到了所有的token对象,剩下的事情就简单多了.我们只需要遍历这个token对象数组,找到那些与某个字符串字面量关联的token(type属性为String的token对象).每个token对象都会在自己的range属性中存放有所关联字符串字面量的位置信息,这是一个表示了所关联字符串字面量在输入源码中的开始位置和结束位置的索引区间数组(闭区间).</p><div style=\"background-color: #F5F5F5;border: 1px solid #CCCCCC;padding:10px;\"> { type: \"String\", value: \"\"Hello\"\", range: [12, 18] }</div><p><span style=\"line-height: 1.5;\">有了这个位置信息,我们就能使用一些基本的字符串操作来替换输入源码中的某段内容.对于上面这个例子的话,修改目标就是索引位置在</span>[12, 18]之间的源码内容<span style=\"line-height: 1.5;\">.值得注意的是,如果原始字符串字面量的值(两个引号中间夹着的内容)中包含有一个或多个的单引号,则我们需要做一些额外的工作,就是要把这些单引号进行转义(查看第</span><a style=\"line-height: 1.5;\" href=\"http://es5.github.com/#x7.8.4\">7.8.4</a>小节的SingleEscapeCharacters<span style=\"line-height: 1.5;\">).如果真的需要进行这样的转义,则转义后的字符串字面量的长度会大于原始字符串字面量的长度(多了反斜杠字符),从而改变了整个源码的长度,再从而让token数组中其它还未处理的token对象中包含的位置信息产生错位,因此我们还需要进行偏移量的调整.下面是个需要进行转义的字符串字面量的例子:</span></p><div style=\"background-color: #F5F5F5;border: 1px solid #CCCCCC;padding:10px;\"><span style=\"color: #008000;\">//</span><span style=\"color: #008000;\"> 输入源码</span><br/>\"color = 'blue'\"<span style=\"color: #000000;\">;<br/> <br/></span><span style=\"color: #008000;\">//</span><span style=\"color: #008000;\"> 不进行转义操作的话会输出非法的字符串字面量</span><br/>'color = 'blue'';</div><p>另外,我写的转换代码还差一件事情没做,就是要把那些不再需要的转义字符也删除掉.也就是原来字符串字面量中包含的双引号前面的那个反斜杠,它已经不再需要了.这项工作就留给读者们实现吧!</p><blockquote><p>译者注:作者说的是这种情况,原字符串字面量为\"\\\"\",这时用反斜杠转义里面的双引号是必须的,但按照上面的规则转换之后就成了'\\\"',虽然这也是一个合法的字符串字面量,且求值结果不变.不过作者的意思是这个反斜杠是多余的,是应该删除掉的.</p></blockquote><p>很显然,我写的这个工具只是为教学演示而用.另外,虽然现在大部分编辑器都支持搜索替换的功能,如果你需要使用编辑器来完成这项任务,也有一定的难度,注意不要替换掉那些不在字符串字面量两边的引号.</p><blockquote><p>译者注:你觉的能用正则表达式来完成这项任务吗?注释和正则字面量中的引号字符会让你束手无策.</p></blockquote><p>你还可以想想看,利用token列表和源码局部修改的技术,还能干哪些事情?</p><blockquote><p>译者注:<span>你有没有发现作者忽略了一个比较极端的情况,就是假如</span><span>原字符串字面量为\"\\'\",虽然这个反斜杠是多余的,但这的确是一个合法的字符串写法,求值后字符串的值为一个单引号.按照上面的算法转换之后会变成'\\\\''.显然,这会导致一个语法错误,因为少了一个反斜杠.是不是呢?</span></p><p>有了Esprima,实现这样一个转换器真的是很简单,如下</p><script type=\"text/javascript\">// <![CDATA[document.write('<table style=\"border:0\"><tbody><tr><td style=\"border:0\"><textarea id=\"input\" style=\"width: 400px; height: 150px;\">var str1 = \"string1\"\\nvar str2 = \"\\'string2\\'\"\\nvar str3 = \"\\\\\"string3\\\\\\'\"</textarea></td><td style=\"border:0\"><textarea id=\"output\" style=\"width: 400px; height: 150px;\"></textarea></td></tr></tbody></table>');$.getScript(\"http://files.cnblogs.com/ziyunfei/esprima.js\", function () {  $(\"#input\").on(\"input\", function () {    var source = this.value;    var offset = 0;    try {      esprima.parse(source, {        tokens: true,        range: true      }).tokens.forEach(function (token) {        if (token.type === 'String' && token.value[0] === '\"') {          var range = token.range;          var escapedString = token.value.slice(1, -1).replace(/'/g, \"\\\\'\").replace(/\\\\\\\\'/g, \"\\\\'\").replace(/\\\\\"/g,\"\\\"\");          var newValue = \"'\" + escapedString + \"'\";          source = source.slice(0, range[0] + offset) + newValue + source.slice(range[1] + offset);          offset += newValue.length - token.value.length;        }      });      $(\"#output\").val(source);    } catch (error) {      $(\"#output\").val(error);    }  }).trigger(\"input\");});// ]]></script></blockquote><img src=\"http://counter.cnblogs.com/blog/rss/3184248\" width=\"1\" height=\"1\" alt=\"\"/><br/><p>本文链接：<a href=\"http://www.cnblogs.com/ziyunfei/p/3184248.html\" target=\"_blank\">http://www.cnblogs.com/ziyunfei/p/3184248.html</a>，转载请注明。</p>",
            "$": {
              "type": "html"
            }
          }
        ]
      },
      {
        "id": [
          "http://www.cnblogs.com/ziyunfei/archive/2013/04/23/3033647.html"
        ],
        "title": [
          {
            "_": "[译]JavaScript引擎中的延迟解析 - 紫云飞",
            "$": {
              "type": "text"
            }
          }
        ],
        "summary": [
          {
            "_": "原文:http://ariya.ofilabs.com/2012/07/lazy-parsing-in-javascript-engines.html现代的JavaScript引擎可以将函数体的解析操作延迟到真正需要的时候再进行,下面我将讲一下为什么要这样做以及引擎具体是如何实现的.IE团队在最近的一篇博文\"IE10和Windows 8中JavaScript性能的发展\"中提到了他们使用延迟解析来提升IE10的性能.实际上,IE9正式版已经实现了这种优化手段,只不过IE10更进一步改进了它.文中有这样一句话(其中Chakra是IE的JavaScript引擎的名字):为了进一步",
            "$": {
              "type": "text"
            }
          }
        ],
        "published": [
          "2013-04-23T13:14:00Z"
        ],
        "updated": [
          "2013-04-23T13:14:00Z"
        ],
        "author": [
          {
            "name": [
              "紫云飞"
            ],
            "uri": [
              "http://www.cnblogs.com/ziyunfei/"
            ]
          }
        ],
        "link": [
          {
            "$": {
              "rel": "alternate",
              "href": "http://www.cnblogs.com/ziyunfei/archive/2013/04/23/3033647.html"
            }
          },
          {
            "$": {
              "rel": "alternate",
              "type": "text/html",
              "href": "http://www.cnblogs.com/ziyunfei/archive/2013/04/23/3033647.html"
            }
          }
        ],
        "content": [
          {
            "_": "<style><!--code {    background-color: #F7F7F9;    border: 1px solid #E1E1E8;    padding: 2px 4px;}--></style><p class=\"lead\">原文:<a href=\"http://ariya.ofilabs.com/2012/07/lazy-parsing-in-javascript-engines.html\" target=\"_blank\">http://ariya.ofilabs.com/2012/07/lazy-parsing-in-javascript-engines.html</a></p><hr /><p class=\"lead\">现代的JavaScript引擎可以将函数体的解析操作延迟到真正需要的时候再进行,下面我将讲一下为什么要这样做以及引擎具体是如何实现的.</p><p>IE团队在最近的一篇博文\"<a href=\"http://blogs.msdn.com/b/ie_cn/archive/2012/06/21/advances-in-javascript-performance-in-ie10-and-windows-8.aspx\" target=\"_blank\">IE10和Windows 8中JavaScript性能的发展</a>\"中提到了他们使用延迟解析来提升IE10的性能.实际上,IE9正式版已经实现了这种优化手段,只不过IE10更进一步改进了它.文中有这样一句话(其中<span style=\"color: #404040; font-family: 'Helvetica Neue',Helvetica,Arial,sans-serif; font-size: 13.3333px; line-height: 18px;\">Chakra</span>是IE的JavaScript引擎的名字):</p><blockquote><p>为了进一步降低指令首次执行的时间,Chakra只有在那个函数即将运行的时候才对它进行解析并生成字节码,这种机制就称之为延迟解析.</p></blockquote><p>让我们通过一个简单的例子看看延迟解析到底是什么,完整的示例代码如下:</p><div style=\"background-color: #F5F5F5;border: 1px solid #CCCCCC;padding:10px;\"><span style=\"color: #0000ff;\">function</span> add(x, y) { <span style=\"color: #0000ff;\">return</span> x +<span style=\"color: #000000;\"> y; }<br /></span><span style=\"color: #0000ff;\">function</span> mul(x, y) { <span style=\"color: #0000ff;\">return</span> x *<span style=\"color: #000000;\"> y; }<br />alert(add(</span>40, 2));</div><div class=\"wp_syntax\">在引擎执行这段代码之前,首先会将代码传给它的解析器(<a href=\"http://en.wikipedia.org/wiki/Parser\" target=\"_blank\">parser</a>)组件.解析器会对传入的代码进行语法分析,最后生成一个叫抽象语法树(<a href=\"http://en.wikipedia.org/wiki/Abstract_syntax_tree\" target=\"_blank\">abstract syntax tree</a> 简称AST)的东西.如果你想看看语法树具体长什么样,可以试试这个基于<a href=\"http://esprima.org/\" target=\"_blank\">Esprima</a>(由我创建的一个JavaScript解析器项目)的<a href=\"http://esprima.org/demo/parse.html?code=function%20add(x%2C%20y)%20%7B%20return%20x%20%2B%20y%3B%20%7D%0D%0Afunction%20mul(x%2C%20y)%20%7B%20return%20x%20*%20y%3B%20%7D%0D%0Aalert(add(40%2C%202))%3B\" target=\"_blank\">在线解析器demo</a>.虽然示例代码很短,但它生成的语法树还是很复杂的,所以这里我就用人类语言描述一下解析器的解析结果到底是什么:</div><blockquote><p> 声明一个函数<em>add</em>.它接受x和y两个参数.它只包含一条return语句.返回值是x和y的和.<br />声明一个函数<em>mul</em>.它接受x和y两个参数.它只包含一条return语句.返回值是x和y的积.<br />调用函数<em>alert</em>.参数是调用函数<em>add</em>的返回值,其中参数是40和2.</p></blockquote><p>有了这个语法树,就能进行后续一系列的操作.一直到最终解释器执行代码,弹出框中显示结果42.你也许已经注意到了,在上面的几步解析操作中,函数<em>mul</em>的解析是完全徒劳的,因为最终<em>alert</em>函数只调用了<em>add</em>函数,<em>mul</em>函数根本没用到.除了这个简单的演示例子以外,其实在真实的Web中,也的确有很多被声明过的函数一次也没被调用过(依据微软的<a href=\"http://research.microsoft.com/en-us/projects/jsmeter/\" target=\"_blank\">JSMeter research</a>).</p><p>不过现代的JavaScript引擎不会这么\"尽职尽责\"的去一次性地解析所有代码,而是使用了<strong>延迟解析(lazy parsing)</strong>的方式.相同的代码,解析器的解析结果会变成下面这样:</p><blockquote><p>声明一个函数<em>add,</em>函数体为\"{ return x + y; }\".<br />声明一个函数<em>mul</em><em>,</em>函数体为\"{ return x * y; }\".<br />调用函数<em>alert</em>.参数是调用函数<em>add</em>的返回值,其中参数是40和2.<br /></p></blockquote><p>也就是说,解析器没有解析每个函数的函数体中的每句代码,而仅仅是把整个函数体保存下来,到了这个函数真正要运行的时候,再进行解析:</p><blockquote><p>调用函数<em>add</em>.发现它还没有被解析,于是启动解析器解析\"{ return x + y; }\",解析结果为:<br />它接受x和y两个参数.它只包含一条return语句.返回值是x和y的和.</p></blockquote><p>大体上讲就是,解析那个函数源码的任务被延迟了,只有在必要的时候,也就是那个函数(<em>add</em>函数)马上要执行的时候才会去解析它.不过此时延迟解析器仍然需要去解析这段函数源码,但这次解析和正常解析的区别是,这次解析的解析过程是被简化的.只有通过这次解析,才能正确的找到整个函数的函数体,也就是<code>function add(x, y) {</code>,和函数体尾部的<code>}</code>之间的代码.这项任务不能通过正则表达式或者其他任何形式的扫描来实现,那样不靠谱.由于这种解析是被简化的,只需要快点找到函数结尾的大括号,而不需要做其他的无关操作,这就意味着可以省略掉一些正常解析过程中所必须的操作.首先一个就是,我们不需要去生成语法树,因为这时没人需要这份语法树.另外,不再需要为代码路径在堆内存中分配内存空间,分配内存需要消耗系统资源,避免这项操作可以提高引擎运行速度.</p><p>下面举一个现实生活中的例子.比如你偶然发现一篇很好的文章(有可能就是这篇文章),但你决定不马上看,而是在以后真正需要了解这方面知识的时候再来看.所以你需要把文章的正文保存到你的笔记软件里.那么你就需要快速的浏览一下这篇文章,找到它正文的起始处和结束处,这个过程是很快的(比起阅读整篇文章来说).一旦找到了正文的起始处和结束处,你就可以选择这些文字,复制到剪切板里,切换到笔记软件的窗口,最终粘贴到里面.过几天,到了你真正需要用到那篇文章中所讲的内容的时候,你就可以打开那篇笔记,完完整整的读一遍.</p><p>让我们通过解析一个while语句来看看正常解析器和延迟解析器两者之间的区别,你肯定已经知道了,while语句的语法如下:</p><blockquote><p>'while' '(' Expression ')' Statement</p></blockquote><p>正常解析器需要解析这些代码并且要生成一个代表该代码结构的抽象语法树.如果把解析器中解析while语句的代码用JavaScript实现(引擎中本来是C++),会是这样:</p><div style=\"background-color: #F5F5F5;border: 1px solid #CCCCCC;padding:10px;\"><span style=\"color: #0000ff;\">function</span><span style=\"color: #000000;\"> realParseWhileStatement()<br />{<br />  expect(</span>'while'<span style=\"color: #000000;\">);<br />  expect(</span>'('<span style=\"color: #000000;\">);<br />  </span><span style=\"color: #0000ff;\">var</span> expression =<span style=\"color: #000000;\"> parseExpression();<br />  expect(</span>')'<span style=\"color: #000000;\">);<br />  </span><span style=\"color: #0000ff;\">var</span> statement =<span style=\"color: #000000;\"> parseStatement();<br /> <br />  </span><span style=\"color: #008000;\">//</span><span style=\"color: #008000;\"> 返回AST</span><br/>  <span style=\"color: #0000ff;\">return</span><span style=\"color: #000000;\"> {<br />    type: </span>'WhileStatement'<span style=\"color: #000000;\">,<br />    test: expression,<br />    body: statement<br />  };<br />}</span></div><p>如果是延迟解析,我们就不再需要保存返回的结果,那么代码就可以简化成:</p><div style=\"background-color: #F5F5F5;border: 1px solid #CCCCCC;padding:10px;\"><span style=\"color: #0000ff;\">function</span><span style=\"color: #000000;\"> lazyParseWhileStatement()<br />{<br />  expect(</span>'while'<span style=\"color: #000000;\">);<br />  expect(</span>'('<span style=\"color: #000000;\">);<br />  parseExpression();<br />  expect(</span>')'<span style=\"color: #000000;\">);<br />  parseStatement();<br />}</span></div><p>显然,还有其他一些函数来解析各种各样的语法结构.</p><p>如果在延迟解析的过程中又遇到一个嵌套的函数声明该怎么办?同样的规则,该函数也会被延迟解析.函数里的盗梦空间,有没有?</p><p>实际上,真实的延迟解析器会更复杂一点,它不光需要妥善处理严格模式和解析错误,还得避免堆栈溢出等其他一些细节问题.</p><p>接下来,让我们看一下延迟加载在两个主流的JavaScript引擎中是如何实现的.</p><p>首先看一下<strong><a href=\"http://trac.webkit.org/wiki/JavaScriptCore\" target=\"_blank\">JavaScriptCore</a></strong> (JSC),它被内置在Safari中的Webkit渲染引擎中.JSC的源代码存放在Webkit源码中的<code>Source/JavaScriptCore</code>目录中,与延迟加载相关的源文件有如下几个:</p><div style=\"background-color: #F5F5F5;border: 1px solid #CCCCCC;padding:10px;\">parser/Parser.h<br />parser/Parser.cpp<br />parser/SyntaxChecker.h</div><div class=\"wp_syntax\">在JSC中,正常解析器和延迟解析器本质上使用了相同的代码,是使用C++模板来实现了两种不同的功能.其中,解析器组件本身并不构建语法树,这项工作会交给<code>TreeBuilder</code>来做.JSC中有两个可用的<code>TreeBuilder</code>,<code>ASTBuilder</code>和<code>SyntaxChecker</code>.后一个本质上什么都不做,它由解析器驱动,解析器可以一直向前解析直到停下来为止.<code>SyntaxChecker</code>扮演的实际上是一个类似语法检查器的东西,所以它的名字才会叫成<code>SyntaxChecker</code>.</div><p>当<code>SyntaxChecker</code>在函数体的尾部结束运行时,函数体起始处(左大括号处)和结束处(右大括号处)的位置将被保存下来,这个存储的范围值将在随后真正的解析开始的时候被用到,也就是函数被真正调用的时候.由于JSC已经保存了一份完整的源码,所以只保存范围就可以,没必要再复制一份源码字符串.</p><p><strong><a href=\"https://code.google.com/p/v8/\" target=\"_blank\">V8</a></strong>(使用在Chrome和Node.js中)中的情况也很类似.V8中与延迟解析相关的源码文件有:</p><div style=\"background-color: #F5F5F5;border: 1px solid #CCCCCC;padding:10px;\">src/preparser.cc<br />src/preparser.h<br />src/preparser-api.cc</div><p>和JSC的不同的是,V8中的正常解析器和延迟解析器使用了两份不同的代码(但有着类似的接口).后者在V8中的术语叫<em>PreParser</em>.当正常解析器解析到一个函数体时,就会调用PreParser,也就是在执行<code>Parser::ParseFunctionLiteral</code>方法的时候.有意思的是,V8为一种特例做了专门的优化,这个特例就是立即调用函数表达式<a href=\"http://benalman.com/news/2010/11/immediately-invoked-function-expression/\" target=\"_blank\">(immediately invoked function expression</a> 简称IIFE<a href=\"http://benalman.com/news/2010/11/immediately-invoked-function-expression/\" target=\"_blank\">)</a>,一种能提供更好的<a href=\"http://addyosmani.com/blog/essential-js-namespacing/\" target=\"_blank\">命名空间(namespacing)</a>而不用担心污染全局变量的写法,很适合用来实现模块,比如:</p><div style=\"background-color: #F5F5F5;border: 1px solid #CCCCCC;padding:10px;\"><span style=\"color: #0000ff;\">var</span> foobar = (<span style=\"color: #0000ff;\">function</span><span style=\"color: #000000;\">() {<br />    </span><span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">  实现代码</span><br/>    <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">  返回模块对象</span><br/>})();</div><div class=\"wp_syntax\">因为这种模式现在非常流行,所以V8用一种简单的试探法来检测函数的这种用法:如果在<code>function</code>关键字前面有一个<code>(</code>,则不要考虑延迟解析,直接对该函数进行真正的解析,比如上面的这个IIFE示例.</div><p>还有<strong><a href=\"https://developer.mozilla.org/en/SpiderMonkey\" target=\"_blank\">SpiderMonkey</a></strong>(Firefox中的JavaScript引擎)又如何呢?SpiderMonkey目前还没有实现延迟解析,不过已经在实现中了,查看<a href=\"https://bugzilla.mozilla.org/show_bug.cgi?id=678037\" target=\"_blank\">bug 678037</a>可以了解到最新的进展,这一举措可以进一步提升Firefox的性能.</p><p>最后要说的是,因为这篇文章很长,你可能一下消化不了,可以大概扫几眼以后再细读.这就叫做\"延迟阅读\"!</p><img src=\"http://counter.cnblogs.com/blog/rss/3033647\" width=\"1\" height=\"1\" alt=\"\"/><br/><p>本文链接：<a href=\"http://www.cnblogs.com/ziyunfei/archive/2013/04/23/3033647.html\" target=\"_blank\">http://www.cnblogs.com/ziyunfei/archive/2013/04/23/3033647.html</a>，转载请注明。</p>",
            "$": {
              "type": "html"
            }
          }
        ]
      },
      {
        "id": [
          "http://www.cnblogs.com/ziyunfei/archive/2013/04/20/3029652.html"
        ],
        "title": [
          {
            "_": "[译]使用PhantomJS进行网页剪报 - 紫云飞",
            "$": {
              "type": "text"
            }
          }
        ],
        "summary": [
          {
            "_": "原文:http://ariya.ofilabs.com/2013/04/web-page-clipping-with-phantomjs.htmlPhantomJS的一个主要用途就是用来抓取网页并将它渲染成图片.在渲染图片时有很多选项可供调整,其中最常用的一个就是缩放选项(调整zoomFactor属性的值),它经常会被用在制作缩略图的场景下.另外一个不怎么被人熟知的选项就是\"按指定矩形区域渲染\"选项(调整clipRect属性的值),也就是生成的图片只包含了目标网页中被指定的那部分区域.这种只渲染页面指定矩形区域的需求通常表现为你只想获取页面中某个特定元素的内容(就像getB",
            "$": {
              "type": "text"
            }
          }
        ],
        "published": [
          "2013-04-20T01:24:00Z"
        ],
        "updated": [
          "2013-04-20T01:24:00Z"
        ],
        "author": [
          {
            "name": [
              "紫云飞"
            ],
            "uri": [
              "http://www.cnblogs.com/ziyunfei/"
            ]
          }
        ],
        "link": [
          {
            "$": {
              "rel": "alternate",
              "href": "http://www.cnblogs.com/ziyunfei/archive/2013/04/20/3029652.html"
            }
          },
          {
            "$": {
              "rel": "alternate",
              "type": "text/html",
              "href": "http://www.cnblogs.com/ziyunfei/archive/2013/04/20/3029652.html"
            }
          }
        ],
        "content": [
          {
            "_": "<p class=\"lead\">原文:<a href=\"http://ariya.ofilabs.com/2013/04/web-page-clipping-with-phantomjs.html\" target=\"_blank\">http://ariya.ofilabs.com/2013/04/web-page-clipping-with-phantomjs.html</a></p><hr /><p class=\"lead\"><a href=\"http://phantomjs.org/\" target=\"_blank\">PhantomJS</a>的一个主要用途就是用来抓取网页并将它渲染成图片.在<a href=\"http://ariya.ofilabs.com/2012/10/web-page-screenshot-with-phantomjs.html\" target=\"_blank\">渲染图片</a>时有很多选项可供调整,其中最常用的一个就是缩放选项(调整<span style=\"color: #660066;\">zoomFactor</span>属性的值),它经常会被用在制作缩略图的场景下.另外一个不怎么被人熟知的选项就是\"按指定矩形区域渲染\"选项(调整<span style=\"color: #660066;\"><span style=\"color: #660066;\">clipRect</span></span>属性的值),也就是生成的图片只包含了目标网页中被指定的那部分区域.</p><p>这种只渲染页面指定矩形区域的需求通常表现为你只想获取页面中某个特定元素的内容(就像<a href=\"https://developer.mozilla.org/zh-CN/docs/DOM/element.getBoundingClientRect\" target=\"_blank\">getBoundingClientRect</a>的作用一样).这种截图需求可以很方便的使用<a href=\"http://casperjs.org/\" target=\"_blank\">CasperJS</a>提供的<a href=\"http://casperjs.org/api.html#casper.captureSelector\" target=\"_blank\">captureSelector</a>函数来实现.</p><p>另外一种情况就是你想将一个比较长的页面分割成两张图片分别渲染,经常是在查看<a href=\"http://www.nngroup.com/articles/mobile-site-vs-full-site/\" target=\"_blank\">移动网站</a>的时候,下面的图片演示了渲染BBC网站时图片的分割效果.</p><p><img src=\"http://images.cnitblog.com/blog/116671/201304/20020246-3f4fa40f883341768dacf1104d6a2e2d.png\" alt=\"\" /></p><p>用来生成这两张图片的脚本就在下面.</p><div style=\"background-color: #F5F5F5;border: 1px solid #CCCCCC;padding:10px;\"><span style=\"color: #000066; font-weight: bold;\">var</span> page <span style=\"color: #339933;\">=</span> require<span style=\"color: #009900;\">(</span><span style=\"color: #3366cc;\">'webpage'</span><span style=\"color: #009900;\">)</span>.<span style=\"color: #660066;\">create</span><span style=\"color: #009900;\">(</span><span style=\"color: #009900;\">)</span><span style=\"color: #339933;\">;</span><br />page.<span style=\"color: #660066;\">settings</span>.<span style=\"color: #660066;\">userAgent</span> <span style=\"color: #339933;\">=</span> <span style=\"color: #3366cc;\">'WebKit/534.46 Mobile/9A405 Safari/7534.48.3'</span><span style=\"color: #339933;\">;</span><br />page.<span style=\"color: #660066;\">settings</span>.<span style=\"color: #660066;\">viewportSize</span> <span style=\"color: #339933;\">=</span> <span style=\"color: #009900;\">{</span> width<span style=\"color: #339933;\">:</span> <span style=\"color: #cc0000;\">400</span><span style=\"color: #339933;\">,</span> height<span style=\"color: #339933;\">:</span> <span style=\"color: #cc0000;\">600</span> <span style=\"color: #009900;\">}</span><span style=\"color: #339933;\">;</span><br />page.<span style=\"color: #660066;\">open</span><span style=\"color: #009900;\">(</span><span style=\"color: #3366cc;\">'http://m.bbc.co.uk/news/business'</span><span style=\"color: #339933;\">,</span> <span style=\"color: #000066; font-weight: bold;\">function</span> <span style=\"color: #009900;\">(</span>status<span style=\"color: #009900;\">)</span> <span style=\"color: #009900;\">{</span><br />    <span style=\"color: #000066; font-weight: bold;\">if</span> <span style=\"color: #009900;\">(</span>status <span style=\"color: #339933;\">!==</span> <span style=\"color: #3366cc;\">'success'</span><span style=\"color: #009900;\">)</span> <span style=\"color: #009900;\">{</span><br />        console.<span style=\"color: #660066;\">log</span><span style=\"color: #009900;\">(</span><span style=\"color: #3366cc;\">'Unable to load BBC!'</span><span style=\"color: #009900;\">)</span><span style=\"color: #339933;\">;</span><br />        phantom.<span style=\"color: #660066;\">exit</span><span style=\"color: #009900;\">(</span><span style=\"color: #009900;\">)</span><span style=\"color: #339933;\">;</span><br />    <span style=\"color: #009900;\">}</span> <span style=\"color: #000066; font-weight: bold;\">else</span> <span style=\"color: #009900;\">{</span><br />        window.<span style=\"color: #660066;\">setTimeout</span><span style=\"color: #009900;\">(</span><span style=\"color: #000066; font-weight: bold;\">function</span> <span style=\"color: #009900;\">(</span><span style=\"color: #009900;\">)</span> <span style=\"color: #009900;\">{</span><br />            page.<span style=\"color: #660066;\">clipRect</span> <span style=\"color: #339933;\">=</span> <span style=\"color: #009900;\">{</span> left<span style=\"color: #339933;\">:</span> <span style=\"color: #cc0000;\">0</span><span style=\"color: #339933;\">,</span> top<span style=\"color: #339933;\">:</span> <span style=\"color: #cc0000;\">0</span><span style=\"color: #339933;\">,</span> width<span style=\"color: #339933;\">:</span> <span style=\"color: #cc0000;\">400</span><span style=\"color: #339933;\">,</span> height<span style=\"color: #339933;\">:</span> <span style=\"color: #cc0000;\">600</span> <span style=\"color: #009900;\">}</span><span style=\"color: #339933;\">;</span><br />            page.<span style=\"color: #660066;\">render</span><span style=\"color: #009900;\">(</span><span style=\"color: #3366cc;\">'bbc-page1.png'</span><span style=\"color: #009900;\">)</span><span style=\"color: #339933;\">;</span><br />            page.<span style=\"color: #660066;\">clipRect</span> <span style=\"color: #339933;\">=</span> <span style=\"color: #009900;\">{</span> left<span style=\"color: #339933;\">:</span> <span style=\"color: #cc0000;\">0</span><span style=\"color: #339933;\">,</span> top<span style=\"color: #339933;\">:</span> <span style=\"color: #cc0000;\">600</span><span style=\"color: #339933;\">,</span> width<span style=\"color: #339933;\">:</span> <span style=\"color: #cc0000;\">400</span><span style=\"color: #339933;\">,</span> height<span style=\"color: #339933;\">:</span> <span style=\"color: #cc0000;\">600</span> <span style=\"color: #009900;\">}</span><span style=\"color: #339933;\">;</span><br />            page.<span style=\"color: #660066;\">render</span><span style=\"color: #009900;\">(</span><span style=\"color: #3366cc;\">'bbc-page2.png'</span><span style=\"color: #009900;\">)</span><span style=\"color: #339933;\">;</span><br />            phantom.<span style=\"color: #660066;\">exit</span><span style=\"color: #009900;\">(</span><span style=\"color: #009900;\">)</span><span style=\"color: #339933;\">;</span><br />        <span style=\"color: #009900;\">}</span><span style=\"color: #339933;\">,</span> <span style=\"color: #cc0000;\">2000</span><span style=\"color: #009900;\">)</span><span style=\"color: #339933;\">;</span><br />    <span style=\"color: #009900;\">}</span><br /><span style=\"color: #009900;\">}</span><span style=\"color: #009900;\">)</span><span style=\"color: #339933;\">;</span></div><p>代码非常简单,尤其是如果你已经熟悉了PhantomJS的这几个<a href=\"https://github.com/ariya/phantomjs/wiki/Screen-Capture\" target=\"_blank\">截屏用例</a>的情况下.改变UA字符串是为了确保抓取到的页面是移动版页面.生成的两张图片,分别对应了用户将要看到的第一屏页面和第二屏页面.这都是通过调整所要截取矩形区域的top偏移量来控制的,非常方便!</p><img src=\"http://counter.cnblogs.com/blog/rss/3029652\" width=\"1\" height=\"1\" alt=\"\"/><br/><p>本文链接：<a href=\"http://www.cnblogs.com/ziyunfei/archive/2013/04/20/3029652.html\" target=\"_blank\">http://www.cnblogs.com/ziyunfei/archive/2013/04/20/3029652.html</a>，转载请注明。</p>",
            "$": {
              "type": "html"
            }
          }
        ]
      },
      {
        "id": [
          "http://www.cnblogs.com/ziyunfei/archive/2013/04/18/3019739.html"
        ],
        "title": [
          {
            "_": "[译]关于IE11,我们所知道的以及我们所能预料到的 - 紫云飞",
            "$": {
              "type": "text"
            }
          }
        ],
        "summary": [
          {
            "_": "原文:http://generatedcontent.org/post/47216611856/ie11最近,一个开发代号为Windows Blue的Windows操作系统泄漏到了互联网上,该操作系统的内置浏览器为IE11,本文将介绍一下这个泄漏版的IE11中有哪些关键的新变化和新特性.预先声明: 本文中所讲的内容都来自互联网,我自己没有安装过这个泄漏版的IE11,虽然我目前正在帮助微软的userAgents社区做一些工作,但我没有任何关于IE11未来计划的内部消息,本文只是对网上的那些消息做了一下总结,并加入了自己的看法和预测.一个新的身份标识关于IE11的第一个新闻就是它有了一个新的用户代",
            "$": {
              "type": "text"
            }
          }
        ],
        "published": [
          "2013-04-18T14:02:00Z"
        ],
        "updated": [
          "2013-04-18T14:02:00Z"
        ],
        "author": [
          {
            "name": [
              "紫云飞"
            ],
            "uri": [
              "http://www.cnblogs.com/ziyunfei/"
            ]
          }
        ],
        "link": [
          {
            "$": {
              "rel": "alternate",
              "href": "http://www.cnblogs.com/ziyunfei/archive/2013/04/18/3019739.html"
            }
          },
          {
            "$": {
              "rel": "alternate",
              "type": "text/html",
              "href": "http://www.cnblogs.com/ziyunfei/archive/2013/04/18/3019739.html"
            }
          }
        ],
        "content": [
          {
            "_": "<p><!-- BEGIN TUMBLR FACEBOOK OPENGRAPH TAGS --><!-- If you'd like to specify your own Open Graph tags, define the og:url and og:title tags in your theme's HTML. --><!-- Read more: http://ogp.me/ --><!-- END TUMBLR FACEBOOK OPENGRAPH TAGS --><!-- TWITTER TAGS --></p><p>原文:<a href=\"http://generatedcontent.org/post/47216611856/ie11\" target=\"_blank\">http://generatedcontent.org/post/47216611856/ie11</a></p><hr /><p>最近,一个开发代号为Windows Blue的Windows操作系统泄漏到了互联网上,该操作系统的内置浏览器为IE11,本文将介绍一下这个泄漏版的IE11中有哪些关键的新变化和新特性.</p><p><strong>预先声明:</strong> 本文中所讲的内容都来自互联网,我自己没有安装过这个泄漏版的IE11,虽然我目前正在帮助微软的<a href=\"http://useragents.ie/\" target=\"_blank\">userAgents社区</a>做一些工作,但我没有任何关于IE11未来计划的内部消息,本文只是对网上的那些消息做了一下总结,并加入了自己的看法和预测.</p><p><strong>一个新的身份标识</strong></p><p>关于IE11的第一个新闻就是它有了一个<a href=\"http://www.neowin.net/news/ie11-to-appear-as-firefox-to-avoid-legacy-ie-css\" target=\"_blank\">新的用户代理(UA)字符串</a>:</p><div style=\"background-color: #F5F5F5;border: 1px solid #CCCCCC;padding:10px;\">Mozilla/<span style=\"color: #800080;\">5.0</span> (IE <span style=\"color: #800080;\">11.0</span>; Windows NT <span style=\"color: #800080;\">6.3</span>; Trident/<span style=\"color: #800080;\">7.0</span>; .NET4.0E; .NET4.0C; rv:<span style=\"color: #800080;\">11.0</span>) like Gecko</div><p>其中有两个比较显著的变化:</p><ol><li>MSIE变成了IE</li><li>多了一个like Gecko字段</li></ol><p>第一个变化很明显是想让网站上现有的UA检测失效(译者注:因为现有的检测代码都是在检测MSIE字样).UA检测是为那些老版本的IE设计的,比如它们不支持<code>addEventListener等符合标准的特性,就得走专门的代码分支</code>.IE这样做就是在表示,它不再需要那些专门的检测代码,它可以执行符合标准的代码了.</p><p>关于后一个变化,有报道称这是IE在伪装成Firefox,这并不完全正确.Gecko的确是Firefox的渲染引擎,这没问题,但like gecko这个字段是WebKit最先使用的,IE添加该字段的理由和WebKit当年的理由一样,那就是,网站通常不会这么问浏览器:\"你想要IE私有的代码还是基于标准的代码?\",而是这么问:\"你是IE还是Gecko?\",也就是说,即使你支持标准也没有用,你的名字必须得是Gecko.虽然目前WebKit和IE实际上比Gecko更流行,但为了兼容已有的那些老站点,必须要加上这个字段.被识别成Gecko比被识别成Webkit要好的多,因为假如被识别成Webkit,就会遇到很多WebKit私有的甚至带属性前缀的代码,尤其是在移动站点上,伪装成Gecko能好一点.</p><p>改变UA字符串并不是这个版本的IE11用来伪装自己身份的唯一手段,还有navigator.<code>appName属性现在返回了</code><code>Netscape,而不是以前的M</code><code>icrosoft Internet Explorer,从而与</code>WebKit和Gecko的实现达成一致.虽然Opera/Presto没有这么干,不过它马上要切换到Blink内核了,所以所有浏览器的<code>appName属性都将会是</code>Netscape.</p><p>最后一个伪装方式,就是IE11现在会假装不支持<code>document.all</code>.如果你使用特性检测来检测浏览器是否支持<code>document.all</code>,它会像Firefox,WebKit,以及Opera一样,反回一个<code>false(译者注:在非IE浏览器中,<code>document.all</code>是个非常特殊的属性,它是一个对象值,但它同时又是一个假值,按照JS标准,这是不可能的,查看<a href=\"http://www.w3help.org/zh-cn/causes/BX9002\" target=\"_blank\">http://www.w3help.org/zh-cn/causes/BX9002</a>)</code>.为什么要这样做?难道特性检测不是一直提倡的做法吗?是的,但是,很多开发者们总用\"特性检测\"来充当\"浏览器检测\"(译者注:Maintainable JavaScript一书中把这种检测方式称之为\"浏览器推断\",是不推荐的做法),这是不对的,在Opera工作时,我曾无数次看到过下面这样的代码:</p><div style=\"background-color: #F5F5F5;border: 1px solid #CCCCCC;padding:10px;\"><span style=\"color: #0000ff;\">var</span> isIE = <span style=\"color: #0000ff;\">null</span><span style=\"color: #000000;\">;<br/></span><span style=\"color: #0000ff;\">if</span><span style=\"color: #000000;\"> (document.all) {<br/> isIE </span>= <span style=\"color: #0000ff;\">true</span><span style=\"color: #000000;\">;<br/>}<br/><br/></span><span style=\"color: #0000ff;\">if</span><span style=\"color: #000000;\"> (isIE) {<br/>  </span><span style=\"color: #008000;\">//</span><span style=\"color: #008000;\"> IE私有的代码,比如ActiveX,滤镜相关的</span><br/>} <span style=\"color: #0000ff;\">else</span><span style=\"color: #000000;\"> {<br/>  </span><span style=\"color: #008000;\">//</span><span style=\"color: #008000;\"> 符合标准的代码</span><br/>}</div><p>如果<code>document.all为真值</code>,则你马上断定它是IE,然后执行一些毫不相关的代码(译者注:指的是与document.all这个特性毫不相关的代码,这就是浏览器推断的表现).</p><p>如果IE以后假装不支持它,就可以<code>避免被识别出来</code>.另外一种可能是真的完全删除掉这个属性,但这样会破坏很多网站已有的代码.伪装不支持是一个很折衷的选择,浏览器开发商喜欢这么做.</p><p>但你必须记住,所有这些变化都发生在一个泄漏版的IE11中.很有可能是IE的开发者们想试验一下,看看这些变化执行之后的修复程度是否大于其破坏程度.我们不能过早的断定这些变化都会出现在最终版本的IE11中.</p><p>所有这些变化意味着什么呢.微软实际上在告诉全世界:\"IE已经成长了,它是与标准兼容的,它能够支持网站上所有符合标准的代码,我们不再希望有专门为IE准备的代码\".我比较倾向于相信这一点.IE10已经向前迈了一大步,IE11也许真的能够就标准实现上和其他浏览器进行竞争.</p><p><strong>ES6</strong></p><p>在这个泄漏版的IE11中,发现了两个ECMAScript 6(下一代JavaScript)中的新特性:</p><p><strong>__proto__</strong></p><p>在ECMAScript规范中,对象的原型用<var></var>[[Prototype]]内部属性来表示,我们并没有方法直接操作这个属性.ES6通过对<a href=\"http://people.mozilla.org/%7Ejorendorff/es6-draft.html#sec-B.3.1\" target=\"_blank\"><code>__proto__</code></a><code>属性进行标准化</code>改变了这一点.IE11现在也支持了__proto__属性,和Firefox,WebKit以及Opera一起.__proto__ 属性目前是非标准的,且我认为是个非常丑的API.</p><p><strong>WeakMap</strong></p><p>一个<a href=\"http://people.mozilla.org/%7Ejorendorff/es6-draft.html#sec-15.15\" target=\"_blank\"><code>WeakMap</code></a>对象是一个由键值对组成的映射,其中每个键值对中的键必须是一个对象值,并且如果除了这个键以外,一旦没有其他的引用指向这个对象时,这个对象就会被垃圾回收器回收掉,当然,引用它的那个键值对也就不复存在了.正因为这种表现,所以<code>WeakMap对象中的键是不能被遍历的</code>.WeakMap的一个典型的使用情形就是用它来保存对DOM节点的引用,每当一个DOM节点从文档中删除之后,对应的DOM对象就会被回收掉,WeakMap对象引用它的那个键值对也会被自动删除,这样减少了对内存的占用.</p><p><code>支持WeakMap的浏览器有</code>IE11,Firefox,以及Chrome(需要在chrome:flags页面中开启相关选项).</p><p><strong>WebGL</strong></p><p>如果说存在一个IE反对者们可以用来声称\"目前的IE仍然不属于现代浏览器\"的理由,那么这个理由就是IE还不支持WebGL.不过我个人认为,对于大部分web开发者来说,WebGL并不是一个最重要的特性,因为它是一个很复杂的技术,通常的网站不需要3D图形的显示.</p><p>但在某些场景下,WebGL的确是个很关键的因素,比如说游戏.Mozilla和Epic最近宣布了<a href=\"http://blog.mozilla.org/blog/2013/03/27/mozilla-is-unlocking-the-power-of-the-web-as-a-platform-for-gaming/\" target=\"_blank\">利用asm.js</a><a href=\"http://blog.mozilla.org/blog/2013/03/27/mozilla-is-unlocking-the-power-of-the-web-as-a-platform-for-gaming/\" target=\"_blank\">将Unreal 3引擎移植到JavaScript</a>的消息,这也就证明了Web越来越有能力成为真正的游戏平台,以至于微软也迫不及待的实现相关技术.</p><p>在这个泄漏版的IE11中,已经能够使用WebGL了,不过使用前必须要先<a href=\"http://withinwindows.com/within-windows/2013/3/30/blues-clues-how-to-enable-webgl-in-internet-explorer-11\" target=\"_blank\">导入一个注册表文件才行</a>,毕竟还在开发阶段,不能直接开放.一开始人们发现它只支持IESL着色语言(基于DirectX),而不是符合标准的GLSL(基于OpenGL),后来才发现原来注册表中的一个值能够控制浏览器在这两者之间切换.</p><p>不过我们不能高兴的太早.直到最终的IE11正式版发布之前,我们都不能确定它是否真的会成为IE11的特性.我记得当初Opera中的WebGL就是默认关闭的,因为当时让Opera访问一个带有WebGL内容的页面,就会导致操作系统的蓝屏死机(我认为这是着色器导致的).Safari目前也是默认禁用了WebGL.不过,既然微软正在实现WebGL,未来的IE11不包含它的可能性是非常小的.</p><p><strong>网络</strong></p><p>有证据显示,这个泄漏版的IE11<a href=\"http://withinwindows.com/within-windows/2013/4/1/blues-clues-internet-explorer-11-getting-spdy-support\" target=\"_blank\">已经支持了SDPY</a>,虽然目前还不是全功能的.所以我们有理由猜测,该特性会出现在最终版本的IE11中.</p><p>SPDY是一个由Google提出的,基于HTTP的网络协议.它的主要目的是想通过降低网络延迟,压缩请求头,以及减少客户端的连接数来加速网页的加载.虽然目前SPDY还不是标准,但IETF已经用它作为了<a href=\"http://en.wikipedia.org/wiki/HTTP_2.0\" target=\"_blank\">HTTP 2.0标准的</a>基础.</p><p>SPDY目前已经被Opera,Firefox,以及Chrome支持.</p><p><strong>DOM和JavaScript API</strong></p><p><strong>Mutation<span id=\"result_box\" class=\"short_text\" lang=\"zh-CN\"><span class=\"alt-edited\">观察者</span></span></strong></p><p>如果你想监视某些DOM变化,传统的做法就是去监听<a href=\"http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-eventgroupings-mutationevents\" target=\"_blank\">Mutation事件</a>.很多人都已经知道,Mutation事件是有设计缺陷的,因为它会导致严重的<a href=\"http://www.w3.org/2008/webapps/wiki/MutationReplacement#Background\" target=\"_blank\">性能问题</a>.正因为这个问题,Mutation事件现已被<a href=\"http://dev.w3.org/2006/webapi/DOM-Level-3-Events/html/DOM3-Events.html?rev=1.100#events-mutationevents\" target=\"_blank\">废弃</a>.</p><p>但是Mutation事件的功能是非常有用的,我们需要一个替代品,于是就有了DOM4中的<a href=\"http://www.w3.org/TR/domcore/#mutation-observers\" target=\"_blank\">Mutation观察者</a>.IE11实现了这一特性,和Chrome,Safari 6,以及Firefox一起,Opera一旦切换到Blink内核,也自然会继承到这一特性.</p><p><strong>全屏API</strong></p><p>有时,我们希望能够隐藏掉浏览器的窗口部分,让网页占据整个屏幕来显示.最常见的使用案例应该就是在播放视频的时候了,游戏算是第二常见的案例.<a href=\"http://www.w3.org/TR/fullscreen/\" target=\"_blank\">全屏API</a>能够让我们实现这一需求.</p><p>看起来IE11也要实现这一规范,因为这个泄漏版的IE11中已经有了<code>requestFullscreen方法,当然,是带有</code><code>ms前缀的,</code>剩余部分的规范应该会在接下来的版本中实现.另外,Opera也已经实现了这一规范中的所有API,且是不带前缀的.Safari,Chrome,以及Firefox中的实现是带前缀的.其中Firefox的当前实现是依据旧版规范草案的,Safari 5.1和Chrome 15&ndash;19也是(参考<a href=\"http://caniuse.com/fullscreen\" target=\"_blank\">caniuse.com</a>).</p><p>由于Metro IE(也许还有其他的名字)始终是全屏的,那么该特性也就主要在桌面环境中使用了.</p><p><strong>CSS</strong></p><p>关于IE11新增了哪些CSS特性,并没有太多的新闻,也许是因为还处于开发初期,并且IE10已经实现了不少新的CSS特性的原因.其中有一个好消息是,IE11更新了FlexBox的实现到最新版的规范草案(很有可能是最终版).Flexbox语法在IE10正式发布的前两天发生了变化,所以导致IE10实现了一个过时的语法.我在编写SmashingBook 3中的FlexBox一节时,就被这个问题所困扰.目前只有Opera 12.1,Chrome(带前缀),Firefox 22实现了新版的FlexBox规范,Safari实现的仍然是旧版的规范.</p><p><strong>接下来呢?</strong></p><p>下面说说我希望接下来IE11能够实现的新特性.比如我希望能够支持CSS中的tr<code>ansform-style: preserve-3d,这样可以让</code>3D效果更加完善.还有希望能支持<a href=\"http://www.w3.org/TR/css3-conditional/\" target=\"_blank\">CSS条件规则</a>中的<code>@supports,</code>曾经我在摩托罗拉工作时,通过那里的Webkit团队我推进了<code>@supports</code>特性在Webkit中的实现,现在不光WebKit,Firefox和Opera也都已经实现.另外,如果能支持<code>border-image也不错,</code>要是能支持WebM等其他的视频格式就更好了,不过这一点我不报太大希望.</p><p>因为ES6中的<code>WeakMap已经实现了</code>,所以以后实现更多的ES6特性也不会很奇怪了,尤其是考虑到现在<a href=\"http://www.typescriptlang.org/\" target=\"_blank\">TypeScript</a>也包含了不少ES6中的东西.类似的,还有微软自己的<a href=\"http://html5labs.interoperabilitybridges.com/prototypes/cu-rtc-web-roaming/cu-rtc-web-roaming/info\" target=\"_blank\">CU-RTC-Web</a>以及<a href=\"http://html5labs.interoperabilitybridges.com/prototypes/device-orientation-events/device-orientation-events/info\" target=\"_blank\"><span id=\"result_box\" class=\"short_text\" lang=\"zh-CN\"><span>设备方向</span></span></a>等特性的实现.我想我们会在过两天<span><span>旧金山举办</span></span>的<a href=\"http://www.buildwindows.com/\" target=\"_blank\">微软Build2013开发者大会</a>上得知更多.</p><p>最后,感谢<a href=\"http://fremycompany.com/BG/2013/Internet-Explorer-11-rsquo-s-leaked-build-395/\" target=\"_blank\">Fran&ccedil;ois Remy</a>和<a href=\"http://withinwindows.com/\" target=\"_blank\">Rafael Rivera</a>发掘并公布出此泄漏版IE11中的这么多隐藏特性.</p><img src=\"http://counter.cnblogs.com/blog/rss/3019739\" width=\"1\" height=\"1\" alt=\"\"/><br/><p>本文链接：<a href=\"http://www.cnblogs.com/ziyunfei/archive/2013/04/18/3019739.html\" target=\"_blank\">http://www.cnblogs.com/ziyunfei/archive/2013/04/18/3019739.html</a>，转载请注明。</p>",
            "$": {
              "type": "html"
            }
          }
        ]
      },
      {
        "id": [
          "http://www.cnblogs.com/ziyunfei/archive/2013/04/14/2972727.html"
        ],
        "title": [
          {
            "_": "[译]ECMAScript 6中的方法定义 - 紫云飞",
            "$": {
              "type": "text"
            }
          }
        ],
        "summary": [
          {
            "_": "原文:http://ariya.ofilabs.com/2013/03/es6-and-method-definitions.html在JavaScript的对象字面量中,属性值被设置成为一个函数是个很常见的做法.在各种JavaScript框架中,这种做法也很常见,尤其是用来设置构造函数的prototype属性对象的时候.在即将到来的ECMAScript 6中,引入了一种名叫方法定义(method definition)的新语法糖,相对于以前的完整写法,这种简写形式可以让你少写一个function键字.在介绍\"方法定义\"之前,让我们快速的回顾一下访问器属性.访问器属性是个可",
            "$": {
              "type": "text"
            }
          }
        ],
        "published": [
          "2013-04-13T16:20:00Z"
        ],
        "updated": [
          "2013-04-13T16:20:00Z"
        ],
        "author": [
          {
            "name": [
              "紫云飞"
            ],
            "uri": [
              "http://www.cnblogs.com/ziyunfei/"
            ]
          }
        ],
        "link": [
          {
            "$": {
              "rel": "alternate",
              "href": "http://www.cnblogs.com/ziyunfei/archive/2013/04/14/2972727.html"
            }
          },
          {
            "$": {
              "rel": "alternate",
              "type": "text/html",
              "href": "http://www.cnblogs.com/ziyunfei/archive/2013/04/14/2972727.html"
            }
          }
        ],
        "content": [
          {
            "_": "<style><!--code {    color: black;    background-color: #F7F7F9;    border: 1px solid #E1E1E8;    color: #DD1144;    padding: 2px 4px;    -moz-border-radius: 3px 3px 3px 3px;    color: #333333;    font-family: Monaco,Menlo,Consolas,\"Courier New\",monospace;    font-size: 12px;    padding: 0 3px 2px;}--></style><p class=\"lead\">原文:<a href=\"http://ariya.ofilabs.com/2013/03/es6-and-method-definitions.html\" target=\"_blank\">http://ariya.ofilabs.com/2013/03/es6-and-method-definitions.html</a></p><hr /><p class=\"lead\">在JavaScript的对象字面量中,属性值被设置成为一个函数是个很常见的做法.在各种JavaScript框架中,这种做法也很常见,尤其是用来设置构造函数的prototype属性对象的时候.在即将到来的ECMAScript 6中,引入了一种名叫<strong>方法定义(method definition)</strong>的新语法糖,相对于以前的完整写法,这种简写形式可以让你少写一个<code>function</code>键字.</p><p>在介绍\"方法定义\"之前,让我们快速的回顾一下访问器属性.访问器属性是个可以拥有setter和getter的属性,它是ECMAScript 5.1规范中的新特性,查看ES5中的<a href=\"http://es5.github.com/#x11.1.5\">11.1.5小节</a>中的Object Initialiser了解详情.访问器属性的原理就是使用<code>set</code>和<code>get</code>标记来将一个对象属性和两个函数绑定起来,在那个属性被读取或被赋值时,绑定的函数会被分别调用,下面的代码演示了访问器属性的用法:</p><div style=\"background-color: #F5F5F5;border: 1px solid #CCCCCC;padding:10px;\"><span style=\"color: #0000ff;\">var</span> BigLoco =<span style=\"color: #000000;\"> {<br/>  locoName: </span>'Gordon'<span style=\"color: #000000;\">,<br/>  get name() { </span><span style=\"color: #0000ff;\">return</span> <span style=\"color: #0000ff;\">this</span><span style=\"color: #000000;\">.locoName; },<br/>  set name(n) { </span><span style=\"color: #0000ff;\">this</span>.locoName =<span style=\"color: #000000;\"> n }<br/>};<br/> <br/>console.log(BigLoco.name); </span><span style=\"color: #008000;\">//</span><span style=\"color: #008000;\"> 'Gordon'</span></div><p>在该代码中,我们的确声明了两个函数,但是没有使用<code>function</code>关键字.在ECMAScript 6中,这一语法得到了进一步的扩展,不光访问器属性,普通的值为函数的数据属性(通常称之为方法)也可以了.这个新语法就称之为\"方法定义\",查看最近的<a href=\"http://wiki.ecmascript.org/doku.php?id=harmony:specification_drafts\" target=\"_blank\">ES6草案</a>中的第<a href=\"http://teramako.github.com/ECMAScript/ecma6th_syntax.html#13.3\" target=\"_blank\">13.3小节</a>了解详情.</p><p>看一下下面的这个ECMAScript 6代码片段,尤其要注意<code>start</code>和<code>stop</code>函数.</p><div style=\"background-color: #F5F5F5;border: 1px solid #CCCCCC;padding:10px;\"><span style=\"color: #0000ff;\">var</span> SteamEngine =<span style=\"color: #000000;\"> {<br/>  color: </span>'blue'<span style=\"color: #000000;\">,<br/>  get name() { </span><span style=\"color: #0000ff;\">return</span> 'Thomas'<span style=\"color: #000000;\"> },<br/>  start() { console.log(</span>'Hurry up!'<span style=\"color: #000000;\">); },<br/>  stop() { console.log(</span>'Screech...! That was close.'<span style=\"color: #000000;\">); }<br/>};<br/> <br/>console.log(</span>'My name is'<span style=\"color: #000000;\">, SteamEngine.name);<br/>SteamEngine.start();<br/>SteamEngine.stop();</span></div><p>如果我们把上面的代码转换成ES5代码,则转换结果会是这样:</p><div style=\"background-color: #F5F5F5;border: 1px solid #CCCCCC;padding:10px;\"><span style=\"color: #0000ff;\">var</span> SteamEngine =<span style=\"color: #000000;\"> {<br/>  color: </span>'blue'<span style=\"color: #000000;\">,<br/>  get name() { </span><span style=\"color: #0000ff;\">return</span> 'Thomas'<span style=\"color: #000000;\"> },<br/>  start: </span><span style=\"color: #0000ff;\">function</span>() { console.log('Hurry up!'<span style=\"color: #000000;\">); },<br/>  stop: </span><span style=\"color: #0000ff;\">function</span>() { console.log('Screech...! That was close.'<span style=\"color: #000000;\">); }<br/>};</span></div><p>我觉的这种新的语法糖很不错!</p><img src=\"http://counter.cnblogs.com/blog/rss/2972727\" width=\"1\" height=\"1\" alt=\"\"/><br/><p>本文链接：<a href=\"http://www.cnblogs.com/ziyunfei/archive/2013/04/14/2972727.html\" target=\"_blank\">http://www.cnblogs.com/ziyunfei/archive/2013/04/14/2972727.html</a>，转载请注明。</p>",
            "$": {
              "type": "html"
            }
          }
        ]
      },
      {
        "id": [
          "http://www.cnblogs.com/ziyunfei/archive/2013/04/13/3017571.html"
        ],
        "title": [
          {
            "_": "[译]JavaScript引擎中的自动函数内联 - 紫云飞",
            "$": {
              "type": "text"
            }
          }
        ],
        "summary": [
          {
            "_": "原文:http://ariya.ofilabs.com/2013/04/automatic-inlining-in-javascript-engines.html想当年,在JavaScript解释器的运行速度还很慢的时候,有一条最佳实践就是\"不要在性能关键(performance-critical)的代码中使用函数调用\".随着最近现代JavaScript引擎的不断发展,这条最佳实践变的不是那么必要了.其中,能在很大程度上减少我们对\"频繁的函数调用会消耗过多性能\"的担心的一个新特性就是自动函数内联(automatic function inlining).",
            "$": {
              "type": "text"
            }
          }
        ],
        "published": [
          "2013-04-13T03:57:00Z"
        ],
        "updated": [
          "2013-04-13T03:57:00Z"
        ],
        "author": [
          {
            "name": [
              "紫云飞"
            ],
            "uri": [
              "http://www.cnblogs.com/ziyunfei/"
            ]
          }
        ],
        "link": [
          {
            "$": {
              "rel": "alternate",
              "href": "http://www.cnblogs.com/ziyunfei/archive/2013/04/13/3017571.html"
            }
          },
          {
            "$": {
              "rel": "alternate",
              "type": "text/html",
              "href": "http://www.cnblogs.com/ziyunfei/archive/2013/04/13/3017571.html"
            }
          }
        ],
        "content": [
          {
            "_": "<p class=\"lead\">原文:<a href=\"http://ariya.ofilabs.com/2013/04/automatic-inlining-in-javascript-engines.html\" target=\"_blank\">http://ariya.ofilabs.com/2013/04/automatic-inlining-in-javascript-engines.html</a></p><hr /><p class=\"lead\">想当年,在JavaScript解释器的运行速度还很慢的时候,有一条最佳实践就是\"不要在性能关键(performance-critical)的代码中使用函数调用\".随着最近现代JavaScript引擎的不断发展,这条最佳实践变的不是那么必要了.其中,能在很大程度上减少我们对\"频繁的函数调用会消耗过多性能\"的担心的一个新特性就是<strong>自动函数内联(automatic function inlining)</strong>.</p><p>考虑下面的代码:</p><div style=\"background-color: #F5F5F5;border: 1px solid #CCCCCC;padding:10px;\"><span style=\"color: #0000ff;\">function</span><span style=\"color: #000000;\"> square(x) {<br/>  </span><span style=\"color: #0000ff;\">return</span> x *<span style=\"color: #000000;\"> x;<br/>}<br/> <br/></span><span style=\"color: #0000ff;\">function</span><span style=\"color: #000000;\"> f(x) {<br/>  </span><span style=\"color: #0000ff;\">var</span> sum = 0<span style=\"color: #000000;\">;<br/>  </span><span style=\"color: #0000ff;\">for</span> (<span style=\"color: #0000ff;\">var</span> i = 0; i &lt; x; i++<span style=\"color: #000000;\">) {<br/>    sum </span>+=<span style=\"color: #000000;\"> square(i);<br/>  }<br/>  </span><span style=\"color: #0000ff;\">return</span><span style=\"color: #000000;\"> sum;<br/>}</span></div><div class=\"wp_syntax\">如果<code>x是一个比较大的数字</code>,则执行<code>f(x)的时候会非常多次的对</code><code>square函数进行调用</code>.即使该函数的单次调用的性能开销非常小,如果反复执行非常多次,这个性能开销也会变的非常显著.为此,就有了\"不要在长循环体内进行函数调用\"这样的一条最佳实践.</div><p>幸运的是,当这部分代码被执行的非常\"<strong>热\"</strong>(hot,指执行了非常多次)时,一个现代的JavaScript引擎能够感知到这一点并对其进行优化.在很多优化手段中,最简单的一条优化就是不要在每次循环中真正的调用squ<code>are函数,而是直接对该函数进行内联(inline),因为这个函数非常简单,内联之后对代码的逻辑不会有任何影响</code>.内联的意思就是说,你的代码会像下面这样的代码一样被执行:</p><div style=\"background-color: #F5F5F5;border: 1px solid #CCCCCC;padding:10px;\"><span style=\"color: #0000ff;\">function</span><span style=\"color: #000000;\"> f(x) {<br/>  </span><span style=\"color: #0000ff;\">var</span> sum = 0<span style=\"color: #000000;\">;<br/>  </span><span style=\"color: #0000ff;\">for</span> (<span style=\"color: #0000ff;\">var</span> i = 0; i &lt; x; i++<span style=\"color: #000000;\">) {<br/>    sum </span>+= i *<span style=\"color: #000000;\"> i;<br/>  }<br/>  </span><span style=\"color: #0000ff;\">return</span><span style=\"color: #000000;\"> sum;<br/>}</span></div><p>怎么才能证明JavaScript引擎真的会对上述代码执行内联优化呢?下面是一个可行的证明方法:使用V8 debugger shell.首先,为了确保引擎会对我们的代码进行优化(代码能够变得非常\"热\"),我们再上述代码的基础上再加上这么一行:</p><div style=\"background-color: #F5F5F5;border: 1px solid #CCCCCC;padding:10px;\"><span style=\"color: #0000ff;\">for</span> (<span style=\"color: #0000ff;\">var</span> x = 0; x &lt; 10000; ++x) f(1e4);</div><div class=\"wp_syntax\">现在,如果你<a href=\"https://developers.google.com/v8/build\" target=\"_blank\">编译过V8</a>并且手头已经有了V8 debugger shell(<code><a href=\"http://files.cnblogs.com/ziyunfei/d8.zip\">d8.exe</a>)</code>,在命令行上执行下面的代码:</div><div style=\"background-color: #F5F5F5;border: 1px solid #CCCCCC;padding:10px;\">d8 --trace-inlining sum.js</div><div class=\"wp_syntax\">就会输出这样一条信息(也可能还会有其他信息):</div><div style=\"background-color: #F5F5F5;border: 1px solid #CCCCCC;padding:10px;\">Inlined square called from f.</div><p>这就证明了V8最终决定不去反复的执行函数调用,还是去内联这个函数.</p><p>如果你以前经常会在给浏览器执行代码之前手动的进行函数内联操作,现在是时候改变这一做法了.你尽管考虑可维护性,即便把代码分成若干个很小的函数也没关系!在大多数情况下,我们可以相信现代的JavaScript引擎能够自动的对那些小函数进行内联优化.</p><img src=\"http://counter.cnblogs.com/blog/rss/3017571\" width=\"1\" height=\"1\" alt=\"\"/><br/><p>本文链接：<a href=\"http://www.cnblogs.com/ziyunfei/archive/2013/04/13/3017571.html\" target=\"_blank\">http://www.cnblogs.com/ziyunfei/archive/2013/04/13/3017571.html</a>，转载请注明。</p>",
            "$": {
              "type": "html"
            }
          }
        ]
      }
    ]
  }
}