{
  "rss": {
    "$": {
      "version": "2.0",
      "xmlns:atom": "http://www.w3.org/2005/Atom"
    },
    "channel": [
      {
        "title": [
          "limu的砖篮儿"
        ],
        "description": [
          "李穆(淘宝花名:李牧).\r\n一淘UX前端负责人"
        ],
        "link": [
          "http://limu.iteye.com"
        ],
        "language": [
          "zh-CN"
        ],
        "copyright": [
          "Copyright 2003-2012, ITeye.com"
        ],
        "docs": [
          "http://blogs.law.harvard.edu/tech/rss"
        ],
        "generator": [
          "ITeye - 做最棒的软件开发交流社区"
        ],
        "atom:link": [
          {
            "$": {
              "href": "http://limu.iteye.com/rss",
              "rel": "self",
              "type": "application/rss+xml"
            }
          }
        ],
        "item": [
          {
            "title": [
              "CSSLoader实现思路以及与JSLoader的异同"
            ],
            "description": [
              "\n              \n              童鞋们新年好，2012年只发了两篇水文，就这么过去了，实在汗颜。话说大家都转移阵地去微博和github讨论问题了，谁让iteye还不支持markdown呢<img src=\"/images/smiles/icon_lol.gif\" /> 。\r<br />\r<br />今天说说我不熟悉的领域CSS，因为手里的项目实在需要，所以最近花了不少精力在我有限的CSS知识范围内寻找解决方案，也经过和很多同事讨论碰撞，不如记录一下。\r<br />\r<br /><strong><span style=\"font-size: large;\">CSS也需要模块化</span></strong>\r<br />CSS也需要模块化，这个其实不需要说太多，大家也都是这么做的。在开发阶段css伴随这个各个模块存在。隐约记得还有不少关于面向对象CSS的讨论，也有Less和SASS这种加强CSS结构化的工具。\r<br />\r<br />而在上线前往往需要将各处散落的CSS文件统一合并，或更智能的实时combo。所以今天讨论的CSSLoader是开发时使用。\r<br />\r<br /><strong><span style=\"font-size: large;\">CSS模块间存在依赖关系，但用JS模块管理方式一并管理不够恰当</span></strong>\r<br />CSS模块间存在依赖关系，常见的情况是所有css都依赖框架的reset.css，然后可能各个css也都依赖项目通用css如project.css。\r<br />\r<br />但是用js模块管理方式来管理css模块是不够合适的，有以下一些问题：\r<br />1. 当前的JSLoader，往往只支持，一个js模块依赖若干css模块，并非真正的支持css间的依赖。\r<br />2. css文件内，不支持js语法，所以无法描述它的依赖。内置的@import有它的问题，稍后讲讲。\r<br />\r<br />在讨论中，我们发现还是从CSS的特点出发，为它量身定制Loader解决方案为佳。\r<br />\r<br />\r<br /><strong><span style=\"font-size: large;\">CSS特点是有层次，那么理想的项目CSS规划怎样</span></strong>\r<br />CSS的全称是层叠样式表，这其实说明了CSS的特点是有层次的，而这一点在JS中表现的并不明显，特别大家通过模块化屏蔽了全局变量相互覆盖带来的影响之后。\r<br />\r<br />CSS的层次的特点是，下层的CSS规则，可以覆盖上层的CSS规则，所以我觉得网页理想的CSS规划是每一个CSS模块都能明确其所属层次。\r<br />\r<br />这样的网页CSS层次如下图所示，这也是我们当前项目中的结构：\r<br />\r<br /><img src=\"http://dl.iteye.com/upload/attachment/0079/0897/5c1b0831-2494-3901-804a-77be162fdbcc.png\" />\r<br />\r<br />1. reset.css ： 底层类库提供的通用\r<br />2. project.css ：项目内通用的css，在我们的项目中可能存在其他项目的project.css，因为我希望不同项目中间的组件可以共享\r<br />3. widget.css ：组件的通用css\r<br />4. widgetInstance.css ：组件实例特有的css\r<br />\r<br />可以看出在css分层次规划的背景下，css文件的依赖次序是固定的，4 -&gt; 3 -&gt; 2 -&gt; 1 。 回过头来css的加载顺序应该是1、2、3、4，必须串行。\r<br />\r<br />我们看到这样的规划下css模块是一棵树，如果projcet2.css依赖widget1-1.css显然是不合理的。而js的模块依赖是一张没有闭环即可的图（闭环==循环引用）。\r<br />\r<br />简单总结下<strong>理想的CSS规划策略</strong>：\r<br /><span style=\"color: darkblue;\">\r<br />1. 为网页的css划分层次，让每个css模块有明确的层次属性\r<br />2. 同一层次内的不同css模块，相互间不应该存在冲突的定义\r<br />3. 下层css模块只可以覆盖其所依赖的上层css模块中的部分规则\r<br /></span>\r<br />\r<br /><strong><span style=\"font-size: large;\">CSSLoader的要点</span></strong>\r<br />\r<br /><strong>精确的的onload事件</strong>\r<br />我们必须保证上层css加载进来、规则完全应用好之后才能加载下层css。这样我们就需要一个精确的onload事件，在早期的getScript方法加载css文件时，只要把请求发了就立即触发onload，以草草达到和js模块一致的回调。而最近这方面的研究已经比较完善，kissy1.2以及seajs的很早的版本就支持真正的css文件onload回调。推荐seajs的做法，因为404时同样会触发回调。代码在这里<a href=\"https://github.com/seajs/seajs/blob/master/src/util-fetch.js#L82\" target=\"_blank\">https://github.com/seajs/seajs/blob/master/src/util-fetch.js#L82</a>，测试用例在这里<a href=\"http://seajs.org/tests/issues/load-css/test.html\" target=\"_blank\">http://seajs.org/tests/issues/load-css/test.html</a>，感谢玉伯。\r<br />\r<br />我们注意到这里的css加载实现是动态构建link节点，但是在IE下有效的link节点有个数限制，所以方案并不完美。那么其实其他所有为页面引入css的方法都可以用，但前提是需要有靠谱的回调。甚至可以研究下，让css文件也能将载入和规则应用分离开的高级样式引入方式。\r<br />\r<br /><strong>并发处理</strong>\r<br />一定存在同时初始化多个widget的情况，那么并发加载inst1-1-1和inst1-1-2时，要确保其共同的上层，如projcet1.css最先加载并且不能重复加载。在这一点上可以，参照JSLoader的实现模式，将已经载入的模块记录在案。这一点也引出了@import的问题，如果两个inst里边都写了@import project1.css，那么可能会出现inst1-1-1覆盖projcet1的规则又被覆盖回去的情况。\r<br />\r<br />更进一步，当一个加载任务队列正在进行时，又开启了另一个加载任务队列，如果我们能按照css模块的层次顺序，将两个队列merge成一个队列再继续执行，看起来会更好些。\r<br />\r<br /><strong><span style=\"font-size: large;\">API示意</span></strong>\r<br />简单构想了一下扩展后的API，一串CSS加载任务发起还是由JS模块承担。\r<br />\r<br />基于Kissy的话，需要add方法，为js模块增加cssRequires配置项，区别于requires，cssRequires数组内的文件需要按顺序串行加载，能够标识css模块的层次更好。\r<br />\r<br /><pre name=\"code\" class=\"js\">\r\nKISSY.add('mywidget',function(){\r\n\t//...\r\n},{\r\n\trequires:['mod-a','mod-b'],\r\n\tcssRequires:['reset.css:1','projcet.css:2','widget.css:3','instance.css:4']\r\n});\r\n</pre>\r<br />\r<br />在KISSY.use的时候原有逻辑负责js的加载，同时丢一个任务给新实现的cssLoader，去按层次加载css。\r<br />\r<br /><strong><span style=\"font-size: large;\">脆弱的方案</span></strong>\r<br />这绝对不是一个完美的解决方案，当前的实现方案基于“理想的CSS规划策略”，需要分层、同层次不冲突、仅向依赖的上层覆盖，这三点完全做到，而这里最大的挑战似乎是如何技术化的保障同一层次的css不会出现冲突。\r<br />\r<br />在天然的浏览器环境没有很好的提供我们需要的feature时，等待它进化还是不现实的，很多时候就是靠我们能掌控全局这一优势，在不同环节各退一步，达成一个可以勉强运转体系。\r<br />\r<br />好在这个方案是在开发时运转，而且明确的css规划也为真正线上产品的css打包或自动combo提供了便利。\r<br />\r<br /><strong><span style=\"font-size: large;\">简单发散一下</span></strong>\r<br />\r<br /><strong>让层次描述更灵活</strong>\r<br />约定4个层次，还是太死板了，我们可以参照zIndex的设计，让层次数值之间存在大量空隙供扩展。\r<br />\r<br /><strong>其他实现方案</strong>\r<br />可能有把css写在js里的方案，有基于less、sass扩展的方案，有开发时跑一个本地服务的方案（类似grunt）。这些都好，但对于如今我们手上的项目来说不够敏捷。其实没准有人已经实现过，欢迎知道的同学推荐。\r<br />\r<br />\r<br /><strong><span style=\"font-size: large;\">最后</span></strong>\r<br />真的不太会CSS，如果有误请帮忙指出，如果有好的方案或者相关的研究都推荐过来吧，谢谢~\n              \n              <br/><br/>\n              <span style=\"color:red;\">\n                <a href=\"http://limu.iteye.com/blog/1767177#comments\" style=\"color:red;\">已有 <strong>2</strong> 人发表留言，猛击-&gt;&gt;<strong>这里</strong>&lt;&lt;-参与讨论</a>\n              </span>\n              <br/><br/><br/>\n<span style=\"color:#E28822;\">ITeye推荐</span>\n<br/>\n<ul><li><a href='/clicks/433' target='_blank'><span style=\"color:red;font-weight:bold;\">—软件人才免语言低担保 赴美带薪读研！— </span></a></li></ul>\n<br/><br/><br/>\n              \n            "
            ],
            "pubDate": [
              "Wed, 09 Jan 2013 23:36:23 +0800"
            ],
            "link": [
              "http://limu.iteye.com/blog/1767177"
            ],
            "guid": [
              {
                "_": "http://limu.iteye.com/blog/1767177",
                "$": {
                  "isPermaLink": "false"
                }
              }
            ]
          },
          {
            "title": [
              "D2归来晒PPT"
            ],
            "description": [
              "\n              \n              D2归来60分钟，2个分享，88页PPT，趁热发。\r<br />特别感谢教主大大<a href=\"http://weibo.com/u/1900199050\" target=\"_blank\">@_Franky</a>和灰大<a href=\"http://weibo.com/otakustay\" target=\"_blank\">@otakustay</a>的支持，我们共同完成了第三方内容开发这个section。\r<br />很高兴认识很多朋友，遗憾是做分享和赶PPT错过了很多想听的内容，等后续视频放出来了。\r<br />\r<br /><a href=\"http://www.slideshare.net/leneli/ss-13569940\" target=\"_blank\">广告代码和创意代码持续优化</a>\r<br /><a href=\"https://speakerdeck.com/u/lenel/p/taobao-ad-jsbeacon-and-creative-optimize\" target=\"_blank\">（墙内）</a>\r<br /><a href=\"http://www.slideshare.net/leneli/d2etaoshow\" target=\"_blank\">OPOA那些事儿</a>\r<br /><a href=\"https://speakerdeck.com/u/lenel/p/etao-ux-magix-and-brix\" target=\"_blank\">（墙内）</a>\r<br />这两个分享基于前两年的几项工作，下边是另外两个PPT\r<br />\r<br /><a href=\"http://www.slideshare.net/leneli/kslite\" target=\"_blank\">使用KsLite支持第三方内容开发</a>\r<br /><a href=\"https://speakerdeck.com/u/lenel/p/kslite-for-3rd-part-content-develop\" target=\"_blank\">（墙内）</a>\r<br /><a href=\"http://www.slideshare.net/leneli/magixjswebapp\" target=\"_blank\">OPOA实战</a>\r<br /><a href=\"https://speakerdeck.com/u/lenel/p/opoa-in-action\" target=\"_blank\">（墙内）</a>\r<br />-- 这是“OPOA那些事儿”的原始文件之一，有108页PPT，算是MagixJS对于优化OPOA开发比较全面的阶段性总结。\r<br />\r<br />再单列一下一淘UX前端团队正在维护的两个项目\r<br />\r<br /><img src=\"http://dl.iteye.com/upload/attachment/0070/4490/6e296e3d-cc74-3dc0-be5f-7d348adaf31d.png\" />\r<br /><a href=\"https://github.com/limu/magix\" target=\"_blank\">MagixJS For OPOA since 2011</a>\r<br />\r<br />\r<br /><img src=\"http://dl.iteye.com/upload/attachment/0070/4492/99cbe1e5-348b-35d6-8cdb-a1d132397319.png\" />\r<br /><a href=\"https://github.com/etaoux/brix\" target=\"_blank\">Brix For Components since 2012</a>\n              \n              <br/><br/>\n              <span style=\"color:red;\">\n                <a href=\"http://limu.iteye.com/blog/1581103#comments\" style=\"color:red;\">已有 <strong>0</strong> 人发表留言，猛击-&gt;&gt;<strong>这里</strong>&lt;&lt;-参与讨论</a>\n              </span>\n              <br/><br/><br/>\n<span style=\"color:#E28822;\">ITeye推荐</span>\n<br/>\n<ul><li><a href='/clicks/433' target='_blank'><span style=\"color:red;font-weight:bold;\">—软件人才免语言低担保 赴美带薪读研！— </span></a></li></ul>\n<br/><br/><br/>\n              \n            "
            ],
            "pubDate": [
              "Sat, 07 Jul 2012 21:35:26 +0800"
            ],
            "link": [
              "http://limu.iteye.com/blog/1581103"
            ],
            "guid": [
              {
                "_": "http://limu.iteye.com/blog/1581103",
                "$": {
                  "isPermaLink": "false"
                }
              }
            ]
          },
          {
            "title": [
              "春运刷票的那些年"
            ],
            "description": [
              "\n              \n              其实这篇也可以叫：《那些年，我们一起刷酷讯》。\r<br />\r<br />每年春运买火车票这事儿都能让京飘的同学们愁上个把月，其实每年也没看到谁回不去。04、05想找一张二手票很难，263跳蚤市场，水木，贴吧到处去淘。到了06春节前，事情有了转机，出现了这么个网站kooxoo.com，发迹于水木清华bbs，做的事情就是垂直搜索二手火车票转让信息，这个网站就是如今大名鼎鼎的酷讯。\r<br />\r<br />刷酷讯也不那么容易，往往刷到了二手信息要不电话打不通，要不加价高的离谱。于是，就有了刷票脚本v1.0。从06到11年这小脚本一直升级到了v6.0，<strong><span style=\"color: red;\">而功能其实很简单，开一个网页每隔三五分钟刷下酷讯的页面，和上次的结果做比较，发现新的信息就弹出个提示。</span></strong>这样就不用一直盯着网页看，又能第一时间拿到信息。那些有能量的人，经常会从多个渠道拿到重复的车票，他们并不屑于冒风险赚个几百差价，这就是最理想的交易对象。\r<br />\r<br />这个小脚本见证了酷讯的变化，也记载了一次次爬与被爬之间小小的博弈。今年火车票全面实名制，我想我和酷讯都可以好好歇歇了，回忆这几年写脚本的过程，还是有些技术点蛮有意思的，特别这个小脚本一直使用JavaScript实现，而JS在浏览器端受到了诸多限制，趁着还没全忘，在此记录一下。\r<br />\r<br />不过先说明下这个小脚本的使用者除了我，也就是部门内的一些同事，刷新频率也一直没有改的过于频繁，对酷讯的影响绝不会超过半个QPS，若说我攻击还是省省哈。\r<br />\r<br />【跨域XHR】\r<br />脚本的实现方案主要分为两种：跨域XHR和第三方脚本潜入。06、07年，我用的是前面一种。\r<br />\r<br />我首先想到的是用iframe或者frameset把kx的页面潜入到我的页面中，然后我的页面访问kx页面的内容，我们当时的系统中成天这样干。但很快发现这不可能，这是我的前端技术生涯中第一次遇到了跨域问题。现在回顾一下各种跨域解决方案，在酷讯无法控制的情况下，这个问题依然是无解的（或许通过加入信任站点？）。好在当时也没有纠结太久，就转向了另一个方案。\r<br />\r<br />通过XHR获取页面的内容，然后解析文本。大家马上会想到，依然会有域名大山存在，不过幸运的是，<strong><span style=\"color: red;\">在IE6里边，从文件系统直接打开本地html文件，在允许脚本运行后，是可以发送跨域XHR请求并拿到响应体的</span></strong>。基于这个事实，后面的一切就简单的多了，通过XHR获取数据，然后把数据抽取出来结构化，过一段时间再抽取一次，做比较，有新的，弹出alert提示。\r<br />\r<br />【Firefox GreaseMonkey插件 脚本潜入】\r<br />到07进入阿里，不再做IEOnly，开始接触兼容性开发。我发现了Firefox非常牛X的插件GreaseMonkey，传说中的“油猴”。<strong><span style=\"color: red;\">GreaseMonkey的作用就是可以指定在某种类型的url中，自动潜入一个本地脚本运行</span></strong>。这相当于在我的浏览器里我可以控制其他域名的网页了。所以在08年，刷票脚本的技术方案改为脚本潜入。相对与前一个方案，这个方案因为可以直接访问对方页面的Dom树，不用解析文本，而且从之前分析prototype.js源码得知Firefox浏览器还支持XPath，XML里类似CSS选择器，一下子获取数据变得容易且稳定许多。\r<br />\r<br />后来油猴成为了我的大玩具，最成功的插件是开心网停车脚本，全自动停车，十分钟换地方，想贴条那是没门。当然还有自动贴条脚本，太伤人品，没有扩散，呵呵。\r<br />\r<br />【GreaseMonkey本地存储和GlobalStorage】\r<br />改为脚本潜入也不是一点障碍没有，在跨域XHR方案中，多次获取的页面数据统一在内存中，比较起来非常方便。而改为脚本潜入的模式的V3.0，每次刷新页面，如何保持数据成了一个重要问题，存在cookie中有些丑陋，而且暴露给对方服务器了。好在<strong><span style=\"color: red;\">GreaseMonkey插件提供了本地存储功能，用它记录前一个页面的信息，以备后面比较</span></strong>。我不记得API是什么了，暂且叫他GMStorage吧，和Html5本地存储接口差不多。而在09年的v4.0我就直接使用了本地存储，当时还叫GlobalStorage，而不是LocalStorage。\r<br />\r<br />【GreaseMonkey的安全改进DomWrapper】\r<br />GreaseMonkey越来越流行，其潜在的安全问题也是巨大的，随意安装GM脚本，你的所有网页浏览行为，键盘输入都可能被监听记录。\r<br />09年V4.0开发时，我发现油猴做了一些改变，油猴脚本里拿到的document，不在是真是的document，很多操作变的没有效果。\r<br />这必须Hack一下，我尝试了几种办法，发现<strong><span style=\"color: red;\">在油猴脚本里边使用DomScriptElement方法创建一个script节点，另载入一个外部脚本，另外一个脚本的运行不受任何GM的安全限制</span></strong>。\r<br />其实我觉得GM的DomWrapper还不如不做，它迫使人们引入另外一个远程脚本，也使得脚本开发者更容易的通过改变另外一个脚本的内容神不知鬼不觉的做些坏事。\r<br />\r<br />【酷讯的变化：从堵到疏】\r<br />记得07年阿里第一届网侠大会，酷讯的哥们分享他们如何爬到数据，就神秘的提了一下，借助前端脚本抓取，我在下边听着暗笑~，大家手法是一样一样一样的啊。\r<br />随着年复一年的口碑相传，用酷讯淘票的人越来越多。我估计类似我的小脚本的各式各样工具也越来越多。面对这类问题，酷讯明显的经历了一个由堵到疏的过程。\r<br />某一年，酷讯在请求时带上了两个参数，记录鼠标点击位置相对搜索按钮左上角的像素差。\r<br />某一年，酷讯不再使用顺序的id，每条信息的ID都是一个随机串，这样判断是否有新信息变得麻烦。\r<br />\r<br />但是客户端没有秘密而言，这些小手段都可以被轻易化解，估计效果并不是很好。\r<br />\r<br />再后来酷讯可能也注意到没有太好的办法堵，就改为疏导，改为本身提供这类自刷新功能，有新信息气泡提示，这样方便的控制刷新频率（似乎间隔越来越长），降低服务器的压力。\r<br />\r<br />在10年的V5.0中,脚本只是简单的控制自刷新频率，做更醒目的提示。且更多的利用本地存储，记录以往的搜索信息供比对。\r<br />\r<br />【Bookmarklet 脚本潜入】\r<br />我最早发现Bookmarklet应用是CSDN的一个转帖插件，<strong><span style=\"color: red;\">Bookmarklet的核心是构造一个连接，连接内容是javascript:伪协议，把这个链接拖入收藏夹，在任意页面上点击这个连接，都会运行js为协议里包含的脚本内容，脚本内容常常是通过DomScriptElement引入一个远程脚本</span></strong>，这样也达到了脚本潜入的目的。这个技术后来被广泛应用于各种云输入法当中而被大家熟知。\r<br />因为Bookmarklet不限制浏览器，酷讯提供了Ajax获取新信息接口（不用刷整个页面），IE8支持了LocalStorage，10年的V5.0版本脚本即支持GM也支持BM，刷票脚本再次回归IE怀抱。不过BM需要每次点一下，这个还是比GM要麻烦一点点。\r<br />\r<br />\r<br />【其他网站的分流】\r<br />11年的V6.0是脚本效果最差的一年，因为酷讯的效果感觉不那么即时了，58这类的网站分流了酷讯的客流。今年大家都不用做这一块了，不过真心希望业界丰富建站经验的高手们，能够承担12306.cn的建设工作，这个站的体验和稳定性太次了，其实俺觉得包给淘宝做就挺好，呵。\r<br />\r<br />前面就是这几年写刷票脚本的流水账，不用再做了，大家都释然吧。\r<br />特别感谢酷讯，多年来行善举造福大家。\r<br />祝新老朋友今年顺利拿到平价车票，开开心心过大年。\n              \n              <br/><br/>\n              <span style=\"color:red;\">\n                <a href=\"http://limu.iteye.com/blog/1333292#comments\" style=\"color:red;\">已有 <strong>0</strong> 人发表留言，猛击-&gt;&gt;<strong>这里</strong>&lt;&lt;-参与讨论</a>\n              </span>\n              <br/><br/><br/>\n<span style=\"color:#E28822;\">ITeye推荐</span>\n<br/>\n<ul><li><a href='/clicks/433' target='_blank'><span style=\"color:red;font-weight:bold;\">—软件人才免语言低担保 赴美带薪读研！— </span></a></li></ul>\n<br/><br/><br/>\n              \n            "
            ],
            "pubDate": [
              "Tue, 03 Jan 2012 00:39:32 +0800"
            ],
            "link": [
              "http://limu.iteye.com/blog/1333292"
            ],
            "guid": [
              {
                "_": "http://limu.iteye.com/blog/1333292",
                "$": {
                  "isPermaLink": "false"
                }
              }
            ]
          },
          {
            "title": [
              "JavaScript的那些书"
            ],
            "description": [
              "\n              \n              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 又好久没写东西了,写上一篇的时候还以为接下来的工作会轻松一些,结果未从我所愿呐,又是一阵忙碌.而这段时间穿插着做了很多12年淘宝校园招聘的前端面试,很多同学都有问到,学校里没有前端的课程,那如何学习JavaScript?\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 我的回答是:读书吧~相对于在网上学习,在项目中学习和跟着有经验的同事学习,书中有着相对完整的知识体系,每读一本好书都会带来一次全面的提高.而如果深一脚浅一脚的学习,写出代码的质量会参差不齐.初学者的首要任务是成为靠谱的熟练开发者,能够稳定的输出有一定质量的代码,这样才能让人放心的把任务交给你.从这个角度来看,跟着w3school类成体系的网络教程学习也是不错的选择,只不过我没有亲自实践过.\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在07年之前,我是在做IEonly的企业级B/S应用,虽然当时项目的JScript就已经非常复杂,但当时团队里有很多经验丰富的同事,多是跟他们请教,或者再MSDN和网上找答案.07年进入阿里之后,开始直面兼容性问题,同时开始单打独斗,这个阶段开始接触相关的前端书籍,最先购买的是&lt;JavaScript高级程序设计&gt;和&lt;JavaScript Dom编程艺术&gt;.可以说比较幸运,挑中了这两本很靠谱的书(其实当时市面上书籍并不多,感谢选择出版这些书和翻译这些书的同学们),近来这两本书都出了第二版其生命力可见一斑.\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这几年来,自认读的前端方面的书不算少,校招同学们问到有什么书推荐,我还是会列几个批次的书籍出来给大家,在这里公布一下,没法说这是最优学习路线,但真看进去了获得一个IT民工从业资格是没啥问题的.咱也先秀下书架吧:\r<br /><img src=\"http://dl.iteye.com/upload/attachment/591671/3e3b358c-c1b4-3a6f-b6d1-5f546bd35309.jpg\" />\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 说说我对于书的选择,在从高级程序设计以及DOM编程艺术获得了较好的用户体验之后,基本上延续了选择译著的路子,属顺势而为倒没有什么特殊的因素在里头.而我一般不会推荐英文原版书,中文更具亲和力,JavaScript并不是一门多么高深的语言,我相信译者是可以在深刻理解原文的基础上做翻译的.我也会读一些外文书,而往往当我知道一本不错的书籍有了出版计划,就会停止精读,等译作出版(比如不久前的&lt;高性能JavaScript&gt;).不过确实有时会遇到术语翻译不一致甚至翻译的不通顺的情况,好在多数书网上可以找到英文电子版,实在不解之处对照一下也就可以了.\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 下面都是我精读过且觉得不错的书,先分分类再逐本分享下我的读书心得:\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>第一批次:入门级,也适合想掌握一些前端技能的非前端工程师.</strong>\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;JavaScript Dom编程艺术&gt;\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>第二批次:成为一名合格的前端工程师</strong>\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;JavaScript高级程序设计&gt;(或&lt;JavaScript权威指南&gt;)\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;精通JavaScript&gt;\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>第三批次:更优秀的代码,更优良的设计</strong>\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;JavaScript语言精粹&gt;\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;JavaScript设计模式&gt;\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>第四批次:从语言细节到复杂工程实践,想开发靠谱的各类底层代码,应该看看</strong>\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Secrets of the JavaScript Ninja&gt;\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;JavaScript Patterns&gt;\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;ECMA-262 in Detail&gt;\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 应该重视跟踪阅读一些大牛们的Blog了\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 一直在等待:&lt;一本JavaScript语言作者或引擎实现者写的书&gt;\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>番外篇:各类专题书籍,读好第二批次书籍之后,有精力就接触下</strong>\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;高性能网站建设指南&gt;\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;高性能网站建设进阶指南&gt;\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;高性能JavaScript&gt;\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Ajax实战&gt;\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;JQuery实战&gt;\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;精通CSS&gt;(或&lt;CSS权威指南&gt;)\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;正则表达式必知必会&gt;(或&lt;正则表达式权威指南&gt;)\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 应该选择:&lt;一本HTML5方面的书&gt;\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 应该选择:&lt;一本NodeJS方面的书&gt;\r<br />\r<br /><strong><a href=\"http://book.douban.com/subject/1921890/\" target=\"_blank\">JavaScript Dom编程艺术</a>(<a href=\"http://book.douban.com/subject/6038371/\" target=\"_blank\">第二版链接</a>)</strong>\r<br /><img src=\"http://img1.douban.com/mpic/s1958902.jpg\" /><img src=\"http://img1.douban.com/mpic/s4677623.jpg\" />\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 话说这本书的中文名有一些标题党的,当初如果知道这仅是一本入门书籍,我是不会买来的.拿到后一天就看完了,对我来说没有太多技能上的实质帮助.不过这个书语言很流畅,重要的是对知识深浅度把握的很好,html/js/css/dom各个方面都把握在一个合适的度,这很符合我对书籍期望,一步步走,每一步都踏踏实实.\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这本书通过几个实例,循序渐进的介绍了前端开发的方方面面,让大家能够了解前端的技术体系概况,又能具备了一些简单的动手能力.如果大家对我之前写过的&lt;<a href=\"http://limu.iteye.com/blog/986724\" target=\"_blank\">浏览器端技术体系概览 -- 前端开发的七种武器</a>&gt;有些感觉,那读读这本书正好能上手实践一把.\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 去年淘宝前端懒懒交流会的豆瓣小站上做了一个调查,<a href=\"http://site.douban.com/widget/votes/246013/3712/\" target=\"_blank\">如果非要您推荐一本适合新人学习的js方面的书，您的推荐是什么?</a>虽然投票的人不多,但这本书却是遥遥领先.\r<br />\r<br /><strong><a href=\"http://book.douban.com/subject/1869705/\" target=\"_blank\">JavaScript高级程序设计</a>(<a href=\"http://book.douban.com/subject/4886879/\" target=\"_blank\">第二版链接</a>)</strong>\r<br /><img src=\"http://img3.douban.com/mpic/s1888787.jpg\" /><img src=\"http://img1.douban.com/mpic/s4391754.jpg\" />\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这本书的第一版很全面且不枯燥的书籍,年纪轻轻的NCZ有这样的大作难能可贵.读懂这本书,前端技能又可以上一个台阶,基本上可以成为专业的前端工程师了.\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对于当时的我来讲,这本书及时的补充了浏览器兼容性方面的知识,特别是事件相关的知识,这个浏览器间差别最大.有些内容讲的非常简单明了,比如call和apply的用法,之前总是理解不好,NCZ几句话+一个例子就说明白了.\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 然而作为全面型的书籍,第一版也是有一些问题的:\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1.闭包只半页篇幅,没说清楚.\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2.匿名函数没怎么讲.\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3.全书没提到constructor,更别说hasOwnProperty,__proto__.\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这带来了我之前说的深一脚浅一脚的困扰,这些知识基本上是通过&lt;JavaScript权威指南&gt;阅读中补充的,当然当时版本的权威指南也有同样的问题,比如它没解释instanceof.也没提到__proto__.这造成了我对面向对象理解的不全面,当时在做了N多测试后还很蛋疼的写了一篇博文&lt;<a href=\"http://www.baidu.com/s?tn=baiduhome_pg&amp;bs=javascript+%BB%B6%CF%B2%D4%A9%BC%D2&amp;f=8&amp;rsv_bp=1&amp;rsv_spt=1&amp;wd=JavaScript+constructor%BA%CDinstanceof%2CJSOO%D6%D0%B5%C4%D2%BB%B6%D4%BB%B6%CF%B2%D4%A9%BC%D2&amp;n=2&amp;inputT=1634\" target=\"_blank\">JavaScript constructor和instanceof,JSOO中的一对欢喜冤家</a>&gt;,后来接触到&lt;JavaScript设计模式&gt;关于OO的全面论述之后,果断删掉了这篇JY.\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 相信这本书的第二版,以及权威指南的第六版肯定会在这些方面进行补充.不过这两本书都是十足的大部头,高级程序设计第二版已经比权威指南去除附录要厚了.\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 一本全面且不枯燥的书太难找了,所以我还是喜欢第一版.对我技术上的提升帮助非常之大.忍不住再秀一张图(当时在封闭开发Alimama.com,马云时常来,他不肯在书的第一页签名搞得好像他写的,于是把签名画在了第二页.)\r<br /><img src=\"http://dl.iteye.com/upload/attachment/591669/0a76fac8-6641-30d9-8712-5be146111406.jpg\" />\r<br />\r<br /><strong><a href=\"http://book.douban.com/subject/3007076/\" target=\"_blank\">精通JavaScript</a></strong>\r<br /><img src=\"http://img3.douban.com/mpic/s3069995.jpg\" />\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 我会把书籍分成两类,一类是全面型,一类是犀利型.前面介绍了一本全面型的书籍,接下来介绍的这本的特点是非常犀利,这类书籍的特点是作者能找对重点(2/8原则掌握的很好),在重点位置深入挖掘.这本书的作者John Resig也是JQuery的作者,他显然是个足够犀利的人儿.JQuery从未承诺解决所有问题,但再一些重点部位的突破,让这个类库如此流行.这本书并没有着重介绍JQuery,还是基于原生的JavaScript和DOM API.\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 列一些这本书的重点话题,能够很好的看出作者为什么会开发出JQuery,或者说JQuery为什么是现在的样子:\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1.如何创建可复用的代码?如何调试,测试?(这是基础)\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2.如何判断DOM何时加载完毕?如何遍历,修改DOM?(JQuery以DOM为核心,节点的增删改查,事件响应是重点)\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3.如何确定元素的位置,相对于页面/屏幕?如何做平滑的动画?(思考下CSS相关的话题很多,作者为什么选了这两个?)\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4.如何改进表单验证,封装完整的Ajax程序?(涉及数据交互,是另一个重中之重.)\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 不算厚的一本书,基本上就是以上的话题+几个实例.当我们看过了一本全面型的书籍,对前端的知识有了深入的了解之后,这本书的作者指出了今后的重点,并告诉大家如何把知识用到解决重点问题上.\r<br />\r<br /><strong><a href=\"http://book.douban.com/subject/3590768/\" target=\"_blank\">JavaScript语言精粹</a></strong>\r<br /><img src=\"http://img3.douban.com/mpic/s3651235.jpg\" />\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 推荐大家看看阮一峰老师的博文&lt;<a href=\"http://www.ruanyifeng.com/blog/2011/06/birth_of_javascript.html\" target=\"_blank\">JavaScript诞生记</a>&gt;,JavaScript是Brendan Eich大神10天时间设计出的语言,现在成了Web前端领域的唯一语言.\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 一方面这门语言博采众家之长,也帮助它维系了长久的生命力:\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \"1.借鉴C语言的基本语法；\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2.借鉴Java语言的数据类型和内存管理；\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3.借鉴Scheme语言，将函数提升到\"第一等公民\"（first class）的地位；\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4.借鉴Self语言，使用基于原型（prototype）的继承机制。\"\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 另一方面\"由于设计时间太短，语言的一些细节考虑得不够严谨，导致后来很长一段时间，Javascript写出来的程序混乱不堪。\"Brendan Eich对其这10天工作的评价是:\"它的优秀之处并非原创，它的原创之处并不优秀。\"\r<br />\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Douglas Crockford通过&lt;JavaScript: The Good Parts&gt;这本书对JavaScript进行了一次大审判,老道认为JavaScript语言有很多优秀的地方,也有一些鸡肋和糟粕.老道不反对用这门语言,在规避一些鸡肋和糟粕之后它自然是优秀的.\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 老道认为JavaScript优美的特性如下:\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1.函数是头等对象(可以作为其他函数的参数和返回值,支持闭包)\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2.基于原型继承的动态对象\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3.对象字面量和数组字面量(构成JSON的基础)\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 老道列出了很多鸡肋和糟粕,并提供了JSLint这个工具,来校验代码是否使用了不好的部分.书中给出的语法图让我有深入学习一下&lt;编译原理&gt;的冲动,也理解了JSLint作为用JS语言分析JS语言的工具成型的理论基础.\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 强烈建议大家使用JSLint来检测自己的代码,但是我们不必教条,可以违返其中一些的检测规则,只要我们清楚老道为什么会设置这个规则,有什么风险?若我们不遵守这个规则,是否能回避相应的风险.\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 我觉得这本书最重要的意义是告诉我们为什么\"它是鸡肋,它是糟粕\"这是经过前面的学习和大量实践之后,成熟的开发者应该关注的.比如:\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1.hasOwnProperty,老道说它糟粕的原因是因为这不是一个关键字,而是一个Object.prototype上可以被重写的方法.那么这个告诉我们,并不是不要用hasOwnProperty,而是要注意不要覆盖它.\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2.eval的主要问题是性能,大量的eval(类eval)语句降低了JS引擎的性能.而经过测试少量的eval语句+eval大段的JS文本性能并不差,有必要也可以考虑使用.\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \r<br /><strong><a href=\"http://book.douban.com/subject/3329540/\" target=\"_blank\">JavaScript设计模式</a></strong>\r<br /><img src=\"http://img3.douban.com/mpic/s3398900.jpg\" />\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这是一本介绍JavaScript面向对象编程以及设计模式非常好的书籍.相对于又一本全面型书籍语言精粹,犀利型书籍登场了.\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 我对面向对象的看法是:隐藏细节,方便做大.基于良好的抽象和封装,我们可以方便的自顶而下的设计,自底而上的开发.面向对象的优缺点不是本文的重点,这里不讨论,只能说这是一个非常不错的代码设计实现方法论.\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; JavaScript到底是不是一个面向对象的语言,从本质说一定是的,从表象来说OO的不那么明显.我们必须通过一些额外的代码实现诸如,划分公有/私有,接口,继承,多态等特性.由于JavaScript语言的灵活性,实现的方式非常多.这本书的第一部分对常见的两类实现模式:类式继承和原型继承都有非常好的最佳实践总结.所以我的想法是完全读懂它,然后按照这个来做就好了.如果这里介绍的实践足够强大,我们没有必要发明新的继承实现模式了,事实上YUI一直是这种模式,而新的JavaScript引擎甚至引入了Object.create方法,将一些动作写入标准内置在JS引擎中.\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 我们应该将视点放在设计模式上,GoF的设计模式那本书里的例子,对于前端开发来说并不都是很好理解,而这本书的例子全部是前端相关,有助于大家理解设计模式的精妙.还有些同学说,即使我不了解GoF的理论,我也在默默的用这些模式了.确实是这样,但我想我们关注设计模式,不光要学会各种模式是怎样的,更重要的是学习到各种模式适合什么场合,不适合什么场合.了解有什么优点,也要了解有什么缺点,你正在默默使用的模式存在隐患么?系统学习之后会对其更有把握.\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 前几天听同事说这本书全面断货,不知道是太火,还是印的太少,希望能尽快看到上架.\r<br />\r<br /><strong><a href=\"http://book.douban.com/subject/3176860/\" target=\"_blank\">Secrets of the JavaScript Ninja</a></strong>\r<br /><img src=\"http://img1.douban.com/mpic/s4683232.jpg\" />\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 进入第四个批次,这里的书籍多数没有中译本出版.现阶段想开发靠谱的底层类库代码,确实需要啃一些外文书了.英文书很多,没有精力大量阅读,通常读一些口碑较好的书籍.\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 另外,到了这个批次,我的阅读量也相当的有限,所以肯定有很多好的内容没有提到,期望大家能继续推荐.而且到了这个批次,书籍产出肯定跟不上知识的更新速度,跟踪阅读一些JS大牛们的Blog应该成为习惯.\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这是JQuery作者的第二本书,自然又是犀利型的代表.John Resig已经陆续放出这本书的大部分内容,从2008年开始写,计划2012年5月出版.\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 如果说JR的第一本书能够看出为什么有JQuery,那么这本书能看出让JQuery发展下去,作者关注了哪些.我们会看到其实一些很细节的内容,比如强调测试用例的构建/自动化测试的方法,比如如何利用每个function实例的length属性,比如对with,eval的思考和发散等等.\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 关于这本书具体如何的好处,我还理不清,拿来开开眼界是非常不错的.记得玉伯大大组织了一波同学在翻译,不知进展如何了.\r<br />\r<br /><strong><a href=\"http://book.douban.com/subject/5252901/\" target=\"_blank\">JavaScript Patterns</a></strong>\r<br /><img src=\"http://img1.douban.com/mpic/s4460994.jpg\" />\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 乍一看这本书标题,以为又是一本讲设计模式的书,那和&lt;JavaScript设计模式&gt;重复了,开始没有仔细关注.今年拔赤推荐了它,才发现者并不仅仅介绍GoF的设计模式而是涵盖前端开发各个方面的先进理论。虽然是09年的书，这两年前端的很多较深刻变化在这边书里都能看到雏形。上一本书犀利，这本更全面。\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 作者Stoyan Stefanov是Yahoo的前端技术专家,从这本书中可以看到很多YUI3设计上的本源,比如在对象创建模式中介绍的模块模式/沙箱模式.近来CommonJS Loader的流行在这之上的继续深入发掘.这本书还包括代码测试,打包,部署,加载策略等各个流程中的诸多细节,这些构成了完整的体系在Yahoo在YUI3都有非常好的实践.\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 听说我们的同事拔赤和一舟在翻译这个本书,非常期待.\r<br />\r<br /><strong><a href=\"http://dmitrysoshnikov.com/\" target=\"_blank\">ECMA-262</a></strong>\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这不是一本书,是俄罗斯小伙子写的一系列ECMA-262标准分析文章,ECMA-262-3系列已经很完整.标准像汇编语言一样枯燥,而这系列文章把枯燥的标准转化为一系列深入讨论的话题,配合恰到好处的示例,一定会让大家对JS引擎的认识再上一层.\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 网上有一些译文,但是由于类似文章译文比较少,很多英文还未达成一致表述,所以推荐阅读英原文.另外作者很好,遇到的棘手的问题,去咨询他都能很快收到很好的回复.\r<br />\r<br /><strong>期待:一本JavaScript语言作者或引擎实现者写的书</strong>\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 一直以来期待JavaScript能有一本像<a href=\"http://book.douban.com/subject/1882483/\" target=\"_blank\">C语言的K&amp;R</a>这样的大作,最近也在读<a href=\"http://book.douban.com/subject/2185076/\" target=\"_blank\">计算机系统概论</a>补一些大学时没学好的知识,非常认同书中\"自底而上\"的学习路线.我想对JavaScript引擎的透彻分析,能够减少大家看着实验结果,猜测着写书的境况.随着NodeJS的火爆,引擎的技术分析文章越来越多,期待很快出现集大成者.\r<br />\r<br /><strong><a href=\"http://book.douban.com/subject/3132277/\" target=\"_blank\">高性能网站建设指南</a>&nbsp; <a href=\"http://book.douban.com/subject/4719162/\" target=\"_blank\">进阶指南</a>&nbsp; <a href=\"http://book.douban.com/subject/5362856/\" target=\"_blank\">高性能JavaScript</a></strong>\r<br /><img src=\"http://img3.douban.com/mpic/s5914296.jpg\" /><img src=\"http://img3.douban.com/mpic/s4231089.jpg\" /><img src=\"http://img1.douban.com/mpic/s4538004.jpg\" />\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 进入番外篇,推荐的书籍都是有针对性的领域之作,内容往往并不高深,大家根据自己的实际情况进行选择阅读.\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 高性能的网页是前端必然的追求,Steve Sounders率先在Yahoo开启了这方面的专题研究,伴随着&lt;高性能网站建设指南&gt;的出版和YSlow工具发布.网站性能优化,特别是前端角度和运维角度的优化方案,进入了人们的视野,同时获得了巨大的效果,甚至形成了名为WPO(Web Performance Optimization)产业.\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 第一本书除了介绍了能够立竿见影的规则的同时也开启了民智.大家开始思考如何做优化,如何结合自己的应用实践做优化.而后两本书基本上是遵循优化思路的继续得来的实践总结.关于优化的工具,思路,方法是我特别强调的.感兴趣的同学可以看下<a href=\"http://limu.iteye.com/blog/755628\" target=\"_blank\">在Yslow 34 Rules之后 -- 网站性能优化思路和进展 </a>这一篇.\r<br />\r<br /><strong>其他领域之作</strong>\r<br /><img src=\"http://img3.douban.com/mpic/s1636149.jpg\" /><img src=\"http://img1.douban.com/mpic/s3574953.jpg\" /><img src=\"http://img3.douban.com/mpic/s4249018.jpg\" /><img src=\"http://img1.douban.com/mpic/s2794811.jpg\" />\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 接下来介绍这些专题类书籍,并不是特别推荐,往往每个专题都有很多书籍可供选择,随手写一些读书心得吧.\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href=\"http://book.douban.com/subject/1764900/\" target=\"_blank\">Ajax实战</a>:06年的书,很早就购入.书中介绍了很多RIA高级应用的相关话题,很开眼界.\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href=\"http://book.douban.com/subject/3446112/\" target=\"_blank\">JQuery实战</a>:一定需要一本介绍JQuery的书,这书还可以,不过现在看来应该比较旧了,JQuery已经更新了很多.我主要从这本书了解了JQuery的工具函数扩展机制和插件机制是如何实现的.JQuery让完全不了解prototype属性的同学也能写出可复用的复杂组件,非常不容易,以后再单独写写对JQuery的一些看法吧.\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href=\"http://book.douban.com/subject/4736167/\" target=\"_blank\">精通CSS</a>:一定需要一本介绍CSS的书,工作中一直以来CSS用的不是很深入,不做特殊介绍.\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href=\"http://book.douban.com/subject/2269648/\" target=\"_blank\">正则表达式必知必会</a>:一定需要一本正则方面的书籍,这本小册子查起来蛮方便.\r<br />\r<br /><img src=\"http://img3.douban.com/mpic/s4557808.jpg\" /><img src=\"http://img3.douban.com/mpic/s4569610.jpg\" />\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href=\"http://book.douban.com/subject/5386169/\" target=\"_blank\">HTML5揭秘</a>和<a href=\"http://book.douban.com/subject/5402708/\" target=\"_blank\">HTML5高级程序设计</a>买回来一直没看,对HTML5的新增特性还是有了解的,等能用到时再看再评.\r<br /><img src=\"http://dl.iteye.com/upload/attachment/591742/60bc9ba5-4433-364d-9c78-210d20b742e1.png\" />\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 希望看到NodeJS方面的书籍,尽快引入.\r<br />\r<br />\r<br /><strong>写在最后</strong>\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 我只能推荐我看过的书对吧,所以大家懂的.\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 我们不去对比各种电子产品,就是对比鸡蛋大米,书籍都是非常廉价的.\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当有了领域内一定的实践经验之后,阅读一本相关的书籍并不是难事,也并不会耗费很多时间.\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 全面型的书籍可以让大家技能水平Step By Step的稳步提高,让大家站得高也站得稳.\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 犀利型的书籍可以让大家了解重点,了解别人是怎么运用那些你也会的知识的.\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 专题类的书籍是拓宽眼界,帮助大家完成工作任务的好手.\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对于非英文专业的同学,如果有中译本,不用非得纠结着去看原版,我们要最快学到知识,最快进入思考与实践.\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 感谢作者,译者(我的同事中有很多译者,都说指望这个赚钱是不可能的),以及选择运作这些书出版的各位老师.\n              \n              <br/><br/>\n              <span style=\"color:red;\">\n                <a href=\"http://limu.iteye.com/blog/1267475#comments\" style=\"color:red;\">已有 <strong>17</strong> 人发表留言，猛击-&gt;&gt;<strong>这里</strong>&lt;&lt;-参与讨论</a>\n              </span>\n              <br/><br/><br/>\n<span style=\"color:#E28822;\">ITeye推荐</span>\n<br/>\n<ul><li><a href='/clicks/433' target='_blank'><span style=\"color:red;font-weight:bold;\">—软件人才免语言低担保 赴美带薪读研！— </span></a></li></ul>\n<br/><br/><br/>\n              \n            "
            ],
            "pubDate": [
              "Sun, 20 Nov 2011 12:23:19 +0800"
            ],
            "link": [
              "http://limu.iteye.com/blog/1267475"
            ],
            "guid": [
              {
                "_": "http://limu.iteye.com/blog/1267475",
                "$": {
                  "isPermaLink": "false"
                }
              }
            ]
          },
          {
            "title": [
              "扩展SeaJS模块定义中的module参数的应用示例"
            ],
            "description": [
              "\n              \n              近三四个月公司有两个比较大的项目在忙,没怎么更新博客.现在一个项目已进入平台开发期,另一个即将上线,接下来会多拿出时间进行一些技术总结.已经预定了月中懒懒交流会上的分享,也会写一系列博文出来.即将上线的这个项目是一个OPOA应用,上一篇博客<a href=\"http://limu.iteye.com/blog/1064024\" target=\"_blank\">\"让Mustache支持简单的IF语句\"</a>和本篇都是这个项目的某个角落,它们有个统一的TAG:MagixJS,我会逐步揭开它.\r<br />\r<br /><a href=\"http://seajs.com\" target=\"_blank\">SeaJS</a>是我的同事玉伯开发的一套小巧且强大的Module Loader.我想前端的朋友多多少少会有耳闻,就不多说了.接触Java还算多些,在我看来seajs的module就像是Java的class.模块与模块之间有着依存关系,seajs会保证你在使用一个模块时,已经将所依赖的其他模块载入到脚本运行环境中.\r<br />\r<br />在模块化的代码组织形式下,我们可以放心大胆的细粒度书写模块(详见<a href=\"http://limu.iteye.com/blog/845870\" target=\"_blank\">我之前关于模块静态编译的分析</a>).当前的OPOA项目已有近一百个模块.在开发过程中,我发现无论模块本身还是模块之间的依存关系,应该都可以更清楚的描述出来.比如:<ul>\r<li>模块输出的是什么,构造器,静态对象还是某个的构造器的实例?\r</li><li>为什么A模块依赖B模块,是因为A继承B,还是因为A是B的实例?\r</li></ul><strong><span style=\"font-size: large;\">需求来了</span></strong>\r<br />看一个具体场景吧:\r<br /><pre name=\"code\" class=\"js\">\r\nPerson = function(name){}\r\nStuff = function(name,id){}//extend Person\r\nDeveloper = function(name,id,skills){}//extend Stuff\r\n</pre>\r<br />Developer继承Stuff继承Person继承Object这样的关系,我们将每个构造器写成一个模块.我们用YUI,KISSY使用的\"Parasitic Combination Inheritance\"模式(详见\"JavaScript高级程序设计第2版\"6.2.5,<a href=\"http://developer.yahoo.com/yui/3/api/oop.js.html\" target=\"_blank\">YUI代码</a>)来书写类,并将其封装成SeaJS模块形式,以Stuff为例,代码如下:\r<br /><pre name=\"code\" class=\"js\">\r\ndefine(function(require, exports, module){\r\n    var Person = require(\"./person\");\r\n    var Stuff = function(name, id){\r\n        Stuff.superclass.constructor.apply(this, arguments);\r\n        this.id = id;\r\n    };\r\n    extend(Stuff, Person, {\r\n        getId: function(){\r\n            return this.id;\r\n        }\r\n    });\r\n    return Stuff;\r\n});\r\n</pre>\r<br />我们可以马上写出这三个模块,我们把它们放在mptest文件夹下,加上seajs的全局alias指明mptest文件夹的http访问路径,那么我们就可以通过\"mptest/person\",\"mptest/stuff\"和\"mptest/developer\"这三个模块模块名来使用它们.\r<br />\r<br />但这三个模块之间的继承关系并非一目了然.比如我在chrome的控制台下查看一个developer实例.\r<br /><img src=\"http://dl.iteye.com/upload/attachment/527607/d6809a10-f8c8-3a85-bcdb-f4944332fb71.png\" />\r<br />图中两个\"F\",两个\"Object\"分别代表完全不同的四个东西,可我们很难简单识别出来,如果对象很多,层次复杂,这不易读,而这样的代码交给合作开发的partner,要费很多口舌.我们希望能够看到如下的这张图:\r<br /><img src=\"http://dl.iteye.com/upload/attachment/527611/299b6345-bab5-3033-a933-f90500d707fc.png\" />\r<br />通过这张图,我们可以清晰的看出类之间的继承关系,不用唠叨,也不怕忘掉.在模块化背景下进一步深入下去,我们可以将框住的\"Person\",\"Stuff\"处显示对应的模块名,那么一旦我们需要修改某个方法时,如Stuff的getId(),就能够快速找到代码所在文件stuff.js.如下\r<br /><img src=\"http://dl.iteye.com/upload/attachment/527613/2170131d-c82d-3980-9eb2-683397d040a1.png\" />\r<br />\r<br />我就是想在监视变量的时候能够看到上图这样的结果.\r<br />我还想通过简单的类描述,能够用NodeJS脚本跑出一整个包的类图.\r<br />我还想再Chrome控制台实现YUI Logger的日志分类显示以及过滤功能.\r<br />这些都可以辅助提高开发调试效率,也让模块间结构更清晰.\r<br />可是我又不想直接在构造器上做扩展,比如为Person指定静态属性,Person.modname=\"mptest-person\",坏处不细说.\r<br />\r<br /><strong><span style=\"font-size: large;\">扩展module解决问题</span></strong>\r<br />我把需求拿出来和玉伯一起讨论,发现玉伯同学也在偷偷的做类似的提取模块特有信息的事.最终发现模块输出的内容位于module对象的exports属性中,而同时模块对象已经拥有了id,dependencies属性.而module是一个普通object对象,那么如果我们把module由普通object改为Module类的实例,那么我们就可以在Module.prototype内扩展一系列公共方法来完成不同的需求.于是就有了seajs的这个<a href=\"https://github.com/seajs/seajs/issues/67\" target=\"_blank\">issue</a>.玉伯同学很快就在SeaJS v0.9.5版本中实现了它,而我则答应写今天这篇文章来介绍这个issue的具体应用.\r<br />\r<br />首先我扩展了一个module.getName方法,可以根据module.id(即module地址)获取到module的shortname作为代号.\r<br /><pre name=\"code\" class=\"js\">\r\ndefine(function(require, exports, module){\r\n    module.constructor.prototype.getName = function(){\r\n        var alias = seajs._data.config.alias;\r\n\t\tvar id = this.id;\r\n\t\tvar name = id.substr(id.lastIndexOf(\"/\")+1).split(\".\")[0];\r\n\t\tfor (a in alias){\r\n\t\t\tif(id.indexOf(alias[a])===0){\r\n\t\t\t\tname = id.split(alias[a])[1];\r\n\t\t\t\tname = (a+name.split(\".\")[0]);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn name;\r\n    };\r\n});\r\n</pre>\r<br />(注:这个方法并不严谨,只特殊处理了alias中包含完整http地址的情况,仅做示意.)\r<br />\r<br />然后在实现object.create(<a href=\"http://ejohn.org/blog/ecmascript-5-objects-and-properties/\" target=\"_blank\">详见这里</a>)的时候用了eval,把模块名取代\"F\"作为局部function变量名.\r<br /><pre name=\"code\" class=\"js\">\r\nvar object = function(o){\r\n    var cn = this.getName().split(\"/\").join(\"_\");\r\n    eval(\"function \" + cn + \"(){}\" + cn + \".prototype = o;var r = new \" + cn + \"();\");\r\n    return r;\r\n};\r\n</pre>\r<br />(注:这个方法依然很不好,不应该使用eval,但是尚未找到替代方案.关于eval再说几句,eval可能会影响到Js引擎对代码的自动优化,会影响到代码的压缩混淆效果,所以这个里的实现不应该用于生产环境,只做开发调试辅助.)\r<br />\r<br />最后我们实现module.extend方法,通过这个方法实现继承.\r<br /><pre name=\"code\" class=\"js\">\r\ndefine(function(require, exports, module){\r\n    var Person = require(\"./person\");\r\n    var Stuff = function(name, id){\r\n        Stuff.superclass.constructor.apply(this, arguments);\r\n        this.id = id;\r\n    };\r\n    module.extend(Stuff, Person, {\r\n        getId: function(){\r\n            return this.id;\r\n        }\r\n    });\r\n    return Stuff;\r\n});\r\n</pre>\r<br />\r<br />然而还有一个限制,在写Person类的时候,需要显示的指明继承自Object\r<br /><pre name=\"code\" class=\"js\">\r\ndefine(function(require, exports, module){\r\n    var Person = function(name){\r\n        this.name = name;\r\n    };\r\n    module.extend(Person, Object, {\r\n        getName: function(){\r\n            return this.name;\r\n        }\r\n    });\r\n    return Person;\r\n});\r\n</pre>\r<br />\r<br />可以看到这几段代码都还不尽人意,而且只能在Chrome浏览器下看到这张图,不过这却是一个介绍module原型扩展的很好示例.\r<br />\r<br /><strong><span style=\"font-size: large;\">为module添加meta信息</span></strong>\r<br />前面的例子,只是将name作为了局部变量,让debug时可以看得更清晰,我们在更多浏览器,或者离线状态下获取这些信息,我们需要将这些信息显式的存储在module实例里.因为module和exports的双生关系.我们可以在需要的时候把这些信息存在module实例中,不需要的时候(比如生产环境)将这些附加信息撤掉.比如Java的interface,只对开发和编译时校验有意义,运行时并无特殊意义.\r<br />\r<br />于是又实现了一个setMeta方法,这个方法现在接受两个参数,第一个是type用来标明模块输出内容是\"constructor\",\"static\",\"instance\",\"abstract\"还是\"interface\".如果是\"constructor\",第二个参数指明继承自哪个对象.如果是\"instance\"第二个参数指明构造器.\r<br /><img src=\"http://dl.iteye.com/upload/attachment/527680/0a1dd62a-f0ee-308b-a017-56ada57c44fd.png\" />\r<br />有了这些信息,我们可以辅助生成系统类图,甚至辅助生成文档.\r<br />\r<br />这些信息可以在开发时发挥作用,但是真的可以在线上去除么?现在通过显示的调用,module.setMeta()来写入meta数据时无法轻易做到线上剔除的.主要的问题是我们为模块输出内容时使用的是\"=\"赋值语句或\"return\"语句.这种API的扩展性具有一定的局限性.如果是通过一个方法来输出模块内容,如module.export(exportsObject);这样就可以方便的重写export方法,在开发环境和生产环境选用不同的export实现.\r<br />\r<br /><strong><span style=\"font-size: large;\">更好的Logger</span></strong>\r<br />大大小小的框架喜欢提供log方法,可是有一个问题,在chrome的控制台下,所有日志输出都是log方法定义的那一行.无法快速定位到关注的代码.如图:\r<br /><img src=\"http://dl.iteye.com/upload/attachment/527687/e76fdeba-36c6-363e-8703-8508f3a4eddb.png\" />\r<br />所以建议使用原生的console.log,对于没有console的浏览器,我们伪造一个console\r<br /><pre name=\"code\" class=\"js\">\r\nconsole = window.console || {\r\n    log:function(s){\r\n        //alert(s);\r\n    }\r\n}\r\n</pre>\r<br />接下来,我们为所有module添加log方法,\r<br /><pre name=\"code\" class=\"js\">\r\ndefine(function(require, exports, module){\r\n    var mp = module.constructor.prototype;\r\n    mp.log = function(s){\r\n        if (typeof s == \"string\") {\r\n            s = \"[\" + this.getName() + \"]:  \" + s;\r\n        }\r\n        return s;\r\n    };\r\n});\r\n//usage\r\nconsole.log(module.log(s));\r\n</pre>\r<br />这样的好处我们没有丢失行号,又可以给输出内容加上模块信息,继续扩展下去,可以指定哪些模块输出日志,哪些不输出.我的目标是把控制台改造成代行号的<a href=\"http://developer.yahoo.com/yui/3/console/\" target=\"_blank\">YUI Console</a>.如图:\r<br /><img src=\"http://dl.iteye.com/upload/attachment/527692/4e53bde4-c10d-38cf-bf01-30bc48fab692.png\" />\r<br />不过还是可耻的失败了,因为即使module.log返回空,也会打一行日志出来.如图:\r<br /><img src=\"http://dl.iteye.com/upload/attachment/527695/ce82a9f3-fadc-3beb-9aae-d270da084728.png\" />\r<br />我们想只打出stuff模块的信息,其他模块的log信息仍留了一些空行,不过点击行号可以立刻定位到代码,这个却非常不错.\r<br />另外大家可能觉得这样输出日志太麻烦,这就要看大家的真实需求了,同时也可以向Java程序员打听一下如果输出一行日志需要写多少代码..\r<br />\r<br /><strong><span style=\"font-size: large;\">总结一下</span></strong>\r<br />今天的示例说到底都不太成功.\r<br />三个示例都在使用的module.getName(),访问了seajs内置对象,且只考虑了alias情况.\r<br />第一个对象监测示例,不得己动用了eval,而且只能应用于chrome下\"寄生式\"继承这一种继承模式.\r<br />第二个meta信息示例,还无法方便的从生产系统中移除meta信息.\r<br />第三个log扩展示例,更是因为会留空行,而无法把console改造的符合期望.\r<br />但是这三个示例从三个角度展示了扩展module可以做到什么,大家可以发挥想象在各自的项目中有针对性的实现自己的功能.\r<br />我们只要知道module和exports是一对双生,我们不方便修改exports中的业务对象,但却可以在module对象里添加对exports的描述,乃至对exports的操作.\r<br />以上.<a href=\"http://limu.github.com/demo/moduleplus/\" target=\"_blank\">示例在此</a>,<a href=\"https://github.com/limu/limu.github.com/tree/master/demo/moduleplus\" target=\"_blank\">代码在此</a>.\r<br />\n              \n              <br/><br/>\n              <span style=\"color:red;\">\n                <a href=\"http://limu.iteye.com/blog/1136712#comments\" style=\"color:red;\">已有 <strong>1</strong> 人发表留言，猛击-&gt;&gt;<strong>这里</strong>&lt;&lt;-参与讨论</a>\n              </span>\n              <br/><br/><br/>\n<span style=\"color:#E28822;\">ITeye推荐</span>\n<br/>\n<ul><li><a href='/clicks/433' target='_blank'><span style=\"color:red;font-weight:bold;\">—软件人才免语言低担保 赴美带薪读研！— </span></a></li></ul>\n<br/><br/><br/>\n              \n            "
            ],
            "pubDate": [
              "Sun, 31 Jul 2011 22:29:34 +0800"
            ],
            "link": [
              "http://limu.iteye.com/blog/1136712"
            ],
            "guid": [
              {
                "_": "http://limu.iteye.com/blog/1136712",
                "$": {
                  "isPermaLink": "false"
                }
              }
            ]
          },
          {
            "title": [
              "让Mustache支持简单的IF语句"
            ],
            "description": [
              "\n              \n              Mustache是一种Logic-less templates.不支持if这类条件判断是Logic-less的显著特征之一.Mustache的另一个特征是体积小,不依赖其他前端类库,在浏览器端和NodeJS中都可以运行.\r<br />\r<br />并非Logic-less.Mustache的体积小,无依赖,前后兼容才是我们当前的项目选择这套模板系统的真正原因.没有IF有时候感觉并不给力,所以就想办法简单扩展下Mustache,让其具有一些通用的条件判断能力.\r<br />\r<br />比如如下的应用场景,我们需要根据某一字段的值,决定输出有意义的中文,并用颜色加以修饰.\r<br />\r<br />status==\"P\"&nbsp; ==&gt;&nbsp; &lt;b style=\"color:green\"&gt;通过&lt;/b&gt;\r<br />status==\"W\"&nbsp; ==&gt;&nbsp; 等待\r<br />status==\"R\"&nbsp; ==&gt;&nbsp; &lt;b style=\"color:red\"&gt;拒绝&lt;/b&gt;\r<br />\r<br />Logic-less模板实现这个功能就需要在数据上下功夫,如下.\r<br /><pre name=\"code\" class=\"javascript\">\r\ndata = {\r\n\tlist:[\r\n\t\t{ id:\"1\",status\"P\"},\r\n\t\t{ id:\"2\",status\"W\"},\r\n\t\t{ id:\"3\",status\"R\"}\r\n\t],\r\n\tstatusRenderer:function(){\r\n\t\tif(this.status==\"P\"){\r\n\t\t\treturn '&lt;b style=\"color:green\"&gt;通过&lt;/b&gt;'\r\n\t\t}else if(this.status==\"W\"){\r\n\t\t\treturn '等待'\r\n\t\t}else{\r\n\t\t\treturn '&lt;b style=\"color:red\"&gt;拒绝&lt;/b&gt;'\r\n\t\t}\r\n\t}\r\n}\r\n</pre>\r<br />这里的statusRenderer就是在数据这边扩展做的工作,{{{statusRenderer}}}在渲染时,this指向当前context,在取得status之后,经过判断,return正确的渲染字符串.\r<br />于是配合下面的模板就可以满足我们的要求\r<br /><pre name=\"code\" class=\"html\">\r\n&lt;ul&gt;\r\n{{#list}}\r\n&lt;li&gt;ID:{{id}},status:{{{statusRenderer}}}&lt;/li&gt;\r\n{{/list}}\r\n&lt;/ul&gt;\r\n</pre>\r<br />项目是很复杂的,如果需要写无数statusRenderer那会非常累,所以我想Renderer功能强大,在遇到各种特殊情况时,单独写一下未尝不可,但是想上面这种常见需求是需要抽象一下的.\r<br />比如我们希望如下这样的模板,完成同样的需求.\r<br /><pre name=\"code\" class=\"html\">\r\n&lt;ul&gt;\r\n{{#list}}\r\n{{#if(status==P)}}&lt;li&gt;ID:{{id}},status:&lt;b style='color:green'&gt;通过&lt;/b&gt;&lt;/li&gt;{{/endif}}\r\n{{#if(status==W)}}&lt;li&gt;ID:{{id}},status:等待&lt;/li&gt;{{/endif}}\r\n{{#if(status==R)}}&lt;li&gt;ID:{{id}},status:&lt;b style='color:red'&gt;拒绝&lt;/b&gt;&lt;/li&gt;{{/endif}}\r\n{{/list}}\r\n&lt;/ul&gt;\r\n</pre>\r<br />这个改造看起来一定是会伤筋动骨的,因为完全打破了{{#xxx}}{{/xxx}}这种Mustache的嵌套模式.改过之后Mustache就不再是Mustache了.\r<br />于是我们在这里妥协下,把{{/endif}}改为{{/if(status==W)}},这样{{#if(status==W)}}{{/if(status==W)}}就配起对来了.\r<br />接下来我们就只要想办法从模板中把这类标签正则出来,然后为这类配对自动添加Renderer即可.\r<br />模板变成了下面这样:\r<br /><pre name=\"code\" class=\"html\">\r\n&lt;ul&gt;\r\n{{#list}}\r\n{{#if(status==P)}}&lt;li&gt;ID:{{id}},status:&lt;b style='color:green'&gt;通过&lt;/b&gt;&lt;/li&gt;{{/if(status==P)}}\r\n{{#if(status==W)}}&lt;li&gt;ID:{{id}},status:等待&lt;/li&gt;{{/if(status==W)}}\r\n{{#if(status==R)}}&lt;li&gt;ID:{{id}},status:&lt;b style='color:red'&gt;拒绝&lt;/b&gt;&lt;/li&gt;{{/if(status==R)}}\r\n{{/list}}\r\n&lt;/ul&gt;\r\n</pre>\r<br />而输入给to_html方法的数据则变成如下这样(里边的Render为自动生成):\r<br /><pre name=\"code\" class=\"javascript\">\r\ndata = {\r\n\tlist:[\r\n\t\t{ id:\"1\",status\"P\"},\r\n\t\t{ id:\"2\",status\"W\"},\r\n\t\t{ id:\"3\",status\"R\"}\r\n\t],\r\n\t//下面Renderer为自动生成.\r\n\t\"if(status==P)\":function(){\r\n\t\tif(this.status==\"P\"){\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t},\r\n\t\"if(status==W)\":function(){\r\n\t\tif(this.status==\"W\"){\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t},\r\n\t\"if(status==R)\":function(){\r\n\t\tif(this.status==\"R\"){\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n}\r\n</pre>\r<br />整个改造的大体流程如下,首先从模板中取出if(x.y.z==abc)这样的key,然后自动生成以\"if(x.y.z==abc)\"为名字的Renderer.全部代码如下:\r<br /><pre name=\"code\" class=\"javascript\">\r\n    function addFns(template, data){\r\n        var ifs = getConditions(template);\r\n        var key = \"\";\r\n        for (var i = 0; i &lt; ifs.length; i++) {\r\n            key = \"if(\" + ifs[i] + \")\";\r\n            if (data[key]) {\r\n                continue;\r\n            }\r\n            else {\r\n                data[key] = buildFn(ifs[i]);\r\n            }\r\n        }\r\n    }\r\n    function getConditions(template){\r\n        var ifregexp_ig = /\\{{2,3}[\\^#]?if\\((.*?)\\)\\}{2,3}?/ig;\r\n        var ifregexp_i = /\\{{2,3}[\\^#]?if\\((.*?)\\)\\}{2,3}?/i;\r\n        var gx = template.match(ifregexp_ig);\r\n        var ret = [];\r\n        if (gx) {\r\n            for (var i = 0; i &lt; gx.length; i++) {\r\n                ret.push(gx[i].match(ifregexp_i)[1]);\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n    function buildFn(key){\r\n        key = key.split(\"==\");\r\n        var res = function(){\r\n            var ns = key[0].split(\".\"), value = key[1];\r\n            var curData = this;\r\n            for (var i = ns.length - 1; i &gt; -1; i--) {\r\n                var cns = ns.slice(i);\r\n                var d = curData;\r\n                try {\r\n                    for (var j = 0; j &lt; cns.length - 1; j++) {\r\n                        d = d[cns[j]];\r\n                    }\r\n                    if (cns[cns.length - 1] in d) {\r\n                        if (d[cns[cns.length - 1]].toString() === value) {\r\n                            return true;\r\n                        }\r\n                        else {\r\n                            return false;\r\n                        }\r\n                    }\r\n                } \r\n                catch (err) {\r\n                }\r\n            }\r\n            return false;\r\n        };\r\n        return res;\r\n    }\r\n    // new to_html for exports\r\n    function to_html(template, data){\r\n        addFns(template, data);\r\n        return Mustache.to_html.apply(this, arguments);    \r\n    }\r\n</pre>\r<br />看起来这样做的好处是保持了Mustache的配对风格,并且继续无缝支持原生的嵌套以及否定等语法.\r<br />但看起来模板挺丑的,性能损耗也一定是有不少的.\r<br />\r<br />后续的扩展,我想elseif肯定不能支持了,if中带\"与\"\"或\"判断倒是还方便添加的.\r<br />当然还可以做很多扩展,比如给数组增加一些内置属性如\"_index_\", \"_first_\", \"_last_\", \"_odd_\", \"_even_\".\r<br />\r<br />Mustache仍然足够简单,它本身就具有循环和否定判断等特性,增加了IF后,稍微加了点逻辑,但能少写很多Renderer.\r<br />\r<br />重要的是我们依然保有我们所看重的东西:体积小,无依赖,前后兼容.\r<br />在我的项目里破坏了Logic-less是我的事情并不接受批判,但请大家根据自己实际情况谨慎选择.\r<br />\r<br />刚刚接触Mustache,各种特性还在学习摸索中,现在看起来Lambda和子模板等特性,让Mustache的JS实现小巧却功能强大.\r<br />\r<br />或许今天的需求还有更好的解决方案,如果有同学知道还望不吝赐教.\r<br />\r<br />\n              \n              <br/><br/>\n              <span style=\"color:red;\">\n                <a href=\"http://limu.iteye.com/blog/1064024#comments\" style=\"color:red;\">已有 <strong>2</strong> 人发表留言，猛击-&gt;&gt;<strong>这里</strong>&lt;&lt;-参与讨论</a>\n              </span>\n              <br/><br/><br/>\n<span style=\"color:#E28822;\">ITeye推荐</span>\n<br/>\n<ul><li><a href='/clicks/433' target='_blank'><span style=\"color:red;font-weight:bold;\">—软件人才免语言低担保 赴美带薪读研！— </span></a></li></ul>\n<br/><br/><br/>\n              \n            "
            ],
            "pubDate": [
              "Sun, 29 May 2011 23:24:14 +0800"
            ],
            "link": [
              "http://limu.iteye.com/blog/1064024"
            ],
            "guid": [
              {
                "_": "http://limu.iteye.com/blog/1064024",
                "$": {
                  "isPermaLink": "false"
                }
              }
            ]
          },
          {
            "title": [
              "我们为什么要使用NodeJS"
            ],
            "description": [
              "\n              \n              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 科普文一则,说说我对<a href=\"http://nodejs.org\" target=\"_blank\">NodeJS</a>(一种服务端JavaScript实现)的一些认识,以及我为什么会向后端工程师推荐NodeJS.\r<br />\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>\"Node.js 是服务器端的 JavaScript 运行环境，它具有<a href=\"http://en.wikipedia.org/wiki/Non-blocking_algorithm\" target=\"_blank\">无阻塞(non-blocking)</a>和<a href=\"http://en.wikipedia.org/wiki/Event-driven_programming\" target=\"_blank\">事件驱动(event-driven)</a>等的特色，Node.js 采用 <a href=\"http://code.google.com/p/v8/\" target=\"_blank\">V8</a> 引擎，同样，Node.js 实现了类似 <a href=\"http://apache.org/\" target=\"_blank\">Apache</a> 和 <a href=\"http://nginx.org/\" target=\"_blank\">nginx</a> 的web服务，让你可以通过它来搭建基于 JavaScript 的 Web App。\"</em>\r<br />\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 上周末参与了CNodeJS社区的第一次北京聚会,现场气氛非常的好.而作为一名前端开发,我在后面的讨论环节讲了下我对NodeJS的看法,主要回答的问题是\"我为什么会向后端工程师推荐NodeJS\".这其实是去年年底大团队技术总结的话题之一,包含在我之前发过的PPT:<a href=\"http://limu.iteye.com/blog/852813\" target=\"_blank\">团队年终技术Review</a>中.因为之前没有准备,当天仓促上阵,也不知道说清楚了没,不如就在这里再详细展开记录下.\r<br />\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 我想不仅仅是NodeJS,当我们要引入任何一种新技术前都必须要搞清楚几个问题:\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1.我们遇到了什么问题?\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2.这项新技术解决什么问题,是否契合我们遇到的问题?\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3.我们遇到问题的多种解决方案中,当前这项新技术的优势体现在哪儿?\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4.使用新技术,带来哪些新问题,严重么,我们能否解决掉?\r<br />\r<br /><strong>我们的问题:Server端阻塞</strong>\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NodeJS被设计用来解决服务端阻塞问题.通过一段简单的代码解释何为阻塞:\r<br /><pre name=\"code\" class=\"js\">\r\n//根据ID,在数据库中Persons表中查出Name\r\nvar name = db.query(\"select name from persons where id=1\");\r\n//进程等待数据查询完毕,然后使用查询结果.\r\noutput(\"name\")\r\n</pre>\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这段代码的问题是在上面两个语句之间,在整个数据查询的过程中,当前程序进程往往只是在等待结果的返回.这就造成了进程的阻塞.对于高并发,I/O密集行的网络应用中,一方面进程很长时间处于等待状态,一方面为了应付新的请求不断的增加新的进程.这样的浪费会导致系统支持QPS远远小于后端数据服务能够支撑的QPS,成为系统的瓶颈.而且这样的系统也特别容易被慢链接攻击(客户端故意不接收或减缓接收数据,加长进程等待时间).\r<br /><strong>如何解决阻塞问题</strong>\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 解决这个问题的办法是,建立一种事件机制,发起查询请求之后,立即将进程交出,当数据返回后触发事件,再继续处理数据:\r<br /><pre name=\"code\" class=\"js\">\r\n//定义如何后续数据处理函数\r\nfunction onDataLoad(name){\r\n    output(\"name\");\r\n}\r\n//发起数据请求,同时指定数据返回后的回调函数\r\ndb.query(\"select name from persons where id=1\",onDataLoad);\r\n</pre>\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 我们看到按照这个思路解决阻塞问题,首先我们要提供一套高效的异步事件调度机制.而主要用于处理浏览器端的各种交互事件的JavaScript.相对于其他语言,至少有两个关键点特别适合完成这个任务.\r<br /><strong>为什么JS适合解决阻塞问题</strong>\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 首先JavaScript是一种<a href=\"http://baike.baidu.com/view/1711147.htm\" target=\"_blank\">函数式编程</a>语言,函数编程语言最重要的数学基础是<a href=\"http://baike.baidu.com/view/1179241.htm\" target=\"_blank\">λ演算(lambda calculus)</a> -- 即函数可以接受函数当作输入(参数)和输出(返回值).\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 函数可以作为其他函数的参数输入的这个特性,使得为事件指定回调函数变得很容易.特别是JavaScript还支持匿名函数.通过匿名函数的辅助,之前的代码可以进行简写如下.\r<br /><pre name=\"code\" class=\"js\">\r\ndb.query(\"select name from persons where id=1\",function(name){\r\n    output(name);\r\n});\r\n</pre>\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 还有一个关键问题是,异步回调的运行上下文保持(称状态保持),我看一段代码来说明何为状态保持.\r<br /><pre name=\"code\" class=\"js\">\r\n//传统同步写法:将查询和结果打印抽象为一个方法\r\nfunction main(){\r\n    var id = \"1\";\r\n    var name = db.query(\"select name from persons where id=\" + id);\r\n    output(\"person id:\" + id + \", name:\" + name);\r\n}\r\nmain();\r\n</pre>\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 前面的写法在传统的阻塞是编程中非常常见,但接下来进行异步改写时会遇到一些困扰.\r<br /><pre name=\"code\" class=\"js\">\r\n//异步写法:\r\nfunction main(){\r\n    var id = \"1\";\r\n    db.query(\"select name from persons where id=\" + id,function(name){\r\n        output(\"person id:\" + id + \", name:\" + name);//n秒后数据返回后执行回调\r\n    });\r\n}\r\nmain();\r\n</pre>\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 细心的同学可以注意到,当等待了n秒数据查询结果返回后执行回调时.回调函数中却仍然使用了main函数的局部变量\"id\",而\"id\"已经在n秒前走出了其作用域,这是为什么呢?熟悉JavaScript的同学会淡然告诉您:\"这是闭包(closures)~\".\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 其实在复杂的应用中,我们一定会遇到这类场景.即在函数运行时需要访问函数定义时的上下文数据(<em>注意:一定要区分函数定义时和函数运行时这样的字眼和其代表的意义,不然很快就会糊涂</em>).而在异步编程中,函数的定义和运行又分处不同的时间段,那么保持上下文的问题变得更加突出了.\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在这个例子中,db.query作为一个公共的数据库查询方法,把\"id\"这个业务数据传入给db.query,交由其保存是不太合适的.但聪明的同学们可以抽象一下,让db.query再支持一个需要保持状态的数据对象传入,当数据查询完毕后可以把这些状态数据原封不动的回传.如下:\r<br /><pre name=\"code\" class=\"js\">\r\nfunction main(){\r\n    var id = \"1\";\r\n    var currentState = new Object();\r\n    currentState.person_id = id;\r\n    db.query(\"select name from persons where id=\" + id, function(name,state){\r\n        output(\"person id:\" + state.person_id + \", name:\" + name);\r\n    },currentState);//注意currentState是db.query的第三个参数\r\n}\r\nmain();\r\n</pre>\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 记住这种重要的思路,我们再看看是否还能进一步的抽象?可以的,不过接下的动作之前,我们先要了解在JavaScript中一个函数也是一个对象.一个函数实例fn除了具备可函数体的定义之外,仍然可以在这个函数对象实例之上扩展属性,如fn.a=1;受到这个启发我们尝试把需要保持的状态直接绑定到函数实例上.\r<br /><pre name=\"code\" class=\"js\">\r\nfunction main(){\r\n    var id = \"1\";\r\n    var currentState = new Object();\r\n    currentState.person_id = id;\r\n    function onDataLoad(name){\r\n         output(\"person id:\" + onDataLoad.state.person_id + \", name:\" + name);\r\n    }\r\n    onDataLoad.state = currentState ;//为函数指定state属性,用于保持状态\r\n    db.query(\"select name from persons where id=\" + id, onDataLoad);\r\n}\r\n</pre>\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 我们做了什么?生成了currentState对象,然后在函数onDataLoad定义时,将currentState绑定给onDataLoad这个函数实例.那么在onDataLoad运行时,就可以拿到定义时的state对象了.而闭包就是内置了这个过程而已.\r<br />\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在每个函数运行时,都有一个运行时对象称为Execution context,它包含如下variable object(VO,变量对象),scope chain(作用域链)和thisValue三部分.详见<a href=\"http://dmitrysoshnikov.com/ecmascript/javascript-the-core/#execution-context\" target=\"_blank\">ECMA-262 JavaScript. The Core</a>\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <img src=\"http://dl.iteye.com/upload/attachment/469149/04d45d28-49c8-3c5b-a619-111b971b7217.png\" />\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 其中变量对象VO,包含了所有局部变量的引用.对于main函数,局部变量\"id\"存储在VO.id内.看起来用VO来代替我们的currentSate最合适了.但main函数还可能嵌套在其他函数之内,所以我们需要ScopeChain,它是一个包含当前运行函数VO和其所有父函数scope的数组.\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 所以在这个例子中,在onDataLoad函数<strong>定义时</strong>,就为默认为其绑定了一个[[scope]]属性指向其父函数的ExecutionContext的ScopeChain.而当函数onDataLoad执行时,就可以通过[[scope]]属性来访问父函数的VO对象来找到id,如果父函数的VO中没有id这个属性,就再继续向上查找其祖先的VO对象,直到找到id这个属性或到达最外层返回undefined.也正是因为这个引用,造成VO的引用计数不为0,在走出作用域时,才不会被垃圾回收.\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 很多人觉得闭包很难理解,其实我们只要能明确需要区分函数定义和函数运行这两个时机,记住<strong>闭包让函数在运行时能够访问到函数定义时的所处作用域内的所有变量</strong>.或者说<strong>函数定义时能访问到什么变量,那么在函数运行时通过相同的变量名一样能访问到</strong>.\r<br />\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 关于状态保持是本文的重点,在我看到的多数NodeJS的介绍文章,并没有详解这里,我们只是知道了要解决阻塞问题,但是JavaScript解决阻塞问题的优势在哪里,作为一个前端开发,我想有必要详细解释一下.\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 其实说到状态保持还有一个类似的场景,比如用户从A页面提交表单到B页面,如果提交数据校验不通过,则需要返回A页面,同时保持用户在A页面填写的内容并提示用户修改不对的地方.从提交到返回显示这也是一个包含网络交互的异步过程.传统网页,用户的状态通过请求传递到服务端,交由后端状态保持(类似交给db.query的currentSate).而使用Ajax的网页,因为并未离开原页面,那么服务端只要负责校验用户提交的数据是否正确即可,发送错误,返回错误处相关信息即可,这就是所谓前端状态保持.可以看到这个场景里边服务端做的事情变少了,变纯粹了.正如我们的例子中db.query不再存储转发第三个state参数,变得更轻量.\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 我们看到通过JavaScript函数式语言特性,匿名函数支持和闭包很漂亮的解决了同步编程到异步编程转化过程中遇到的一系列最重要的问题.但JavaScript是否就是最好的?这就要回答我们引用新技术时需要考虑的最后一个问题了\r<br /><strong>使用NodeJS是否带来额外的困扰,如何解决</strong>\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 性能真的是最好么?不用比较我们也可以得到结论NodeJS,做无阻塞编程性能较难做到极致.何为极致,处理一个请求需要占用多少内存,多少cpu资源,多少带宽,如果有浪费就不是极致.阻塞式编程浪费了大量进程资源只是在等待,导致大量内存和cpu的浪费.NodeJs好很多,但也正是因为一些闭包等JS内建机制也会导致资源的浪费,看下面的代码\r<br /><pre name=\"code\" class=\"js\">\r\nfunction main(){\r\n    var id = \"1\";\r\n    var str = \"...\"; //这里存储一个2M的字符串\r\n    db.query(\"select name from persons where id=\" + id,function(name){\r\n        output(\"person id:\" + id + \", name:\" + name);//n秒后数据返回后执行回调\r\n    });\r\n}\r\nmain();\r\n</pre>\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 直到数据查询完成,变量str所使用的2M内存不会被释放,而str保持下去可能并没有意义.前面已经解释过闭包的原理,闭包并没有智能到只包起来今后可能被访问到的对象.即使不了解闭包的原理,也可以通过一段简单脚本验证这点:\r<br /><pre name=\"code\" class=\"js\">\r\nfunction main(){\r\n    var id = \"1\";\r\n    var str = \"...\"; //这里存储一个2M的字符串\r\n    window.setTimeout(function(){\r\n        debugger;    //我们在这里设置断点\r\n    },10000)\r\n}\r\nmain();\r\n</pre>\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 我们在回调函数当中只设置一个断点,并不指明我们要访问哪个变量.然后我们在控制台监视一下,id和str都是可以拿到的.(此处结论不严谨，各种新浏览器已经就此做了相关优化，详见评论2楼，特别是2楼给出的详细测试报告的连接)\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 所以我来不负责任的预测一下,性能极端苛刻的场景,无阻塞是未来,但无阻塞发展下去,或者有更轻量的脚本引擎产生(lua?),或者V8JS引擎可能要调整可以disable闭包,或者我们可以通过给JS开发静态编译器在代码发布前优化我们的代码.\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 我之前谈到过JS静态编译器:<a href=\"http://limu.iteye.com/blog/845870\" target=\"_blank\">\"如果给JS代码发布正式使用前增加一个编译步骤,我们能做些什么\"</a>,动态语言的实时编译系统只完成了静态语言编译中的将代码转化为字节码的过程,而静态语言编译器的额外工作,如接口校验,全局性能优化等待.所以JS也需要一个静态的编译器来完成这些功能,<a href=\"http://calendar.perfplanet.com/2010/coding-better-object-oriented-javascript-with-closure-compiler/\" target=\"_blank\">Google利用ClouserComplier提供了系列编译指令,让JS更好的实现OO编程</a>,我来利用静态编译器解决一些JS做细粒度模块化引入的性能方面的问题.而老赵最近的项目<a href=\"https://github.com/JeffreyZhao/jscex\" target=\"_blank\">JSCEX</a>,则也是利用JS发布前的编译环节重点解决异步编程的代码复杂度问题.\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 我们习惯于阻塞式编程的写法,切换到异步模式编程,往往对于太多多层次的callback嵌套弄得不知所措.所以老赵开发的JS静态编译器,借鉴F#的Computation Expressions,让大家遵守一些小的约定后,能够仍然保持同步编程的写法,写完的代码通过JSCEX编译为异步回调式的代码再交给JS引擎执行.\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 如果这个项目足够好用,那就也解决了一个使用NodeJS这种新技术,却加大编程复杂度这个额外引入的困扰.甚至可以沿着这个思路,在静态编译阶段优化内存使用.\r<br />\r<br /><strong>NodeJS还要解决什么问题</strong>\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 说了这么多,无阻塞编程要做的还远不止这些.首先需要一个高效的JS引擎,高效的事件池和线程池.另外几乎所有和NodeJS交互的传统模块如文件系统,数据访问,HTTP解析,DNS解析都是阻塞式的,都需要额外改造.\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 正是NodeJS作者极其团队,认清问题问题以及JS解决这些问题方面的优势.基于高效的V8 JavaScript引擎,贡献了大量的智慧和精力解决上述大部分问题后才有NodeJS横空出世.\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当前Node社区如此火热,<a href=\"https://github.com/joyent/node/wiki/modules\" target=\"_blank\">千余开源的NodeJS模块</a>,活跃在WebFramework,WebSocket,RPC,模板引擎,数据抓取服务,图形图像几乎所有工程领域.\r<br />\r<br /><strong>后记</strong>\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 本文主要的信息来自nodejs作者在<a href=\"http://s3.amazonaws.com/four.livejournal/20091117/jsconf.pdf\" target=\"_blank\">JSConf09</a>,<a href=\"http://nodejs.org/jsconf2010.pdf\" target=\"_blank\">JSConf10</a>上的分享.\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 而作为前端开发,着重讲了函数式编程,闭包对于无阻塞开发的重要意义.我期待这篇文章能够给前端和后端同学都带来收获.\r<br />\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 同样作为前端开发,不得不再插几句,说说服务端JS能够解决的另一个问题:\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当前的Web开发前后端使用不同的语言,很多相同的业务逻辑要前后端分别用不同语言重复实现.比如越来越多重度依赖JS的胖客户端应用,当客户浏览器禁用JavaScript时,则需要使用服务端语言将主业务流程再实现一次(这即是所谓的\"渐进增强\").\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当我们拥有了服务端JavaScript语言,我们自然就会想到能否利用NodeJS做到\"一次开发,渐进增强\".解决掉这个为小量用户,浪费大量时间的恼人的问题.我们先要解决问题,这是使用NodeJS的最大动力.基于之前的统计,因为各种原因浏览器不支持JS的用户大概接近1%,至少淘宝绝对不会主动放弃这部分用户.至于在服务端也使用JS是否能够替掉LAMP架构,抑或NodeJS会对常见MVC架构带来何种冲击,V/C这些层是否能在前后端任意流动这些问题都是NodeJS解决问题后带来的额外话题.\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \"一次开发,渐进增强\"这方面的实践,YAHOO仍然是先驱,早在一年多前开始YAHOO通过<a href=\"https://github.com/davglass/nodejs-yui3\" target=\"_blank\">nodejs-yui3</a>项目做了很多卓越的贡献,而淘宝自主开发的前端框架Kissy也有服务端运行的相关尝试,详见我的同事<a href=\"http://ued.taobao.com/blog/2010/11/04/nodejs-kissy/\" target=\"_blank\">拔赤的分享</a>.而接下来的几个月我也将在这方面做一些尝试,有一定积累后我将再写一篇文章更好的分析这个问题..\r<br />\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; JS在诞生之时就不仅仅是浏览器端工具,如今JS能再一次回到服务端展示拳脚,感谢V8,感谢NodeJS作者,团队和社区的诸多贡献者,祝Node好运,JS好运.\n              \n              <br/><br/>\n              <span style=\"color:red;\">\n                <a href=\"http://limu.iteye.com/blog/1013223#comments\" style=\"color:red;\">已有 <strong>5</strong> 人发表留言，猛击-&gt;&gt;<strong>这里</strong>&lt;&lt;-参与讨论</a>\n              </span>\n              <br/><br/><br/>\n<span style=\"color:#E28822;\">ITeye推荐</span>\n<br/>\n<ul><li><a href='/clicks/433' target='_blank'><span style=\"color:red;font-weight:bold;\">—软件人才免语言低担保 赴美带薪读研！— </span></a></li></ul>\n<br/><br/><br/>\n              \n            "
            ],
            "pubDate": [
              "Sat, 23 Apr 2011 09:06:12 +0800"
            ],
            "link": [
              "http://limu.iteye.com/blog/1013223"
            ],
            "guid": [
              {
                "_": "http://limu.iteye.com/blog/1013223",
                "$": {
                  "isPermaLink": "false"
                }
              }
            ]
          },
          {
            "title": [
              "浏览器端技术体系概览 -- 前端开发的七种武器"
            ],
            "description": [
              "\n              \n              科普文一则,说说我对前端技术体系(也称浏览器端技术体系)的认识,希望能让更多人了解前端,也希望能借此丰富前端开发的大局观.\r<br />\r<br />去年我写了<a href=\"http://limu.iteye.com/category/122180\" target=\"_blank\">网站性能优化</a>系列文章,看过的朋友会知道,这类文章重点并非介绍各种具体的优化技巧,而是在关注发掘这些优化点的思路和方法.然后介绍给大家多种检测手段去发现问题,进而有目标的解决问题.所有这些需要我们对有网页整个生命周期有清晰的认识,对网页中各种技术极其相互结合的方式有明确的认知.这就回归到一个更本质的问题:浏览器端技术体系是怎样的.\r<br />\r<br />想用三言两语说清前端技术不大可能,但是用一篇不长的文章说清何谓前端,还是可以做到的.因为工作中我常会给后台开发的同学介绍前台技术,所以会经常涉及这类话题.\r<br />\r<br />解析前端,我想需要回答如下几个问题.\r<br />1.前端涉及几种技术?分别是做什么的?\r<br />2.在前端内部各种技术之间如何整合协作?\r<br />3.前端如何和后台交流?\r<br />\r<br />回答这些问题我会立即丢出前端开发的\"七种武器\"论,介绍前端主要涉及七种技术分别是什么的同时,重点关注\"七种武器\"如何对内协作,如何对外交流.(鉴于本文的科普文性质,下面具体介绍中出现的\"一切\",\"都是\",\"全部\"这类定语可能并非绝对,但可以确定在99%的情况下是正确的)\r<br />\r<br /><strong>一.HTTP:网页上的一切来自Http请求</strong>\r<br />页面上所有内容都是通过若干Http请求从服务端加载而来.\r<br />第一个请求通常是一份(X)HTML文档,也就是浏览器中地址栏的指向.如图:\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <img src=\"http://dl.iteye.com/upload/attachment/454386/619b0260-bb61-3bf5-8308-3ca749fdb682.png\" />\r<br />(这张图可以通过Fixfox的Firebug插件,IE的Httpwatch工具,或者Chrome直接按Ctrl+Shift+I得到)\r<br />地址栏中的url通常会包含地址和一些参数,这样就可以找到对应的后台服务,同时让其据这些动态参数来确定输出内容.\r<br />\r<br />多个Http请求之间是独立的.那么其他请求又是由谁触发的呢?\r<br />由浏览器触发!是在浏览器解析这第一份(X)HTML文档的过程中发出,接下来我就将介绍这个过程.\r<br />\r<br /><strong>二.HTML:在浏览器中HTML被解析成DOM树</strong>\r<br />HTML文档是一份不那么严谨的XML(文本)文档.在任意网页上点击右键,点击查看源代码就可以看到.\r<br />浏览器按照HTML文档内容自上而下的解析运行.最终HTML文本被完整的解析成一颗树,称DOM树.\r<br />注意:DOM树是浏览器内一切所依附的根本,是本文的重点,以后也会多次强调.\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <img src=\"http://dl.iteye.com/upload/attachment/454416/3883e54d-e85c-37c6-b915-5af1a90c03be.png\" />\r<br />(这张图可以通过Fixfox的Firebug插件,IE8/9按F12,或者Chrome直接按Ctrl+Shift+I找到)\r<br />继续回答之前的问题:其余的HTTP请求,除XHR(后面会介绍),CSS的@import和背景图之外,几乎都是在解析HTML时,由DOM树上的几种特定节点发起的.如图中重点标示出的那些节点:\r<li>&lt;img&gt;:用来嵌入图片\r</li><li>&lt;iframe&gt;:用来嵌套其他HTML\r</li><li>&lt;link&gt;:可以用来引入CSS文件\r</li><li>&lt;script&gt;:可以用来引入JavaScript文件\r</li><li>&lt;object&gt;和&lt;embed&gt;:通常用来引入Flash文件\r</li>之所以强调这一点,一是它说明了HTML和Http的关系:首个Http载入HTML,解析HTML发起其他Http.二来再次强调了DOM树,请求在HTML解析为DOM树过程中,在树上节点被解析出来时触发.\r<br />\r<br /><strong>三.CSS:使用CSS设定展现样式和网页布局</strong>\r<br />如何定义网页的样式,比如字体的颜色和大小?这是CSS的工作.\r<br /><pre name=\"code\" class=\"html\">\r\n&lt;!--CSS出现之前,使用额外的样式节点--&gt;\r\n&lt;span&gt;&lt;font size=\"50\" color=\"red\"&gt;文本&lt;/font&gt;&lt;/span&gt;\r\n&lt;!--CSS,统一在节点的style属性内定义--&gt;\r\n&lt;span style=\"color:red,font-size:50px\"&gt;文本&lt;/span&gt;\r\n&lt;!--CSS,在节点之外统一定义,通过class,id等属性关联至节点--&gt;\r\n&lt;span class=\"myTxt\"&gt;文本&lt;/span&gt;\r\n</pre>\r<br />我们看到最后一种方式,为&lt;span&gt;节点指定了class属性myTxt.而myTxt的详细定义可以以两种方式加入文档.\r<br /><pre name=\"code\" class=\"html\">\r\n&lt;!--在style标签内定义--&gt;\r\n&lt;style&gt;\r\n    .myTxt:{color:red,font-size:50px}\r\n&lt;/style&gt;\r\n&lt;!--通过&lt;link&gt;标签引入额外的css,内部包含myTxt类的样式定义--&gt;\r\n&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"http://a.com/a.css\"/&gt;\r\n</pre>\r<br />当然CSS的功能不止是简单的样式定义,还可以通过定义区块的位置确定网页布局方式,CSS也自然有其一套语法,描述CSS的功能,以及确定CSS规则与DOM节点之间的关联.这些细节并非本文重点.\r<br />\r<br />我们看到CSS或者通过节点的style属性,或者通过特定的&lt;style&gt;&lt;link&gt;节点影响网页,这又回到了我们反复强调的内容,DOM树,CSS并未脱离DOM树,而是驻留其上.\r<br />\r<br /><strong>四.JavaScript:使用JavaScript处理交互事件</strong>\r<br />说到JavaScript,不如先澄清下\"Java与JavaScript的关系是雷锋与雷峰塔的关系\".\r<br />网页应用是典型的事件驱动GUI系统.JavaScript为交互事件,时间线上的事件定义响应体.\r<br />我们看一个简单的应用,点击按钮,弹出一个警告框.\r<br /><pre name=\"code\" class=\"html\">\r\n&lt;!--直接写在onclick属性中--&gt;\r\n&lt;button onclick=\"alert(1)\"&gt;&lt;/button&gt;\r\n&lt;!--在onclick属性中,调用test_clk方法--&gt;\r\n&lt;button onclick=\"test_clk()\"&gt;&lt;/button&gt;\r\n&lt;!--在script标签中,定义test_clk方法--&gt;\r\n&lt;script&gt;\r\n\tfunction test_clk(){\r\n\t\talert(1);\r\n\t}\r\n&lt;/script&gt;\r\n&lt;!--在script标签引入外部js文件,内部包含test_clk方法的定义--&gt;\r\n&lt;script src=\"http://a.com/a.js\"&gt;&lt;/script&gt;\r\n</pre>\r<br />接下来我们有个问题,js什么时候运行?\r<li>首先,当浏览器解析到&lt;script&gt;标签时,开始运行其内的代码.\r</li><li>&lt;script&gt;标签内代码或者其他标签内的特定属性中可以定义事件响应体,在事件触发时执行\r</li><li>script代码可以指定某些代码在指定时长后开始执行,或每隔一定间隔重复执行\r</li>\r<br />重要的是我们还是看到了,JS同样没有脱离DOM树.同CSS一样驻留DOM树上.同时需要明确的是JS是被load到客户端浏览器之后,在浏览器中运行的,消耗的是客户端计算资源.JS为浏览器端提供了计算能力,而浏览器端则是JS的宿主.JS作为一种脚本语言,其实并不一定非要工作在浏览器这个宿主之上,但这脱离了前端技术体系,这里不讨论.\r<br />\r<br />说到这里,我们基本了解了构成一个独立网页的几项要素,各自负责什么,相互间如何协作.大家可能注意到,前面曾经说过每个http请求时相互独立的,那么如何让各个网页关联起来呢?\r<br />\r<br />首先网页之间通过链接&lt;a&gt;或&lt;form&gt;表单关联到一起.一般情况网页之间通过点击&lt;a&gt;形成一个新的执行a标签href属性的HttpGet请求,让浏览器从一个页面转向另一个.\r<br />\r<br />当需要浏览者通过客户端提交数据时,我们通常制作一个表单,然后submit表单,将客户数据将会通过HttpPost请求提交至另一个地址.\r<br />\r<br />除此之外的另一个需求就是保持登陆状态了,这需要一段信息始终在各个网页间传递,但是放在url参数中显然是不安全的.那如何实现这个功能?这正是接下来介绍的内容.\r<br />\r<br /><strong>五.Cookie:借助Cookie标识浏览者身份,在页面间保持会话</strong>\r<br />再次回到Http本身,它是一种无状态的协议,分为Header和Body两部分,Body是http传递的主体内容,Header又分为请求头(RequestHeader)和(ResponseHeader)两部分,而header中除了包含表明网页间关系的参数之外也包含一些通用信息,头当中的信息以键值对的方式书写,主要负责通用的缓存策略描述和身份标识等功能,如图:\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <img src=\"http://dl.iteye.com/upload/attachment/454471/3465d17c-8894-3f7a-a94d-d3cedd79a7ba.png\" />\r<br />(这张图,即为第一张图中某个http请求点开之后看到的详情,需要注意图中上面列出了响应头,下面是请求头,和发生顺序不一致.firebug就是这个顺序,注意区分)\r<br />服务端可以通过响应头种植cookie到客户端,而客户端的每个请求的请求头中都会携带域名下的cookie.比如这个到limu.iteye.com的请求,会包含iteye.com下的cookie,同时也包括limu.iteye.com的cookie.服务端可以通过cookie储存会话id,这样多个请求之间就有了关联.同时服务端set cookie时指定cookie设置到哪儿域名及路径下,以及在客户端将驻留多久.\r<br />\r<br />最后说一下JavaScript和Cookie的关系,JavaScript可以读写所在页面域名下的cookie值.\r<br />需要注意在http://www.a.com下面引入了http://www.b.com/b.js,b.js能读取所在页面,也就是www.a.com以及a.com下的cookie,而非b.com下的cookie.而b.js这个http的请求头中则带有b.com系列的cookie,这个请求的响应头中,也只能给b.com种植cookie.这里有点绕,但有必要澄清,可以遇到问题的时候可以再仔细看.\r<br />\r<br />到此为止,我们了解了一个网页的构成要素,也了解了网页之间的联系,这样我们就了解了一个传统网站的前端技术体系.接下来我们介绍一些新花样,正是这些带来了Web2.0的前端变革.\r<br />\r<br /><strong>六.DHTML:使用JavaScript操作Dom树</strong>\r<br />回到网页之内,其实我们只是获得了一颗DOM树,其他内容都驻留在树上.\r<br />接下来我们想一下,如果有一种手段能够随心所欲的改变动态这棵树,那岂不是我们就在客户端拥有了完全控制一个网页的能力.这项能力自然由JavaScript承担.\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <img src=\"http://dl.iteye.com/upload/attachment/454489/2807701d-8431-31b6-b0a7-ada5fedfa2e9.png\" />\r<br />接下来设想一下,操作一个棵树,也就是一份结构化的XML文档我们需要怎样的API?\r<li>找到一个或一组叶子节点,从一个节点出发找到相关节点:父,子,兄弟.\r</li><li>新增/复制节点,并插入到文档中指定位置,以及删除节点.\r</li><li>增删改叶子节点某个属性以及节点包含的文本.\r</li>于是<a href=\"http://www.w3.org/DOM/DOMTR\" target=\"_blank\">W3C(万维网联盟)的 DOM Level 1,2&amp;3</a>中定义了3个层次一系列Dom上的操作接口.其中Level1主要包含上面这些接口.在各种浏览器下Level 1基本都能被正确实现.\r<br />\r<br />回忆一下,之前我们提到了JS的三个执行入口,很重要的一个是响应各种鼠标键盘事件,如何为节点绑定事件响应动作,IE有独特的事件模型.其余浏览器的事件模型符合W3C DOM接口定义.\r<br />\r<br />这一系列技术被称为D(Dynamic)HTML,其核心是通过JS将Http,HTML,CSS,JavaScript更好的粘合在一起.通过JavaScript可以改变网页内的一切,甚至包括动态引入新的CSS和JS.\r<br />很酷是么?但单独DHTML并未流行起来,因为我们空有力量却不知道用到哪里合适.于是当接下来介绍的技术被引入,当我们能够根据服务端的指示来运用前台的力量,一场影响深远的真正的技术变革就此发生了.而在此之前,我们有必要意识到,DHTML不过是浏览器中JavaScript能力的一种扩展.\r<br />\r<br /><strong>七.Ajax:使用JavaScript在网页内与服务器端交互</strong>\r<br />有了DHTML,JavaScript已经具有能力完全的改变所在网页的每个细节.JavaScript的野心不止于此,如果JS能由事件驱动,从服务器端源源不断的获取新鲜数据,那理论上不再需要第二个页面了.\r<br />我们再回忆下,网页上一切来自HTTP,获取数据自然需要JavaScript发起HTTP请求,并且可以读懂这个Http请求响应内容.于是有了XHR(XmlHttpRequest),首先作为一个ActiveX控件被IE5引入(这里必须要感谢IE对不对?).\r<br />XHR就是这样一个可以由JS发送Http请求,且当请求数据返回后将服务端数据交给JS的对象.而且XHR支持异步请求,在Http请求的过程中(因为是和服务端打交道,所以这个操作耗时可能较长),页面还可以正常工作,直到Http响应后会才触发一个事件回调JS方法处理数据.\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <img src=\"http://dl.iteye.com/upload/attachment/454503/5720e2bf-63c0-354a-a161-2116e963b04d.png\" />\r<br />如今Ajax并不单指XHR.所有在不离开当前页面的前提下,由JS主动发起的从服务器端获取JS可解析数据的方案,皆可称Ajax.\r<br />最常见的另一种Ajax实现方案是JSONP,JS通过DOM接口,创建一个&lt;script&gt;节点,指定节点的src为一个http地址到数据服务器,数据被包装成可执行的JS,在http响应结束后立即执行.(这里我们再一次涉及到了JS的执行入口之一,在浏览器遇到&lt;script&gt;节点是执行).\r<br />\r<br />在MS,Google等先驱的引导之下,Ajax的出现引起了前端领域,乃至整个互联网开发领域的深刻变革,即为我们熟知的Web2.0.但回到本源,Ajax依然是浏览器中JavaScript能力的另一种扩展而已.\r<br />\r<br /><strong>总结一下</strong>\r<br /><ol>\r<li>HTTP:一切内容通过HTTP请求获得\r</li><li>HTML:浏览器把HTML解析成DOM树\r</li><li>CSS:定义HTML的布局和样式\r</li><li>JavaScript:提供计算能力,处理交互事件\r</li><li>Cookie:网页间,请求间会话保持(JS可以操作Cookie)\r</li><li>DHTML:JavaScript操作Dom树(包括CSS)\r</li><li>AJAX:JavaScript操纵HTTP\r</li></ol><li>所有前端应用托生于这些基础特性的整合\r</li><li>Web2.0主要托生于DHTML和AJAX这类JavaScript的能力扩展\r</li>\r<br />前端技术体系的介绍可以告一段落,我们并没有把一个个概念的英文缩写展开,然后抄来晦涩的官方的解释.\r<br />\"使用Http传输HTML文档,文档被解析成DOM树,CSS负责布局和样式,JS提供计算能力,处理事件响应,Cookie维持会话.\"\r<br />没错,如果换你来写一个浏览器,会不会也这样做?那么其他的客户端图形交互系统,是不是也一样要完成传输,展现,事件交互等等功能?\r<br />如果我继续介绍一下firebug这类前端开发工具,将其与七种武器对应上,再辅以一些API文档,就可以尝试体验下前端开发了.\r<br />\r<br /><strong>最后和前端开发讲几句</strong>\r<br />读到这里的前端开发,先说声抱歉,写了这么长,通篇都是你烂熟于心的内容.而且你明明了解更多,这里却没有提到.\r<br />其实要点就在这里,如何在你所有知道的内容中提出来若干要点,完整的描述前端技术体系,这件事情对于前端开发而言,重要么?不重要么?重要么?不重要么?我们看几个问题:\r<br />\r<br />为什么会有DHTML?\r<br />我们了解Http,HTML,CSS,JS的协作关系,知道DOM树是一切的依托,我们才会想到通过改变DOM树来操纵网页内的一切.\r<br />\r<br />为什么会有Ajax?\r<br />我们了解DHTML的能力,却不知道其用武之地,后来我们想到依靠服务端指导.接下来我们又知道所有服务端内容都是通过Http获得,自然我们需要JavaScript能够操作的Http对象.\r<br />\r<br />这些问题需要前端开发去发现,去解决.虽然大家都在跟着先贤们的步子走,很少能成为领域的开拓者,但是否了解整个前端技术体系的区别是你是否是在盲目跟风.区别是当一项新技术出现的时候是否能发现其解决的核心问题以及为解决问题付出的额外代价.\r<br />\r<br />引入新技术的需要付出的额外代价是我要强调的另一个重点,使用DHTML的代价是什么,严重依赖Ajax的代价又是什么?了解这些然后我们才能更好的权衡要不要使用.\r<br />\r<br />前端的发展依然在继续,遇到什么问题?如何解决?\r<li>Cookie容量小,每次随Http发送,是否通过JS在客户端存储更多数据? -- LocalStorage\r</li><li>JS单线程,能否让JS进行大量计算的时候,页面不再挂起? -- WebWorkers\r</li><li>JS语言过于随意,依赖繁杂,如何组织代码能方便共享智慧? -- CommonJS Modules\r</li><li>Http无状态短连接,能否让客户端更及时收到服务端消息?&nbsp; -- 各种Comet\r</li><li>Http头较大无法压缩,无法一个请求返回多个数据对象,怎么办? -- 使用SPDY协议\r</li>\r<br />解决问题付出什么代价?是否涵盖了所有常用浏览器,如果不能是否做到了渐进增强?我们要不要这样做?这些是做一名合格的前端,做一名对技术架构有影响力的前端,必然面对的问题.\r<br />\r<br />前端技术体系,看起来题目很大,但其实并没有玄之又玄的东西在里边,所以即便我写的算不得优秀,但是说清楚还是可以的.我在面试高级前端的时候其实很在意前端大局观,不然叫我如何放心的把一个将会持续发展的产品交到他手里.\n              \n              <br/><br/>\n              <span style=\"color:red;\">\n                <a href=\"http://limu.iteye.com/blog/986724#comments\" style=\"color:red;\">已有 <strong>1</strong> 人发表留言，猛击-&gt;&gt;<strong>这里</strong>&lt;&lt;-参与讨论</a>\n              </span>\n              <br/><br/><br/>\n<span style=\"color:#E28822;\">ITeye推荐</span>\n<br/>\n<ul><li><a href='/clicks/433' target='_blank'><span style=\"color:red;font-weight:bold;\">—软件人才免语言低担保 赴美带薪读研！— </span></a></li></ul>\n<br/><br/><br/>\n              \n            "
            ],
            "pubDate": [
              "Tue, 05 Apr 2011 16:56:22 +0800"
            ],
            "link": [
              "http://limu.iteye.com/blog/986724"
            ],
            "guid": [
              {
                "_": "http://limu.iteye.com/blog/986724",
                "$": {
                  "isPermaLink": "false"
                }
              }
            ]
          },
          {
            "title": [
              "团队年终技术Review,也包含Velocity和D2的一些相关话题"
            ],
            "description": [
              "\n              \n              上周和广告引擎的前端团队和广告MED的前端团队进行了年底技术Review.\r<br />同时也结合D2和Velocity的一些相关话题,进行一些技术讨论.\r<br />\r<br />包括我们在今年制作的类似Facebook Quickling Pagecache以及新版twitter架构的hash驱动单页web app业务系统.\r<br />包括我们在业务系统中开发的类似Microsoft HTC以及Youtube UIX Widget系统的简单的页面组件架构.\r<br />包括我们今年在广告展现端,主推的第三方广告代码接口无阻化,以及对老的广告埋点的性能优化.\r<br />包括我们在第三方代码中实现极轻量级无限可扩展支持依赖关系模块化的一些细节.\r<br />\r<br />\r<br /><a href=\"http://www.slideshare.net/leneli/tbad-f2e-2010-review\" target=\"_blank\">slideshare地址在此</a>\r<br />\n              \n              <br/><br/>\n              <span style=\"color:red;\">\n                <a href=\"http://limu.iteye.com/blog/852813#comments\" style=\"color:red;\">已有 <strong>0</strong> 人发表留言，猛击-&gt;&gt;<strong>这里</strong>&lt;&lt;-参与讨论</a>\n              </span>\n              <br/><br/><br/>\n<span style=\"color:#E28822;\">ITeye推荐</span>\n<br/>\n<ul><li><a href='/clicks/433' target='_blank'><span style=\"color:red;font-weight:bold;\">—软件人才免语言低担保 赴美带薪读研！— </span></a></li></ul>\n<br/><br/><br/>\n              \n            "
            ],
            "pubDate": [
              "Mon, 27 Dec 2010 14:20:57 +0800"
            ],
            "link": [
              "http://limu.iteye.com/blog/852813"
            ],
            "guid": [
              {
                "_": "http://limu.iteye.com/blog/852813",
                "$": {
                  "isPermaLink": "false"
                }
              }
            ]
          },
          {
            "title": [
              "如果给JS代码发布正式使用前增加一个编译步骤,我们能做些什么."
            ],
            "description": [
              "\n              \n              最近看了Hedger Wang的\"<a href=\"http://calendar.perfplanet.com/2010/coding-better-object-oriented-javascript-with-closure-compiler/\" target=\"_blank\">Coding Better Object-Oriented JavaScript with Closure Compiler</a>\"(<a href=\"http://www.cnblogs.com/georgewing/archive/2010/12/15/1902902.html\" target=\"_blank\">中文</a>),算是给D2预热.终于明白Google这工具为啥叫Compiler而不是Compressor.\r<br />\r<br />相对于编译型语言,JavaScript缺少了编译这个环节.传统编译器把代码转换为可执行的机器指令的动作交由浏览器中的JS引擎在运行时执行.但现代的编译器除了代码翻译还有哪些功能?而JS引擎能在运行时Cover住这些任务么?\r<br />\r<br />最常见的运行时编译无法解决的问题就是代码压缩.所以我们有各种Compressor让代码传输给浏览器的时是最小的.\r<br />而在这篇文章中Google Closure Complier告诉我们还可以在编译时统一OO风格,减小对象深度以提高访问速度,使用枚举,常量等等其他语言好用的特性.\r<br />\r<br />但看了文章之后我还是没有马上使用GCC这些高级功能的打算.\r<br />预编译时只能做这么多么?\r<br /><span style=\"color: red;\">我觉得Google Closure Complier更有意义的是告诉我们,可以有这样一个发布前预编译的步骤,可以有这样的一个时间窗口,在这个时候结合我们自己的应用,结合我们自己遇到的问题是不是也可以做点什么.</span>\r<br />\r<br />最近我在做kissyLite,前一篇文章<a href=\"http://limu.iteye.com/blog/840159\" target=\"_blank\">kissyLite的包管理和无需预先注册的带依赖关系模块异步加载</a>,讲的是用较少的代码为JS引入具有良好扩展性的模块化.就这个应用场景,我们可以在预编译的环节做点什么.\r<br />\r<br /><span style=\"font-size: large;\"><strong>场景一</strong></span>\r<br />\r<br />mod开发者开发一个功能,将它封装在mod-a中.\r<br />然后我们发现mod-a中可以抽象出来mod-b,让mod-b其他地方也能使用到.\r<br />于是就有了mod-b,同时mod-a requires mod-b.\r<br />\r<br />mod使用者的代码始终是KSLITE.use('mod-a',function(){});\r<br />\r<br />由于原有mod-a被拆分,就需要串行的加载mod-a,mod-b.\r<br />因为以kissyLite的模块化模式,在mod-a加载进来之前是不清楚它require mod-b的.\r<br />\r<br />为了颗粒化可重用,造成了性能的损失 -- 多了一个请求,而且是串行的.\r<br />\r<br /><strong>通过预编译能解决这个问题么?可以.</strong>\r<br />\r<br />模块使用者,使用Debug(带预编译相关功能)版本的kissylite,控制台就可以给出两个优化建议:\r<br />\"为了让子模块能够平行加载,你应该修改此处代码为KSLITE.use('mod-a,mod-b');!\"\r<br />可见至少我们解决了平行加载的问题.\r<br />而且我们可以在开发的时候完全不去考虑这个问题,当所有功能做好之后再来优化,这其实就是预编译时优化功能.\r<br />\r<br /><span style=\"font-size: large;\"><strong>场景二</strong></span>\r<br />\r<br />mod开发者还是发现mod-a中可以抽象出来mod-b,让mod-b其他地方也能使用到.\r<br />这次他非常清楚过细的颗粒化会引入更多的请求和串行加载等性能问题.\r<br />所以他在纠结到底要不要为了可能的重用单独先提出来mod-b.\r<br />\r<br /><strong>通过预编译能解决这个问题么?如果预编译模块能结合自动化测试和自动构建,可以</strong>\r<br />首先回答:要将mod-b拆出来!\r<br />当我们把当前应用所有重要的测试用例都跑过一遍之后,发现当前的所有应用场景mod-b都是跟着mod-a进来的.\r<br />那么预编译可以给出优化建议\r<br />\"为了减少请求数,可以将mod-b的内容追加到mod-a的后面\".\r<br />因为mod-a必须要叫上mod-b,而当前mod-b还没有被单独使用,不如合并.\r<br />甚至可以结合自动构建工具,给出最适合当前应用的kissy版本kissy4U.\r<br />\"为了减少请求数,这次构建已经吧mod-b的内容追加到mod-a的后面:)\".\r<br />基准的kissy版本,mod-a和mod-b每个都是独立的.\r<br />而在为你应用构建的kissy4U中,mod-b在mod-a文件中.\r<br />不用纠结提出mod-b引入的性能问题了,写最优雅的代码吧.\r<br />\r<br /><span style=\"font-size: large;\"><strong>场景三</strong></span>\r<br />还是mod-b要不要跟着mod-a一同输出.\r<br />现在问题又变化了,mod-b可能被单独使用,也可能被mod-a调用.\r<br />还要不要合并mod-a mod-b 到mod-a.js呢?\r<br />到底是先use mod-b 再 use mod-a的情况多呢?(这样显然不要合并文件)\r<br />还是直接就use-a的情况多呢?(这样还是合并了好点)\r<br />\r<br /><strong>通过预编译能解决这个问题么?如果预编译模块能结合线上实际使用情况的统计反馈数据,可以.</strong>\r<br />我们参见Facebook的<a href=\"http://velocity.oreilly.com.cn/index.php?func=session&amp;name=%E9%9D%99%E6%80%81%E7%BD%91%E9%A1%B5%E8%B5%84%E6%BA%90%E7%9A%84%E7%AE%A1%E7%90%86%E5%92%8C%E4%BC%98%E5%8C%96\" target=\"_blank\">静态网页资源的管理和优化</a>\r<br />我们有了抽样统计数据的反馈,就可以在预编译阶段根据反馈来决定要不要合并mod-a和mod-b.\r<br />\r<br /><span style=\"font-size: large;\"><strong>场景四</strong></span>\r<br />add时到底要不要attach?\r<br />add的重要功能是注册一个模块,当这个模块不依赖其他模块或所依赖的内容都可用.那就具备attach的条件,要不要attach呢?\r<br />如果attach了,use的时候更快.如果不attach,页面加载更快.\r<br />\r<br />回答问题:add的时候不要attach.\r<br />默认attach引入的代码运行消耗是不必要的.微软还有一个专门的工具<a href=\"http://www.stevesouders.com/blog/2009/09/08/doloto-javascript-download-optimizer/\" target=\"_blank\">Doloto</a>来拆分加载时必要的代码和不必要的.\r<br />\r<br />但这样做use的时候可能就会慢了.尤其use还可能涉及异步模块加载...\r<br />跟随微软的思路我们很容易想到办法,在domready之后,浏览器不忙的时候把可能用到的模块预先attach.\r<br />我称这个动作为预热.那该预热哪些?页面上有几十个功能都预热么?\r<br />\r<br /><strong>通过预编译能解决这个问题么?依然可以.</strong>\r<br />在页面开发完之后把将会常用的功能使用一遍.然后编译器就可以给出提示.\r<br />\"应该在domready的之后use('a,b,c,d'),进行预先attach\".\r<br />即domready前按需加载,domready后选择性预热.\r<br />\r<br /><span style=\"font-size: large;\"><strong>预编译打开一扇窗</strong></span>\r<br />可以看到针对kissyLite这个具体的应用:\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 利用好这个环节,模块开发者的模块的划分,不必再因为性能问题而纠结.\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 利用好这个环节,应用开发者可以配置出最优的代码打包方案,如Facebook做的那样.\r<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 利用好这个环节,模块化架构可以不必纠结add时attach影响页面速度,不attach又拖慢功能使用.\r<br />但这不重要,可能没有一条适合你.\r<br />\r<br />我们看到Hedger Wang在文章开头先抱怨了一通,然后使用GCC解决了这些问题.\r<br />而这里给出的几个场景完全不同,又何其相似.\r<br />我们也抱怨一通,然后经GCC启发,在其引入的预编译阶段也解决了这些问题.\r<br />\r<br /><strong>每个应用都会遇到自己独特的问题被抱怨,也能在预编译这个时间窗口解决一些什么么?</strong>\r<br />\r<br />\n              \n              <br/><br/>\n              <span style=\"color:red;\">\n                <a href=\"http://limu.iteye.com/blog/845870#comments\" style=\"color:red;\">已有 <strong>0</strong> 人发表留言，猛击-&gt;&gt;<strong>这里</strong>&lt;&lt;-参与讨论</a>\n              </span>\n              <br/><br/><br/>\n<span style=\"color:#E28822;\">ITeye推荐</span>\n<br/>\n<ul><li><a href='/clicks/433' target='_blank'><span style=\"color:red;font-weight:bold;\">—软件人才免语言低担保 赴美带薪读研！— </span></a></li></ul>\n<br/><br/><br/>\n              \n            "
            ],
            "pubDate": [
              "Fri, 17 Dec 2010 18:18:13 +0800"
            ],
            "link": [
              "http://limu.iteye.com/blog/845870"
            ],
            "guid": [
              {
                "_": "http://limu.iteye.com/blog/845870",
                "$": {
                  "isPermaLink": "false"
                }
              }
            ]
          }
        ]
      }
    ]
  }
}